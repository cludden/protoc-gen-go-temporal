// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/xnserr/v1/xnserr.proto
package xnserrv1

import (
	"context"
	"errors"
	"fmt"
	xnsv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/xns/v1"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"log/slog"
	"os"
	"sort"
	"sync/atomic"
	"time"
)

// ServerTaskQueue is the default task-queue for a test.xnserr.v1.Server worker
var ServerTaskQueue = "xnserr-server-v1"

// test.xnserr.v1.Server workflow names
const (
	SleepWorkflowName = "test.xnserr.v1.Server.Sleep"
)

// ServerClient describes a client for a(n) test.xnserr.v1.Server worker
type ServerClient interface {
	// Sleep executes a(n) test.xnserr.v1.Server.Sleep workflow and blocks until error or response received
	Sleep(ctx context.Context, req *SleepRequest, opts ...*SleepOptions) error

	// SleepAsync starts a(n) test.xnserr.v1.Server.Sleep workflow and returns a handle to the workflow run
	SleepAsync(ctx context.Context, req *SleepRequest, opts ...*SleepOptions) (SleepRun, error)

	// GetSleep retrieves a handle to an existing test.xnserr.v1.Server.Sleep workflow execution
	GetSleep(ctx context.Context, workflowID string, runID string) SleepRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// serverClient implements a temporal client for a test.xnserr.v1.Server service
type serverClient struct {
	client client.Client
	log    *slog.Logger
}

// NewServerClient initializes a new test.xnserr.v1.Server client
func NewServerClient(c client.Client, options ...*serverClientOptions) ServerClient {
	var cfg *serverClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewServerClientOptions()
	}
	return &serverClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewServerClientWithOptions initializes a new Server client with the given options
func NewServerClientWithOptions(c client.Client, opts client.Options, options ...*serverClientOptions) (ServerClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *serverClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewServerClientOptions()
	}
	return &serverClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// serverClientOptions describes optional runtime configuration for a ServerClient
type serverClientOptions struct {
	log *slog.Logger
}

// NewServerClientOptions initializes a new serverClientOptions value
func NewServerClientOptions() *serverClientOptions {
	return &serverClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *serverClientOptions) WithLogger(l *slog.Logger) *serverClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *serverClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.xnserr.v1.Server.Sleep executes a test.xnserr.v1.Server.Sleep workflow and blocks until error or response received
func (c *serverClient) Sleep(ctx context.Context, req *SleepRequest, options ...*SleepOptions) error {
	run, err := c.SleepAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SleepAsync starts a(n) test.xnserr.v1.Server.Sleep workflow and returns a handle to the workflow run
func (c *serverClient) SleepAsync(ctx context.Context, req *SleepRequest, options ...*SleepOptions) (SleepRun, error) {
	var o *SleepOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSleepOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SleepWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &sleepRun{
		client: c,
		run:    run,
	}, nil
}

// GetSleep fetches an existing test.xnserr.v1.Server.Sleep execution
func (c *serverClient) GetSleep(ctx context.Context, workflowID string, runID string) SleepRun {
	return &sleepRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *serverClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *serverClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// SleepOptions provides configuration for a test.xnserr.v1.Server.Sleep workflow operation
type SleepOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewSleepOptions initializes a new SleepOptions value
func NewSleepOptions() *SleepOptions {
	return &SleepOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SleepOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ServerTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SleepOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SleepOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SleepOptions) WithExecutionTimeout(d time.Duration) *SleepOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SleepOptions) WithID(id string) *SleepOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SleepOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SleepOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SleepOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SleepOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SleepOptions) WithRunTimeout(d time.Duration) *SleepOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SleepOptions) WithSearchAttributes(sa map[string]any) *SleepOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SleepOptions) WithTaskTimeout(d time.Duration) *SleepOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SleepOptions) WithTaskQueue(tq string) *SleepOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *SleepOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *SleepOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// SleepRun describes a(n) test.xnserr.v1.Server.Sleep workflow run
type SleepRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// sleepRun provides an internal implementation of a(n) SleepRunRun
type sleepRun struct {
	client *serverClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *sleepRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *sleepRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *sleepRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *sleepRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *sleepRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *sleepRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// SleepFunction implements a "test.xnserr.v1.Server.Sleep" workflow
	SleepFunction func(workflow.Context, *SleepRequest) error
)

// ServerWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// ServerWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	ServerWorkflowFunctions interface {
		// Sleep executes a "test.xnserr.v1.Server.Sleep" workflow inline
		Sleep(workflow.Context, *SleepRequest) error
	}
	// serverWorkflowFunctions provides an internal ServerWorkflowFunctions implementation
	serverWorkflowFunctions struct{}
)

func NewServerWorkflowFunctions() ServerWorkflowFunctions {
	return &serverWorkflowFunctions{}
}

// Sleep executes a "test.xnserr.v1.Server.Sleep" workflow inline
func (f *serverWorkflowFunctions) Sleep(ctx workflow.Context, req *SleepRequest) error {
	if SleepFunction == nil {
		return errors.New("Sleep requires workflow registration via RegisterServerWorkflows or RegisterSleepWorkflow")
	}
	return SleepFunction(ctx, req)
}

// ServerWorkflows provides methods for initializing new test.xnserr.v1.Server workflow values
type ServerWorkflows interface {
	// Sleep initializes a new a(n) SleepWorkflow implementation
	Sleep(ctx workflow.Context, input *SleepWorkflowInput) (SleepWorkflow, error)
}

// RegisterServerWorkflows registers test.xnserr.v1.Server workflows with the given worker
func RegisterServerWorkflows(r worker.WorkflowRegistry, workflows ServerWorkflows) {
	RegisterSleepWorkflow(r, workflows.Sleep)
}

// RegisterSleepWorkflow registers a test.xnserr.v1.Server.Sleep workflow with the given worker
func RegisterSleepWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SleepWorkflowInput) (SleepWorkflow, error)) {
	SleepFunction = buildSleep(wf)
	r.RegisterWorkflowWithOptions(SleepFunction, workflow.RegisterOptions{Name: SleepWorkflowName})
}

// buildSleep converts a Sleep workflow struct into a valid workflow function
func buildSleep(ctor func(workflow.Context, *SleepWorkflowInput) (SleepWorkflow, error)) func(workflow.Context, *SleepRequest) error {
	return func(ctx workflow.Context, req *SleepRequest) error {
		input := &SleepWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// SleepWorkflowInput describes the input to a(n) test.xnserr.v1.Server.Sleep workflow constructor
type SleepWorkflowInput struct {
	Req *SleepRequest
}

// SleepWorkflow describes a(n) test.xnserr.v1.Server.Sleep workflow implementation
type SleepWorkflow interface {
	// Execute defines the entrypoint to a(n) test.xnserr.v1.Server.Sleep workflow
	Execute(ctx workflow.Context) error
}

// SleepChild executes a child test.xnserr.v1.Server.Sleep workflow and blocks until error or response received
func SleepChild(ctx workflow.Context, req *SleepRequest, options ...*SleepChildOptions) error {
	childRun, err := SleepChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// SleepChildAsync starts a child test.xnserr.v1.Server.Sleep workflow and returns a handle to the child workflow run
func SleepChildAsync(ctx workflow.Context, req *SleepRequest, options ...*SleepChildOptions) (*SleepChildRun, error) {
	var o *SleepChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSleepChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &SleepChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SleepWorkflowName, req)}, nil
}

// SleepChildOptions provides configuration for a child test.xnserr.v1.Server.Sleep workflow operation
type SleepChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewSleepChildOptions initializes a new SleepChildOptions value
func NewSleepChildOptions() *SleepChildOptions {
	return &SleepChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SleepChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_REJECT_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ServerTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	} else if opts.ParentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SleepChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SleepChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *SleepChildOptions) WithDataConverter(dc converter.DataConverter) *SleepChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SleepChildOptions) WithExecutionTimeout(d time.Duration) *SleepChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SleepChildOptions) WithID(id string) *SleepChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SleepChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SleepChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SleepChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SleepChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SleepChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SleepChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SleepChildOptions) WithRunTimeout(d time.Duration) *SleepChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SleepChildOptions) WithSearchAttributes(sa map[string]any) *SleepChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SleepChildOptions) WithTaskTimeout(d time.Duration) *SleepChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SleepChildOptions) WithTaskQueue(tq string) *SleepChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SleepChildOptions) WithWaitForCancellation(wait bool) *SleepChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *SleepChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *SleepChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// SleepChildRun describes a child Sleep workflow run
type SleepChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SleepChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SleepChildRun) Select(sel workflow.Selector, fn func(*SleepChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SleepChildRun) SelectStart(sel workflow.Selector, fn func(*SleepChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SleepChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// ServerActivities describes available worker activities
type ServerActivities interface{}

// RegisterServerActivities registers activities with a worker
func RegisterServerActivities(r worker.ActivityRegistry, activities ServerActivities) {}

// TestClient provides a testsuite-compatible Client
type TestServerClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ServerWorkflows
}

var _ ServerClient = &TestServerClient{}

// NewTestServerClient initializes a new TestServerClient value
func NewTestServerClient(env *testsuite.TestWorkflowEnvironment, workflows ServerWorkflows, activities ServerActivities) *TestServerClient {
	if workflows != nil {
		RegisterServerWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterServerActivities(env, activities)
	}
	return &TestServerClient{env, workflows}
}

// Sleep executes a(n) test.xnserr.v1.Server.Sleep workflow in the test environment
func (c *TestServerClient) Sleep(ctx context.Context, req *SleepRequest, opts ...*SleepOptions) error {
	run, err := c.SleepAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SleepAsync executes a(n) test.xnserr.v1.Server.Sleep workflow in the test environment
func (c *TestServerClient) SleepAsync(ctx context.Context, req *SleepRequest, options ...*SleepOptions) (SleepRun, error) {
	var o *SleepOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSleepOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSleepRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSleep is a noop
func (c *TestServerClient) GetSleep(ctx context.Context, workflowID string, runID string) SleepRun {
	return &testSleepRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestServerClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestServerClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ SleepRun = &testSleepRun{}

// testSleepRun provides convenience methods for interacting with a(n) test.xnserr.v1.Server.Sleep workflow in the test environment
type testSleepRun struct {
	client    *TestServerClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *SleepRequest
	workflows ServerWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSleepRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.xnserr.v1.Server.Sleep workflow result
func (r *testSleepRun) Get(context.Context) error {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(SleepWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test test.xnserr.v1.Server.Sleep workflow run's workflow ID
func (r *testSleepRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSleepRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSleepRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSleepRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// ServerCliOptions describes runtime configuration for test.xnserr.v1.Server cli
type ServerCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewServerCliOptions initializes a new ServerCliOptions value
func NewServerCliOptions() *ServerCliOptions {
	return &ServerCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ServerCliOptions) WithAfter(fn func(*v2.Context) error) *ServerCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ServerCliOptions) WithBefore(fn func(*v2.Context) error) *ServerCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ServerCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ServerCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ServerCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ServerCliOptions {
	opts.worker = fn
	return opts
}

// NewServerCli initializes a cli for a(n) test.xnserr.v1.Server service
func NewServerCli(options ...*ServerCliOptions) (*v2.App, error) {
	commands, err := newServerCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:                      "server",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// NewServerCliCommand initializes a cli command for a test.xnserr.v1.Server service with subcommands for each query, signal, update, and workflow
func NewServerCliCommand(options ...*ServerCliOptions) (*v2.Command, error) {
	subcommands, err := newServerCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "server",
		Subcommands: subcommands,
	}, nil
}

// newServerCommands initializes (sub)commands for a test.xnserr.v1.Server cli or command
func newServerCommands(options ...*ServerCliOptions) ([]*v2.Command, error) {
	opts := &ServerCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "sleep",
			Usage:                  "executes a(n) test.xnserr.v1.Server.Sleep workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "xnserr-server-v1",
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&v2.DurationFlag{
					Name:     "sleep",
					Usage:    "set the value of the operation's \"Sleep\" parameter (e.g. \"3.000000001s\")",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "failure",
					Usage:    "set the value of the operation's \"Failure\" parameter (json-encoded: {message: <string>, nonRetryable: <bool>, info: <test.xnserr.v1.FailureInfo>, applicationErrorType: <string>})",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewServerClient(tc)
				req, err := UnmarshalCliFlagsToSleepRequest(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SleepAsync(cmd.Context, req, NewSleepOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SleepWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.xnserr.v1.Server worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToSleepRequest unmarshals a SleepRequest from command line flags
func UnmarshalCliFlagsToSleepRequest(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*SleepRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result SleepRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("sleep"); cmd.IsSet(flag) {
		value := durationpb.New(cmd.Duration(flag))
		result.Sleep = value
	}
	if flag := opts.FlagName("failure"); cmd.IsSet(flag) {
		var tmp Failure
		if err := protojson.Unmarshal([]byte(cmd.String(flag)), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"failure\" flag: %w", err)
		}
		value := &tmp
		result.Failure = value
	}
	return &result, nil
}

// WithServerSchemeTypes registers all Server protobuf types with the given scheme
func WithServerSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_xnserr_v1_xnserr_proto.Messages().ByName("SleepRequest"))
	}
}

// ClientTaskQueue is the default task-queue for a test.xnserr.v1.Client worker
var ClientTaskQueue = "xnserr-client-v1"

// test.xnserr.v1.Client workflow names
const (
	CallSleepWorkflowName = "test.xnserr.v1.Client.CallSleep"
)

// ClientClient describes a client for a(n) test.xnserr.v1.Client worker
type ClientClient interface {
	// CallSleep executes a(n) test.xnserr.v1.Client.CallSleep workflow and blocks until error or response received
	CallSleep(ctx context.Context, req *CallSleepRequest, opts ...*CallSleepOptions) error

	// CallSleepAsync starts a(n) test.xnserr.v1.Client.CallSleep workflow and returns a handle to the workflow run
	CallSleepAsync(ctx context.Context, req *CallSleepRequest, opts ...*CallSleepOptions) (CallSleepRun, error)

	// GetCallSleep retrieves a handle to an existing test.xnserr.v1.Client.CallSleep workflow execution
	GetCallSleep(ctx context.Context, workflowID string, runID string) CallSleepRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// clientClient implements a temporal client for a test.xnserr.v1.Client service
type clientClient struct {
	client client.Client
	log    *slog.Logger
}

// NewClientClient initializes a new test.xnserr.v1.Client client
func NewClientClient(c client.Client, options ...*clientClientOptions) ClientClient {
	var cfg *clientClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewClientClientOptions()
	}
	return &clientClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewClientClientWithOptions initializes a new Client client with the given options
func NewClientClientWithOptions(c client.Client, opts client.Options, options ...*clientClientOptions) (ClientClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *clientClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewClientClientOptions()
	}
	return &clientClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// clientClientOptions describes optional runtime configuration for a ClientClient
type clientClientOptions struct {
	log *slog.Logger
}

// NewClientClientOptions initializes a new clientClientOptions value
func NewClientClientOptions() *clientClientOptions {
	return &clientClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *clientClientOptions) WithLogger(l *slog.Logger) *clientClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *clientClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.xnserr.v1.Client.CallSleep executes a test.xnserr.v1.Client.CallSleep workflow and blocks until error or response received
func (c *clientClient) CallSleep(ctx context.Context, req *CallSleepRequest, options ...*CallSleepOptions) error {
	run, err := c.CallSleepAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// CallSleepAsync starts a(n) test.xnserr.v1.Client.CallSleep workflow and returns a handle to the workflow run
func (c *clientClient) CallSleepAsync(ctx context.Context, req *CallSleepRequest, options ...*CallSleepOptions) (CallSleepRun, error) {
	var o *CallSleepOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallSleepOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, CallSleepWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &callSleepRun{
		client: c,
		run:    run,
	}, nil
}

// GetCallSleep fetches an existing test.xnserr.v1.Client.CallSleep execution
func (c *clientClient) GetCallSleep(ctx context.Context, workflowID string, runID string) CallSleepRun {
	return &callSleepRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *clientClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *clientClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// CallSleepOptions provides configuration for a test.xnserr.v1.Client.CallSleep workflow operation
type CallSleepOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewCallSleepOptions initializes a new CallSleepOptions value
func NewCallSleepOptions() *CallSleepOptions {
	return &CallSleepOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *CallSleepOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ClientTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *CallSleepOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *CallSleepOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CallSleepOptions) WithExecutionTimeout(d time.Duration) *CallSleepOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *CallSleepOptions) WithID(id string) *CallSleepOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CallSleepOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CallSleepOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CallSleepOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CallSleepOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CallSleepOptions) WithRunTimeout(d time.Duration) *CallSleepOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CallSleepOptions) WithSearchAttributes(sa map[string]any) *CallSleepOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CallSleepOptions) WithTaskTimeout(d time.Duration) *CallSleepOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CallSleepOptions) WithTaskQueue(tq string) *CallSleepOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *CallSleepOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *CallSleepOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// CallSleepRun describes a(n) test.xnserr.v1.Client.CallSleep workflow run
type CallSleepRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// callSleepRun provides an internal implementation of a(n) CallSleepRunRun
type callSleepRun struct {
	client *clientClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *callSleepRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *callSleepRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *callSleepRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *callSleepRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *callSleepRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *callSleepRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// CallSleepFunction implements a "test.xnserr.v1.Client.CallSleep" workflow
	CallSleepFunction func(workflow.Context, *CallSleepRequest) error
)

// ClientWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// ClientWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	ClientWorkflowFunctions interface {
		// CallSleep executes a "test.xnserr.v1.Client.CallSleep" workflow inline
		CallSleep(workflow.Context, *CallSleepRequest) error
	}
	// clientWorkflowFunctions provides an internal ClientWorkflowFunctions implementation
	clientWorkflowFunctions struct{}
)

func NewClientWorkflowFunctions() ClientWorkflowFunctions {
	return &clientWorkflowFunctions{}
}

// CallSleep executes a "test.xnserr.v1.Client.CallSleep" workflow inline
func (f *clientWorkflowFunctions) CallSleep(ctx workflow.Context, req *CallSleepRequest) error {
	if CallSleepFunction == nil {
		return errors.New("CallSleep requires workflow registration via RegisterClientWorkflows or RegisterCallSleepWorkflow")
	}
	return CallSleepFunction(ctx, req)
}

// ClientWorkflows provides methods for initializing new test.xnserr.v1.Client workflow values
type ClientWorkflows interface {
	// CallSleep initializes a new a(n) CallSleepWorkflow implementation
	CallSleep(ctx workflow.Context, input *CallSleepWorkflowInput) (CallSleepWorkflow, error)
}

// RegisterClientWorkflows registers test.xnserr.v1.Client workflows with the given worker
func RegisterClientWorkflows(r worker.WorkflowRegistry, workflows ClientWorkflows) {
	RegisterCallSleepWorkflow(r, workflows.CallSleep)
}

// RegisterCallSleepWorkflow registers a test.xnserr.v1.Client.CallSleep workflow with the given worker
func RegisterCallSleepWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *CallSleepWorkflowInput) (CallSleepWorkflow, error)) {
	CallSleepFunction = buildCallSleep(wf)
	r.RegisterWorkflowWithOptions(CallSleepFunction, workflow.RegisterOptions{Name: CallSleepWorkflowName})
}

// buildCallSleep converts a CallSleep workflow struct into a valid workflow function
func buildCallSleep(ctor func(workflow.Context, *CallSleepWorkflowInput) (CallSleepWorkflow, error)) func(workflow.Context, *CallSleepRequest) error {
	return func(ctx workflow.Context, req *CallSleepRequest) error {
		input := &CallSleepWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// CallSleepWorkflowInput describes the input to a(n) test.xnserr.v1.Client.CallSleep workflow constructor
type CallSleepWorkflowInput struct {
	Req *CallSleepRequest
}

// CallSleepWorkflow describes a(n) test.xnserr.v1.Client.CallSleep workflow implementation
type CallSleepWorkflow interface {
	// Execute defines the entrypoint to a(n) test.xnserr.v1.Client.CallSleep workflow
	Execute(ctx workflow.Context) error
}

// CallSleepChild executes a child test.xnserr.v1.Client.CallSleep workflow and blocks until error or response received
func CallSleepChild(ctx workflow.Context, req *CallSleepRequest, options ...*CallSleepChildOptions) error {
	childRun, err := CallSleepChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// CallSleepChildAsync starts a child test.xnserr.v1.Client.CallSleep workflow and returns a handle to the child workflow run
func CallSleepChildAsync(ctx workflow.Context, req *CallSleepRequest, options ...*CallSleepChildOptions) (*CallSleepChildRun, error) {
	var o *CallSleepChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallSleepChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &CallSleepChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CallSleepWorkflowName, req)}, nil
}

// CallSleepChildOptions provides configuration for a child test.xnserr.v1.Client.CallSleep workflow operation
type CallSleepChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewCallSleepChildOptions initializes a new CallSleepChildOptions value
func NewCallSleepChildOptions() *CallSleepChildOptions {
	return &CallSleepChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *CallSleepChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ClientTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *CallSleepChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *CallSleepChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *CallSleepChildOptions) WithDataConverter(dc converter.DataConverter) *CallSleepChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CallSleepChildOptions) WithExecutionTimeout(d time.Duration) *CallSleepChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *CallSleepChildOptions) WithID(id string) *CallSleepChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CallSleepChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CallSleepChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *CallSleepChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *CallSleepChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CallSleepChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CallSleepChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CallSleepChildOptions) WithRunTimeout(d time.Duration) *CallSleepChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CallSleepChildOptions) WithSearchAttributes(sa map[string]any) *CallSleepChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CallSleepChildOptions) WithTaskTimeout(d time.Duration) *CallSleepChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CallSleepChildOptions) WithTaskQueue(tq string) *CallSleepChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CallSleepChildOptions) WithWaitForCancellation(wait bool) *CallSleepChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *CallSleepChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *CallSleepChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// CallSleepChildRun describes a child CallSleep workflow run
type CallSleepChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CallSleepChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CallSleepChildRun) Select(sel workflow.Selector, fn func(*CallSleepChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CallSleepChildRun) SelectStart(sel workflow.Selector, fn func(*CallSleepChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CallSleepChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// ClientActivities describes available worker activities
type ClientActivities interface{}

// RegisterClientActivities registers activities with a worker
func RegisterClientActivities(r worker.ActivityRegistry, activities ClientActivities) {}

// TestClient provides a testsuite-compatible Client
type TestClientClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ClientWorkflows
}

var _ ClientClient = &TestClientClient{}

// NewTestClientClient initializes a new TestClientClient value
func NewTestClientClient(env *testsuite.TestWorkflowEnvironment, workflows ClientWorkflows, activities ClientActivities) *TestClientClient {
	if workflows != nil {
		RegisterClientWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterClientActivities(env, activities)
	}
	return &TestClientClient{env, workflows}
}

// CallSleep executes a(n) test.xnserr.v1.Client.CallSleep workflow in the test environment
func (c *TestClientClient) CallSleep(ctx context.Context, req *CallSleepRequest, opts ...*CallSleepOptions) error {
	run, err := c.CallSleepAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// CallSleepAsync executes a(n) test.xnserr.v1.Client.CallSleep workflow in the test environment
func (c *TestClientClient) CallSleepAsync(ctx context.Context, req *CallSleepRequest, options ...*CallSleepOptions) (CallSleepRun, error) {
	var o *CallSleepOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallSleepOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testCallSleepRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCallSleep is a noop
func (c *TestClientClient) GetCallSleep(ctx context.Context, workflowID string, runID string) CallSleepRun {
	return &testCallSleepRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestClientClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestClientClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ CallSleepRun = &testCallSleepRun{}

// testCallSleepRun provides convenience methods for interacting with a(n) test.xnserr.v1.Client.CallSleep workflow in the test environment
type testCallSleepRun struct {
	client    *TestClientClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *CallSleepRequest
	workflows ClientWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testCallSleepRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.xnserr.v1.Client.CallSleep workflow result
func (r *testCallSleepRun) Get(context.Context) error {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(CallSleepWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test test.xnserr.v1.Client.CallSleep workflow run's workflow ID
func (r *testCallSleepRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testCallSleepRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testCallSleepRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testCallSleepRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// ClientCliOptions describes runtime configuration for test.xnserr.v1.Client cli
type ClientCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewClientCliOptions initializes a new ClientCliOptions value
func NewClientCliOptions() *ClientCliOptions {
	return &ClientCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ClientCliOptions) WithAfter(fn func(*v2.Context) error) *ClientCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ClientCliOptions) WithBefore(fn func(*v2.Context) error) *ClientCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ClientCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ClientCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ClientCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ClientCliOptions {
	opts.worker = fn
	return opts
}

// NewClientCli initializes a cli for a(n) test.xnserr.v1.Client service
func NewClientCli(options ...*ClientCliOptions) (*v2.App, error) {
	commands, err := newClientCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:                      "client",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// NewClientCliCommand initializes a cli command for a test.xnserr.v1.Client service with subcommands for each query, signal, update, and workflow
func NewClientCliCommand(options ...*ClientCliOptions) (*v2.Command, error) {
	subcommands, err := newClientCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "client",
		Subcommands: subcommands,
	}, nil
}

// newClientCommands initializes (sub)commands for a test.xnserr.v1.Client cli or command
func newClientCommands(options ...*ClientCliOptions) ([]*v2.Command, error) {
	opts := &ClientCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "call-sleep",
			Usage:                  "executes a(n) test.xnserr.v1.Client.CallSleep workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "xnserr-client-v1",
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&v2.DurationFlag{
					Name:     "sleep",
					Usage:    "set the value of the operation's \"Sleep\" parameter (e.g. \"3.000000001s\")",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "failure",
					Usage:    "set the value of the operation's \"Failure\" parameter (json-encoded: {message: <string>, nonRetryable: <bool>, info: <test.xnserr.v1.FailureInfo>, applicationErrorType: <string>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "start-workflow-options",
					Usage:    "set the value of the operation's \"StartWorkflowOptions\" parameter (json-encoded: {id: <string>, taskQueue: <string>, executionTimeout: <google.protobuf.Duration>, runTimeout: <google.protobuf.Duration>, taskTimeout: <google.protobuf.Duration>, idReusePolicy: <temporal.xns.v1.IDReusePolicy>, errorWhenAlreadyStarted: <bool>, retryPolicy: <temporal.xns.v1.RetryPolicy>, memo: <google.protobuf.Struct>, searchAttirbutes: <google.protobuf.Struct>, enableEagerStart: <bool>, startDelay: <google.protobuf.Duration>, workflowIdConflictPolicy: <temporal.api.enums.v1.WorkflowIdConflictPolicy>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "retry-policy",
					Usage:    "set the value of the operation's \"RetryPolicy\" parameter (json-encoded: {initialInterval: <google.protobuf.Duration>, backoffCoefficient: <double>, maxInterval: <google.protobuf.Duration>, maxAttempts: <int32>, nonRetryableErrorTypes: <string>})",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewClientClient(tc)
				req, err := UnmarshalCliFlagsToCallSleepRequest(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.CallSleepAsync(cmd.Context, req, NewCallSleepOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CallSleepWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.xnserr.v1.Client worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToCallSleepRequest unmarshals a CallSleepRequest from command line flags
func UnmarshalCliFlagsToCallSleepRequest(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*CallSleepRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result CallSleepRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("sleep"); cmd.IsSet(flag) {
		value := durationpb.New(cmd.Duration(flag))
		result.Sleep = value
	}
	if flag := opts.FlagName("failure"); cmd.IsSet(flag) {
		var tmp Failure
		if err := protojson.Unmarshal([]byte(cmd.String(flag)), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"failure\" flag: %w", err)
		}
		value := &tmp
		result.Failure = value
	}
	if flag := opts.FlagName("start-workflow-options"); cmd.IsSet(flag) {
		var tmp xnsv1.StartWorkflowOptions
		if err := protojson.Unmarshal([]byte(cmd.String(flag)), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"start-workflow-options\" flag: %w", err)
		}
		value := &tmp
		result.StartWorkflowOptions = value
	}
	if flag := opts.FlagName("retry-policy"); cmd.IsSet(flag) {
		var tmp xnsv1.RetryPolicy
		if err := protojson.Unmarshal([]byte(cmd.String(flag)), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"retry-policy\" flag: %w", err)
		}
		value := &tmp
		result.RetryPolicy = value
	}
	return &result, nil
}

// WithClientSchemeTypes registers all Client protobuf types with the given scheme
func WithClientSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_xnserr_v1_xnserr_proto.Messages().ByName("CallSleepRequest"))
	}
}
