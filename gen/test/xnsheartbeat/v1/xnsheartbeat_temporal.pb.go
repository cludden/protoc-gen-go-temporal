// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/xnsheartbeat/v1/xnsheartbeat.proto
package xnsheartbeatv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	testutil "github.com/cludden/protoc-gen-go-temporal/pkg/testutil"
	uuid "github.com/google/uuid"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	serviceerror "go.temporal.io/api/serviceerror"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"strings"
	"sync"
	"sync/atomic"
	"time"
)

// XnsHeartbeatServiceTaskQueue is the default task-queue for a test.xnsheartbeat.v1.XnsHeartbeatService worker
var XnsHeartbeatServiceTaskQueue = "xnsheartbeat-v1"

// test.xnsheartbeat.v1.XnsHeartbeatService workflow names
const (
	TestWorkflowWorkflowName = "test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow"
)

// test.xnsheartbeat.v1.XnsHeartbeatService signal names
const (
	TestSignalSignalName = "test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal"
)

// test.xnsheartbeat.v1.XnsHeartbeatService update names
const (
	TestUpdateUpdateName = "test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate"
)

// XnsHeartbeatServiceClient describes a client for a(n) test.xnsheartbeat.v1.XnsHeartbeatService worker
type XnsHeartbeatServiceClient interface {
	// TestWorkflow executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and blocks until error or response received
	TestWorkflow(ctx context.Context, req *TestWorkflowInput, opts ...*TestWorkflowOptions) (*TestWorkflowOutput, error)

	// TestWorkflowAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and returns a handle to the workflow run
	TestWorkflowAsync(ctx context.Context, req *TestWorkflowInput, opts ...*TestWorkflowOptions) (TestWorkflowRun, error)

	// GetTestWorkflow retrieves a handle to an existing test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow execution
	GetTestWorkflow(ctx context.Context, workflowID string, runID string) TestWorkflowRun

	// TestWorkflowWithTestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update on a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow, starting it if necessary, and blocks until update completion
	TestWorkflowWithTestUpdate(ctx context.Context, req *TestWorkflowInput, update *TestUpdateInput, opts ...*TestWorkflowWithTestUpdateOptions) (*TestUpdateOutput, TestWorkflowRun, error)
	// TestWorkflowWithTestUpdateAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update on a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow, starting it if necessary, and returns a handle to the update execution
	TestWorkflowWithTestUpdateAsync(ctx context.Context, req *TestWorkflowInput, update *TestUpdateInput, opts ...*TestWorkflowWithTestUpdateOptions) (TestUpdateHandle, TestWorkflowRun, error)
	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal
	TestSignal(ctx context.Context, workflowID string, runID string, signal *TestSignalInput) error

	// TestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update and blocks until update completion
	TestUpdate(ctx context.Context, workflowID string, runID string, req *TestUpdateInput, opts ...*TestUpdateOptions) (*TestUpdateOutput, error)

	// TestUpdateAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update and returns a handle to the workflow update
	TestUpdateAsync(ctx context.Context, workflowID string, runID string, req *TestUpdateInput, opts ...*TestUpdateOptions) (TestUpdateHandle, error)

	// GetTestUpdate retrieves a handle to an existing test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update
	GetTestUpdate(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (TestUpdateHandle, error)
}

// xnsHeartbeatServiceClient implements a temporal client for a test.xnsheartbeat.v1.XnsHeartbeatService service
type xnsHeartbeatServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewXnsHeartbeatServiceClient initializes a new test.xnsheartbeat.v1.XnsHeartbeatService client
func NewXnsHeartbeatServiceClient(c client.Client, options ...*xnsHeartbeatServiceClientOptions) XnsHeartbeatServiceClient {
	var cfg *xnsHeartbeatServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewXnsHeartbeatServiceClientOptions()
	}
	return &xnsHeartbeatServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewXnsHeartbeatServiceClientWithOptions initializes a new XnsHeartbeatService client with the given options
func NewXnsHeartbeatServiceClientWithOptions(c client.Client, opts client.Options, options ...*xnsHeartbeatServiceClientOptions) (XnsHeartbeatServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *xnsHeartbeatServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewXnsHeartbeatServiceClientOptions()
	}
	return &xnsHeartbeatServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// xnsHeartbeatServiceClientOptions describes optional runtime configuration for a XnsHeartbeatServiceClient
type xnsHeartbeatServiceClientOptions struct {
	log *slog.Logger
}

// NewXnsHeartbeatServiceClientOptions initializes a new xnsHeartbeatServiceClientOptions value
func NewXnsHeartbeatServiceClientOptions() *xnsHeartbeatServiceClientOptions {
	return &xnsHeartbeatServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *xnsHeartbeatServiceClientOptions) WithLogger(l *slog.Logger) *xnsHeartbeatServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *xnsHeartbeatServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow executes a test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and blocks until error or response received
func (c *xnsHeartbeatServiceClient) TestWorkflow(ctx context.Context, req *TestWorkflowInput, options ...*TestWorkflowOptions) (*TestWorkflowOutput, error) {
	run, err := c.TestWorkflowAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// TestWorkflowAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and returns a handle to the workflow run
func (c *xnsHeartbeatServiceClient) TestWorkflowAsync(ctx context.Context, req *TestWorkflowInput, options ...*TestWorkflowOptions) (TestWorkflowRun, error) {
	var o *TestWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewTestWorkflowOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, TestWorkflowWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &testWorkflowRun{
		client: c,
		run:    run,
	}, nil
}

// GetTestWorkflow fetches an existing test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow execution
func (c *xnsHeartbeatServiceClient) GetTestWorkflow(ctx context.Context, workflowID string, runID string) TestWorkflowRun {
	return &testWorkflowRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// TestWorkflowWithTestUpdateOptions is the options for a test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow with a test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update
type TestWorkflowWithTestUpdateOptions struct {
	options         client.UpdateWithStartWorkflowOptions
	workflowOptions *TestWorkflowOptions
	updateOptions   *TestUpdateOptions
}

// NewTestWorkflowWithTestUpdateOptions initializes a new TestWorkflowWithTestUpdateOptions value
func NewTestWorkflowWithTestUpdateOptions() *TestWorkflowWithTestUpdateOptions {
	return &TestWorkflowWithTestUpdateOptions{}
}

// Build transforms TestWorkflowWithTestUpdateOptions into valid client.UpdateWithStartWorkflowOptions
func (o *TestWorkflowWithTestUpdateOptions) Build(ctx context.Context, op func(client.StartWorkflowOptions) client.WithStartWorkflowOperation, input *TestWorkflowInput, update *TestUpdateInput) (options client.UpdateWithStartWorkflowOptions, err error) {
	options = o.options
	if o.workflowOptions == nil {
		o.workflowOptions = NewTestWorkflowOptions()
	}
	swo, err := o.workflowOptions.Build(input.ProtoReflect())
	if err != nil {
		return options, err
	}
	if swo.WorkflowIDConflictPolicy == enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		swo.WorkflowIDConflictPolicy = enumsv1.WORKFLOW_ID_CONFLICT_POLICY_FAIL
	}
	options.StartWorkflowOperation = op(swo)
	if o.updateOptions == nil {
		o.updateOptions = NewTestUpdateOptions()
	}
	uo, err := o.updateOptions.Build(swo.ID, "", update)
	if err != nil {
		return options, err
	}
	options.UpdateOptions = *uo
	return options, nil
}

// WithUpdateWithStartWorkflowOptions sets the UpdateWithStartWorkflowOptions
func (o *TestWorkflowWithTestUpdateOptions) WithUpdateWithStartWorkflowOptions(options client.UpdateWithStartWorkflowOptions) *TestWorkflowWithTestUpdateOptions {
	o.options = options
	return o
}

// WithTestWorkflowOptions sets the WithTestWorkflowOptions
func (o *TestWorkflowWithTestUpdateOptions) WithTestWorkflowOptions(options *TestWorkflowOptions) *TestWorkflowWithTestUpdateOptions {
	o.workflowOptions = options
	return o
}

// WithTestUpdateOptions sets the TestUpdateOptions
func (o *TestWorkflowWithTestUpdateOptions) WithTestUpdateOptions(options *TestUpdateOptions) *TestWorkflowWithTestUpdateOptions {
	o.updateOptions = options
	return o
}

// TestWorkflowWithTestUpdate starts a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update in a transaction
func (c *xnsHeartbeatServiceClient) TestWorkflowWithTestUpdate(ctx context.Context, req *TestWorkflowInput, update *TestUpdateInput, options ...*TestWorkflowWithTestUpdateOptions) (*TestUpdateOutput, TestWorkflowRun, error) {
	updateHandle, run, err := c.TestWorkflowWithTestUpdateAsync(ctx, req, update, options...)
	if err != nil {
		return nil, run, err
	}
	out, err := updateHandle.Get(ctx)
	if err != nil {
		return nil, run, err
	}
	return out, run, nil
}

// TestWorkflowWithTestUpdateAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update in a transaction
func (c *xnsHeartbeatServiceClient) TestWorkflowWithTestUpdateAsync(ctx context.Context, req *TestWorkflowInput, update *TestUpdateInput, options ...*TestWorkflowWithTestUpdateOptions) (TestUpdateHandle, TestWorkflowRun, error) {
	var o *TestWorkflowWithTestUpdateOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewTestWorkflowWithTestUpdateOptions()
	}
	opts, err := o.Build(ctx, func(swo client.StartWorkflowOptions) client.WithStartWorkflowOperation {
		return c.client.NewWithStartWorkflowOperation(swo, TestWorkflowWorkflowName, req)
	}, req, update)
	if err != nil {
		return nil, nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}
	handle, err := c.client.UpdateWithStartWorkflow(ctx, opts)
	if err != nil {
		return nil, nil, err
	}
	return &testUpdateHandle{
		client: c,
		handle: handle,
	}, c.GetTestWorkflow(ctx, handle.WorkflowID(), handle.RunID()), nil
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *xnsHeartbeatServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *xnsHeartbeatServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal to an existing workflow
func (c *xnsHeartbeatServiceClient) TestSignal(ctx context.Context, workflowID string, runID string, signal *TestSignalInput) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, TestSignalSignalName, signal)
}

// test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update to an existing workflow
func (c *xnsHeartbeatServiceClient) TestUpdate(ctx context.Context, workflowID string, runID string, req *TestUpdateInput, opts ...*TestUpdateOptions) (*TestUpdateOutput, error) {
	// initialize update options
	o := NewTestUpdateOptions()
	if len(opts) > 0 && opts[0].Options != nil {
		o = opts[0]
	}

	// call sync update with WorkflowUpdateStageCompleted wait policy
	handle, err := c.TestUpdateAsync(ctx, workflowID, runID, req, o.WithWaitPolicy(client.WorkflowUpdateStageCompleted))
	if err != nil {
		return nil, err
	}

	// block on update completion
	return handle.Get(ctx)
}

// test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update to an existing workflow
func (c *xnsHeartbeatServiceClient) TestUpdateAsync(ctx context.Context, workflowID string, runID string, req *TestUpdateInput, opts ...*TestUpdateOptions) (TestUpdateHandle, error) {
	// initialize update options
	var o *TestUpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewTestUpdateOptions()
	}

	// build UpdateWorkflowOptions
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	// update workflow
	handle, err := c.client.UpdateWorkflow(ctx, *options)
	if err != nil {
		return nil, err
	}
	return &testUpdateHandle{client: c, handle: handle}, nil
}

// GetTestUpdate retrieves a handle to an existing test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update
func (c *xnsHeartbeatServiceClient) GetTestUpdate(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (TestUpdateHandle, error) {
	return &testUpdateHandle{
		client: c,
		handle: c.client.GetWorkflowUpdateHandle(req),
	}, nil
}

// TestWorkflowOptions provides configuration for a test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow operation
type TestWorkflowOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewTestWorkflowOptions initializes a new TestWorkflowOptions value
func NewTestWorkflowOptions() *TestWorkflowOptions {
	return &TestWorkflowOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *TestWorkflowOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = XnsHeartbeatServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *TestWorkflowOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *TestWorkflowOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *TestWorkflowOptions) WithEnableEagerStart(enable bool) *TestWorkflowOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *TestWorkflowOptions) WithExecutionTimeout(d time.Duration) *TestWorkflowOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *TestWorkflowOptions) WithID(id string) *TestWorkflowOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *TestWorkflowOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *TestWorkflowOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *TestWorkflowOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *TestWorkflowOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *TestWorkflowOptions) WithRunTimeout(d time.Duration) *TestWorkflowOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *TestWorkflowOptions) WithSearchAttributes(sa map[string]any) *TestWorkflowOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *TestWorkflowOptions) WithTaskTimeout(d time.Duration) *TestWorkflowOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *TestWorkflowOptions) WithTaskQueue(tq string) *TestWorkflowOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *TestWorkflowOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *TestWorkflowOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *TestWorkflowOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *TestWorkflowOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// TestWorkflowRun describes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow run
type TestWorkflowRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*TestWorkflowOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal
	TestSignal(ctx context.Context, req *TestSignalInput) error

	// test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update
	TestUpdate(ctx context.Context, req *TestUpdateInput, opts ...*TestUpdateOptions) (*TestUpdateOutput, error)

	// test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdateAsync sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update to the workflow
	TestUpdateAsync(ctx context.Context, req *TestUpdateInput, opts ...*TestUpdateOptions) (TestUpdateHandle, error)
}

// testWorkflowRun provides an internal implementation of a(n) TestWorkflowRunRun
type testWorkflowRun struct {
	client *xnsHeartbeatServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *testWorkflowRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *testWorkflowRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *testWorkflowRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *testWorkflowRun) Get(ctx context.Context) (*TestWorkflowOutput, error) {
	var resp TestWorkflowOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal
func (r *testWorkflowRun) TestSignal(ctx context.Context, req *TestSignalInput) error {
	return r.client.TestSignal(ctx, r.ID(), "", req)
}

// test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate workflow update
func (r *testWorkflowRun) TestUpdate(ctx context.Context, req *TestUpdateInput, opts ...*TestUpdateOptions) (*TestUpdateOutput, error) {
	return r.client.TestUpdate(ctx, r.ID(), r.RunID(), req, opts...)
}

// TestUpdateAsync start a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate workflow update and returns a handle to the update
func (r *testWorkflowRun) TestUpdateAsync(ctx context.Context, req *TestUpdateInput, opts ...*TestUpdateOptions) (TestUpdateHandle, error) {
	return r.client.TestUpdateAsync(ctx, r.ID(), r.RunID(), req, opts...)
}

// TestUpdateHandle describes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update handle
type TestUpdateHandle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*TestUpdateOutput, error)
}

// testUpdateHandle provides an internal implementation of a(n) TestUpdateHandle
type testUpdateHandle struct {
	client *xnsHeartbeatServiceClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *testUpdateHandle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *testUpdateHandle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *testUpdateHandle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *testUpdateHandle) Get(ctx context.Context) (*TestUpdateOutput, error) {
	var resp TestUpdateOutput
	var err error
	doneCh := make(chan struct{})
	gctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			var deadlineExceeded *serviceerror.DeadlineExceeded
			if err = h.handle.Get(gctx, &resp); err != nil && ctx.Err() == nil && (errors.As(err, &deadlineExceeded) || strings.Contains(err.Error(), context.DeadlineExceeded.Error())) {
				continue
			}
			break
		}
		close(doneCh)
	}()

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-doneCh:
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}
}

// TestUpdateOptions provides configuration for a test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update operation
type TestUpdateOptions struct {
	Options    *client.UpdateWorkflowOptions
	id         *string
	waitPolicy client.WorkflowUpdateStage
}

// NewTestUpdateOptions initializes a new TestUpdateOptions value
func NewTestUpdateOptions() *TestUpdateOptions {
	return &TestUpdateOptions{Options: &client.UpdateWorkflowOptions{}}
}

// Build initializes a new client.UpdateWorkflowOptions with defaults and overrides applied
func (o *TestUpdateOptions) Build(workflowID string, runID string, req *TestUpdateInput) (opts *client.UpdateWorkflowOptions, err error) {
	// use user-provided UpdateWorkflowOptions if exists
	if o.Options != nil {
		opts = o.Options
	} else {
		opts = &client.UpdateWorkflowOptions{}
	}

	// set constants
	opts.Args = []any{req}
	opts.RunID = runID
	opts.UpdateName = TestUpdateUpdateName
	opts.WorkflowID = workflowID

	// set UpdateID
	if v := o.id; v != nil {
		opts.UpdateID = *v
	}

	// set WaitPolicy
	if v := o.waitPolicy; v != client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = v
	} else if opts.WaitForStage == client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = client.WorkflowUpdateStageAccepted
	}
	return opts, nil
}

// WithUpdateID sets the UpdateID
func (o *TestUpdateOptions) WithUpdateID(id string) *TestUpdateOptions {
	o.id = &id
	return o
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowOptions
func (o *TestUpdateOptions) WithUpdateWorkflowOptions(options client.UpdateWorkflowOptions) *TestUpdateOptions {
	o.Options = &options
	return o
}

// WithWaitPolicy sets the WaitPolicy
func (o *TestUpdateOptions) WithWaitPolicy(policy client.WorkflowUpdateStage) *TestUpdateOptions {
	o.waitPolicy = policy
	return o
}

// Reference to generated workflow functions
var (
	// xnsHeartbeatServiceRegistrationMutex is a mutex for registering test.xnsheartbeat.v1.XnsHeartbeatService workflows
	xnsHeartbeatServiceRegistrationMutex sync.Mutex
	// TestWorkflowFunction implements a "test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow" workflow
	TestWorkflowFunction func(workflow.Context, *TestWorkflowInput) (*TestWorkflowOutput, error)
)

// XnsHeartbeatServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// XnsHeartbeatServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	XnsHeartbeatServiceWorkflowFunctions interface {
		// TestWorkflow executes a "test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow" workflow inline
		TestWorkflow(workflow.Context, *TestWorkflowInput) (*TestWorkflowOutput, error)
	}
	// xnsHeartbeatServiceWorkflowFunctions provides an internal XnsHeartbeatServiceWorkflowFunctions implementation
	xnsHeartbeatServiceWorkflowFunctions struct{}
)

func NewXnsHeartbeatServiceWorkflowFunctions() XnsHeartbeatServiceWorkflowFunctions {
	return &xnsHeartbeatServiceWorkflowFunctions{}
}

// TestWorkflow executes a "test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow" workflow inline
func (f *xnsHeartbeatServiceWorkflowFunctions) TestWorkflow(ctx workflow.Context, req *TestWorkflowInput) (*TestWorkflowOutput, error) {
	if TestWorkflowFunction == nil {
		return nil, errors.New("TestWorkflow requires workflow registration via RegisterXnsHeartbeatServiceWorkflows or RegisterTestWorkflowWorkflow")
	}
	return TestWorkflowFunction(ctx, req)
}

// XnsHeartbeatServiceWorkflows provides methods for initializing new test.xnsheartbeat.v1.XnsHeartbeatService workflow values
type XnsHeartbeatServiceWorkflows interface {
	// TestWorkflow initializes a new a(n) TestWorkflowWorkflow implementation
	TestWorkflow(ctx workflow.Context, input *TestWorkflowWorkflowInput) (TestWorkflowWorkflow, error)
}

// RegisterXnsHeartbeatServiceWorkflows registers test.xnsheartbeat.v1.XnsHeartbeatService workflows with the given worker
func RegisterXnsHeartbeatServiceWorkflows(r worker.WorkflowRegistry, workflows XnsHeartbeatServiceWorkflows) {
	RegisterTestWorkflowWorkflow(r, workflows.TestWorkflow)
}

// RegisterTestWorkflowWorkflow registers a test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow with the given worker
func RegisterTestWorkflowWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *TestWorkflowWorkflowInput) (TestWorkflowWorkflow, error)) {
	xnsHeartbeatServiceRegistrationMutex.Lock()
	defer xnsHeartbeatServiceRegistrationMutex.Unlock()
	TestWorkflowFunction = buildTestWorkflow(wf)
	r.RegisterWorkflowWithOptions(TestWorkflowFunction, workflow.RegisterOptions{Name: TestWorkflowWorkflowName})
}

// buildTestWorkflow converts a TestWorkflow workflow struct into a valid workflow function
func buildTestWorkflow(ctor func(workflow.Context, *TestWorkflowWorkflowInput) (TestWorkflowWorkflow, error)) func(workflow.Context, *TestWorkflowInput) (*TestWorkflowOutput, error) {
	return func(ctx workflow.Context, req *TestWorkflowInput) (*TestWorkflowOutput, error) {
		input := &TestWorkflowWorkflowInput{
			Req: req,
			TestSignal: &TestSignalSignal{
				Channel: workflow.GetSignalChannel(ctx, TestSignalSignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		{
			opts := workflow.UpdateHandlerOptions{}
			if err := workflow.SetUpdateHandlerWithOptions(ctx, TestUpdateUpdateName, wf.TestUpdate, opts); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// TestWorkflowWorkflowInput describes the input to a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow constructor
type TestWorkflowWorkflowInput struct {
	Req        *TestWorkflowInput
	TestSignal *TestSignalSignal
}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *TestWorkflowWorkflowInput) ContinueAsNew(ctx workflow.Context, input *TestWorkflowInput, options ...workflow.ContinueAsNewErrorOptions) (*TestWorkflowOutput, error) {
	next := i.Req
	if input != nil {
		next = input
	}
	if len(options) > 0 {
		return nil, workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], TestWorkflowWorkflowName, next)
	}
	return nil, workflow.NewContinueAsNewError(ctx, TestWorkflowWorkflowName, next)
}

// TestWorkflowWorkflow describes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow implementation
type TestWorkflowWorkflow interface {
	// Execute defines the entrypoint to a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow
	Execute(ctx workflow.Context) (*TestWorkflowOutput, error)

	// test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate implements a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update handler
	TestUpdate(workflow.Context, *TestUpdateInput) (*TestUpdateOutput, error)
}

// TestWorkflowChild executes a child test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and blocks until error or response received
func TestWorkflowChild(ctx workflow.Context, req *TestWorkflowInput, options ...*TestWorkflowChildOptions) (*TestWorkflowOutput, error) {
	childRun, err := TestWorkflowChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// TestWorkflowChildAsync starts a child test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and returns a handle to the child workflow run
func TestWorkflowChildAsync(ctx workflow.Context, req *TestWorkflowInput, options ...*TestWorkflowChildOptions) (*TestWorkflowChildRun, error) {
	var o *TestWorkflowChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewTestWorkflowChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &TestWorkflowChildRun{Future: workflow.ExecuteChildWorkflow(ctx, TestWorkflowWorkflowName, req)}, nil
}

// TestWorkflowChildOptions provides configuration for a child test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow operation
type TestWorkflowChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewTestWorkflowChildOptions initializes a new TestWorkflowChildOptions value
func NewTestWorkflowChildOptions() *TestWorkflowChildOptions {
	return &TestWorkflowChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *TestWorkflowChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = XnsHeartbeatServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *TestWorkflowChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *TestWorkflowChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *TestWorkflowChildOptions) WithDataConverter(dc converter.DataConverter) *TestWorkflowChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *TestWorkflowChildOptions) WithExecutionTimeout(d time.Duration) *TestWorkflowChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *TestWorkflowChildOptions) WithID(id string) *TestWorkflowChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *TestWorkflowChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *TestWorkflowChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *TestWorkflowChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *TestWorkflowChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *TestWorkflowChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *TestWorkflowChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *TestWorkflowChildOptions) WithRunTimeout(d time.Duration) *TestWorkflowChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *TestWorkflowChildOptions) WithSearchAttributes(sa map[string]any) *TestWorkflowChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *TestWorkflowChildOptions) WithTaskTimeout(d time.Duration) *TestWorkflowChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *TestWorkflowChildOptions) WithTaskQueue(tq string) *TestWorkflowChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *TestWorkflowChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *TestWorkflowChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *TestWorkflowChildOptions) WithWaitForCancellation(wait bool) *TestWorkflowChildOptions {
	o.waitForCancellation = &wait
	return o
}

// TestWorkflowChildRun describes a child TestWorkflow workflow run
type TestWorkflowChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *TestWorkflowChildRun) Get(ctx workflow.Context) (*TestWorkflowOutput, error) {
	var resp TestWorkflowOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *TestWorkflowChildRun) Select(sel workflow.Selector, fn func(*TestWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *TestWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(*TestWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *TestWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// TestSignal sends a(n) "test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal" signal request to the child workflow
func (r *TestWorkflowChildRun) TestSignal(ctx workflow.Context, input *TestSignalInput) error {
	return r.TestSignalAsync(ctx, input).Get(ctx, nil)
}

// TestSignalAsync sends a(n) "test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal" signal request to the child workflow
func (r *TestWorkflowChildRun) TestSignalAsync(ctx workflow.Context, input *TestSignalInput) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, TestSignalSignalName, input)
}

// TestSignalSignal describes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal
type TestSignalSignal struct {
	Channel workflow.ReceiveChannel
}

// NewTestSignalSignal initializes a new test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal wrapper
func NewTestSignalSignal(ctx workflow.Context) *TestSignalSignal {
	return &TestSignalSignal{Channel: workflow.GetSignalChannel(ctx, TestSignalSignalName)}
}

// Receive blocks until a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal is received
func (s *TestSignalSignal) Receive(ctx workflow.Context) (*TestSignalInput, bool) {
	var resp TestSignalInput
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal without blocking
func (s *TestSignalSignal) ReceiveAsync() *TestSignalInput {
	var resp TestSignalInput
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *TestSignalSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *TestSignalInput, ok bool, more bool) {
	resp = &TestSignalInput{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal without blocking
func (s *TestSignalSignal) Select(sel workflow.Selector, fn func(*TestSignalInput)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// TestSignalExternal sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal to an existing workflow
func TestSignalExternal(ctx workflow.Context, workflowID string, runID string, req *TestSignalInput) error {
	return TestSignalExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// TestSignalExternalAsync sends a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal to an existing workflow
func TestSignalExternalAsync(ctx workflow.Context, workflowID string, runID string, req *TestSignalInput) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, TestSignalSignalName, req)
}

// XnsHeartbeatServiceActivities describes available worker activities
type XnsHeartbeatServiceActivities interface{}

// RegisterXnsHeartbeatServiceActivities registers activities with a worker
func RegisterXnsHeartbeatServiceActivities(r worker.ActivityRegistry, activities XnsHeartbeatServiceActivities) {
}

// TestClient provides a testsuite-compatible Client
type TestXnsHeartbeatServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows XnsHeartbeatServiceWorkflows
}

var _ XnsHeartbeatServiceClient = &TestXnsHeartbeatServiceClient{}

// NewTestXnsHeartbeatServiceClient initializes a new TestXnsHeartbeatServiceClient value
func NewTestXnsHeartbeatServiceClient(env *testsuite.TestWorkflowEnvironment, workflows XnsHeartbeatServiceWorkflows, activities XnsHeartbeatServiceActivities) *TestXnsHeartbeatServiceClient {
	if workflows != nil {
		RegisterXnsHeartbeatServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterXnsHeartbeatServiceActivities(env, activities)
	}
	return &TestXnsHeartbeatServiceClient{env, workflows}
}

// TestWorkflow executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow in the test environment
func (c *TestXnsHeartbeatServiceClient) TestWorkflow(ctx context.Context, req *TestWorkflowInput, opts ...*TestWorkflowOptions) (*TestWorkflowOutput, error) {
	run, err := c.TestWorkflowAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// TestWorkflowAsync executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow in the test environment
func (c *TestXnsHeartbeatServiceClient) TestWorkflowAsync(ctx context.Context, req *TestWorkflowInput, options ...*TestWorkflowOptions) (TestWorkflowRun, error) {
	var o *TestWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewTestWorkflowOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testTestWorkflowRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetTestWorkflow is a noop
func (c *TestXnsHeartbeatServiceClient) GetTestWorkflow(ctx context.Context, workflowID string, runID string) TestWorkflowRun {
	return &testTestWorkflowRun{env: c.env, workflows: c.workflows}
}

// TestWorkflowWithTestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update in the test environment
func (c *TestXnsHeartbeatServiceClient) TestWorkflowWithTestUpdate(ctx context.Context, input *TestWorkflowInput, update *TestUpdateInput, options ...*TestWorkflowWithTestUpdateOptions) (*TestUpdateOutput, TestWorkflowRun, error) {
	var o *TestWorkflowWithTestUpdateOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewTestWorkflowWithTestUpdateOptions()
	}
	handle, run, err := c.TestWorkflowWithTestUpdateAsync(ctx, input, update, o)
	if err != nil {
		return nil, run, err
	}
	run.Get(ctx)
	out, err := handle.Get(ctx)
	if err != nil {
		return nil, run, err
	}
	return out, run, nil
}

// TestWorkflowWithTestUpdateAsync executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow and a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update in the test environment
func (c *TestXnsHeartbeatServiceClient) TestWorkflowWithTestUpdateAsync(ctx context.Context, input *TestWorkflowInput, update *TestUpdateInput, options ...*TestWorkflowWithTestUpdateOptions) (TestUpdateHandle, TestWorkflowRun, error) {
	var o *TestWorkflowWithTestUpdateOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewTestWorkflowWithTestUpdateOptions()
	}
	if o.workflowOptions == nil {
		o.workflowOptions = NewTestWorkflowOptions()
	}
	swo, err := o.workflowOptions.Build(input.ProtoReflect())
	if err != nil {
		return nil, nil, fmt.Errorf("error initializing workflowOptions: %w", err)
	}
	if o.updateOptions == nil {
		o.updateOptions = NewTestUpdateOptions()
	}
	uo, err := o.updateOptions.Build(swo.ID, "", update)
	if err != nil {
		return nil, nil, fmt.Errorf("error initializing updateOptions: %w", err)
	}
	run, err := c.TestWorkflowAsync(ctx, input)
	if err != nil {
		return nil, nil, err
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.RegisterDelayedCallback(func() {
		c.env.UpdateWorkflow(TestUpdateUpdateName, uo.UpdateID, uc, update)
	}, 0)
	return &testTestUpdateHandle{
		callbacks:  uc,
		env:        c.env,
		opts:       uo,
		req:        update,
		runID:      "",
		workflowID: swo.ID,
	}, run, nil
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestXnsHeartbeatServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestXnsHeartbeatServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// TestSignal executes a test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal
func (c *TestXnsHeartbeatServiceClient) TestSignal(ctx context.Context, workflowID string, runID string, req *TestSignalInput) error {
	c.env.SignalWorkflow(TestSignalSignalName, req)
	return nil
}

// TestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update in the test environment
func (c *TestXnsHeartbeatServiceClient) TestUpdate(ctx context.Context, workflowID string, runID string, req *TestUpdateInput, opts ...*TestUpdateOptions) (*TestUpdateOutput, error) {
	options := NewTestUpdateOptions()
	if len(opts) > 0 && opts[0].Options != nil {
		options = opts[0]
	}
	options.Options.WaitForStage = client.WorkflowUpdateStageCompleted
	handle, err := c.TestUpdateAsync(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// TestUpdateAsync executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update in the test environment
func (c *TestXnsHeartbeatServiceClient) TestUpdateAsync(ctx context.Context, workflowID string, runID string, req *TestUpdateInput, opts ...*TestUpdateOptions) (TestUpdateHandle, error) {
	var o *TestUpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewTestUpdateOptions()
	}
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	if options.UpdateID == "" {
		options.UpdateID = uuid.New().String()
	}

	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(TestUpdateUpdateName, options.UpdateID, uc, req)
	return &testTestUpdateHandle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

// GetTestUpdate retrieves a handle to an existing test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update
func (c *TestXnsHeartbeatServiceClient) GetTestUpdate(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (TestUpdateHandle, error) {
	return nil, errors.New("unimplemented")
}

var _ TestUpdateHandle = &testTestUpdateHandle{}

// testTestUpdateHandle provides an internal implementation of a(n) TestUpdateHandle
type testTestUpdateHandle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowOptions
	req        *TestUpdateInput
	runID      string
	workflowID string
}

// Get retrieves a test test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update result
func (h *testTestUpdateHandle) Get(ctx context.Context) (*TestUpdateOutput, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*TestUpdateOutput), nil
	}
}

// RunID implementation
func (h *testTestUpdateHandle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testTestUpdateHandle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testTestUpdateHandle) WorkflowID() string {
	return h.workflowID
}

var _ TestWorkflowRun = &testTestWorkflowRun{}

// testTestWorkflowRun provides convenience methods for interacting with a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow in the test environment
type testTestWorkflowRun struct {
	client    *TestXnsHeartbeatServiceClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *TestWorkflowInput
	workflows XnsHeartbeatServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testTestWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow result
func (r *testTestWorkflowRun) Get(context.Context) (*TestWorkflowOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(TestWorkflowWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result TestWorkflowOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow run's workflow ID
func (r *testTestWorkflowRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testTestWorkflowRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testTestWorkflowRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testTestWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// TestSignal executes a test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal against a test test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow
func (r *testTestWorkflowRun) TestSignal(ctx context.Context, req *TestSignalInput) error {
	return r.client.TestSignal(ctx, r.ID(), r.RunID(), req)
}

// TestUpdate executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update against a test test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow
func (r *testTestWorkflowRun) TestUpdate(ctx context.Context, req *TestUpdateInput, opts ...*TestUpdateOptions) (*TestUpdateOutput, error) {
	return r.client.TestUpdate(ctx, r.ID(), r.RunID(), req, opts...)
}

// TestUpdateAsync executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update against a test test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow
func (r *testTestWorkflowRun) TestUpdateAsync(ctx context.Context, req *TestUpdateInput, opts ...*TestUpdateOptions) (TestUpdateHandle, error) {
	return r.client.TestUpdateAsync(ctx, r.ID(), r.RunID(), req, opts...)
}

// XnsHeartbeatServiceCliOptions describes runtime configuration for test.xnsheartbeat.v1.XnsHeartbeatService cli
type XnsHeartbeatServiceCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewXnsHeartbeatServiceCliOptions initializes a new XnsHeartbeatServiceCliOptions value
func NewXnsHeartbeatServiceCliOptions() *XnsHeartbeatServiceCliOptions {
	return &XnsHeartbeatServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *XnsHeartbeatServiceCliOptions) WithAfter(fn func(*v2.Context) error) *XnsHeartbeatServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *XnsHeartbeatServiceCliOptions) WithBefore(fn func(*v2.Context) error) *XnsHeartbeatServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *XnsHeartbeatServiceCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *XnsHeartbeatServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *XnsHeartbeatServiceCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *XnsHeartbeatServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewXnsHeartbeatServiceCli initializes a cli for a(n) test.xnsheartbeat.v1.XnsHeartbeatService service
func NewXnsHeartbeatServiceCli(options ...*XnsHeartbeatServiceCliOptions) (*v2.App, error) {
	commands, err := newXnsHeartbeatServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:                      "xns-heartbeat-service",
		Usage:                     "test.xnsheartbeat.v1.XnsHeartbeatService operations",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// NewXnsHeartbeatServiceCliCommand initializes a cli command for a test.xnsheartbeat.v1.XnsHeartbeatService service with subcommands for each query, signal, update, and workflow
func NewXnsHeartbeatServiceCliCommand(options ...*XnsHeartbeatServiceCliOptions) (*v2.Command, error) {
	subcommands, err := newXnsHeartbeatServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "xns-heartbeat-service",
		Usage:       "test.xnsheartbeat.v1.XnsHeartbeatService operations",
		Subcommands: subcommands,
	}, nil
}

// newXnsHeartbeatServiceCommands initializes (sub)commands for a test.xnsheartbeat.v1.XnsHeartbeatService cli or command
func newXnsHeartbeatServiceCommands(options ...*XnsHeartbeatServiceCliOptions) ([]*v2.Command, error) {
	opts := &XnsHeartbeatServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "test-signal",
			Usage:                  "executes a test.xnsheartbeat.v1.XnsHeartbeatService.TestSignal signal",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewXnsHeartbeatServiceClient(c)
				req, err := UnmarshalCliFlagsToTestSignalInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.TestSignal(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", TestSignalSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "test-update",
			Usage:                  "executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and udpate id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewXnsHeartbeatServiceClient(c)
				req, err := UnmarshalCliFlagsToTestUpdateInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.TestUpdateAsync(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", TestUpdateUpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "test-workflow",
			Usage:                  "executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "xnsheartbeat-v1",
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewXnsHeartbeatServiceClient(tc)
				req, err := UnmarshalCliFlagsToTestWorkflowInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.TestWorkflowAsync(cmd.Context, req, NewTestWorkflowOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", TestWorkflowWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update on a test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow, starting it if necessary,
		{
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewXnsHeartbeatServiceClient(c)
				input, err := UnmarshalCliFlagsToTestWorkflowInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling input: %w", err)
				}
				update, err := UnmarshalCliFlagsToTestUpdateInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "update-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling update: %w", err)
				}
				handle, _, err := client.TestWorkflowWithTestUpdateAsync(cmd.Context, input, update)
				if err != nil {
					return fmt.Errorf("error starting workflow with update: %w", err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if out, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(out)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
			After:    opts.after,
			Before:   opts.before,
			Category: "WORKFLOWS",
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Aliases: []string{"d"},
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and update id",
				},
				&v2.StringFlag{
					Aliases:  []string{"f"},
					Category: "INPUT",
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
				},
				&v2.StringFlag{
					Aliases:  []string{"u"},
					Category: "UPDATE",
					Name:     "update-file",
					Usage:    "path to json-formatted update file",
				},
			},
			Name:                   "test-workflow-with-test-update",
			Usage:                  "executes a(n) test.xnsheartbeat.v1.XnsHeartbeatService.TestUpdate update on a test.xnsheartbeat.v1.XnsHeartbeatService.TestWorkflow workflow, starting it if necessary",
			UseShortOptionHandling: true,
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.xnsheartbeat.v1.XnsHeartbeatService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToTestSignalInput unmarshals a TestSignalInput from command line flags
func UnmarshalCliFlagsToTestSignalInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*TestSignalInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result TestSignalInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// UnmarshalCliFlagsToTestUpdateInput unmarshals a TestUpdateInput from command line flags
func UnmarshalCliFlagsToTestUpdateInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*TestUpdateInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result TestUpdateInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// UnmarshalCliFlagsToTestWorkflowInput unmarshals a TestWorkflowInput from command line flags
func UnmarshalCliFlagsToTestWorkflowInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*TestWorkflowInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result TestWorkflowInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// WithXnsHeartbeatServiceSchemeTypes registers all XnsHeartbeatService protobuf types with the given scheme
func WithXnsHeartbeatServiceSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_xnsheartbeat_v1_xnsheartbeat_proto.Messages().ByName("TestSignalInput"))
		s.RegisterType(File_test_xnsheartbeat_v1_xnsheartbeat_proto.Messages().ByName("TestUpdateInput"))
		s.RegisterType(File_test_xnsheartbeat_v1_xnsheartbeat_proto.Messages().ByName("TestUpdateOutput"))
		s.RegisterType(File_test_xnsheartbeat_v1_xnsheartbeat_proto.Messages().ByName("TestWorkflowInput"))
		s.RegisterType(File_test_xnsheartbeat_v1_xnsheartbeat_proto.Messages().ByName("TestWorkflowOutput"))
	}
}

// XnsHeartbeatCallerServiceTaskQueue is the default task-queue for a test.xnsheartbeat.v1.XnsHeartbeatCallerService worker
var XnsHeartbeatCallerServiceTaskQueue = "xnsheartbeat-caller-v1"

// test.xnsheartbeat.v1.XnsHeartbeatCallerService workflow names
const (
	CallTestWorkflowWorkflowName = "test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow"
)

// XnsHeartbeatCallerServiceClient describes a client for a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService worker
type XnsHeartbeatCallerServiceClient interface {
	// CallTestWorkflow executes a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow and blocks until error or response received
	CallTestWorkflow(ctx context.Context, opts ...*CallTestWorkflowOptions) error

	// CallTestWorkflowAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow and returns a handle to the workflow run
	CallTestWorkflowAsync(ctx context.Context, opts ...*CallTestWorkflowOptions) (CallTestWorkflowRun, error)

	// GetCallTestWorkflow retrieves a handle to an existing test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow execution
	GetCallTestWorkflow(ctx context.Context, workflowID string, runID string) CallTestWorkflowRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// xnsHeartbeatCallerServiceClient implements a temporal client for a test.xnsheartbeat.v1.XnsHeartbeatCallerService service
type xnsHeartbeatCallerServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewXnsHeartbeatCallerServiceClient initializes a new test.xnsheartbeat.v1.XnsHeartbeatCallerService client
func NewXnsHeartbeatCallerServiceClient(c client.Client, options ...*xnsHeartbeatCallerServiceClientOptions) XnsHeartbeatCallerServiceClient {
	var cfg *xnsHeartbeatCallerServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewXnsHeartbeatCallerServiceClientOptions()
	}
	return &xnsHeartbeatCallerServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewXnsHeartbeatCallerServiceClientWithOptions initializes a new XnsHeartbeatCallerService client with the given options
func NewXnsHeartbeatCallerServiceClientWithOptions(c client.Client, opts client.Options, options ...*xnsHeartbeatCallerServiceClientOptions) (XnsHeartbeatCallerServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *xnsHeartbeatCallerServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewXnsHeartbeatCallerServiceClientOptions()
	}
	return &xnsHeartbeatCallerServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// xnsHeartbeatCallerServiceClientOptions describes optional runtime configuration for a XnsHeartbeatCallerServiceClient
type xnsHeartbeatCallerServiceClientOptions struct {
	log *slog.Logger
}

// NewXnsHeartbeatCallerServiceClientOptions initializes a new xnsHeartbeatCallerServiceClientOptions value
func NewXnsHeartbeatCallerServiceClientOptions() *xnsHeartbeatCallerServiceClientOptions {
	return &xnsHeartbeatCallerServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *xnsHeartbeatCallerServiceClientOptions) WithLogger(l *slog.Logger) *xnsHeartbeatCallerServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *xnsHeartbeatCallerServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow executes a test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow and blocks until error or response received
func (c *xnsHeartbeatCallerServiceClient) CallTestWorkflow(ctx context.Context, options ...*CallTestWorkflowOptions) error {
	run, err := c.CallTestWorkflowAsync(ctx, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// CallTestWorkflowAsync starts a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow and returns a handle to the workflow run
func (c *xnsHeartbeatCallerServiceClient) CallTestWorkflowAsync(ctx context.Context, options ...*CallTestWorkflowOptions) (CallTestWorkflowRun, error) {
	var o *CallTestWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallTestWorkflowOptions()
	}
	opts, err := o.Build(nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, CallTestWorkflowWorkflowName)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &callTestWorkflowRun{
		client: c,
		run:    run,
	}, nil
}

// GetCallTestWorkflow fetches an existing test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow execution
func (c *xnsHeartbeatCallerServiceClient) GetCallTestWorkflow(ctx context.Context, workflowID string, runID string) CallTestWorkflowRun {
	return &callTestWorkflowRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *xnsHeartbeatCallerServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *xnsHeartbeatCallerServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// CallTestWorkflowOptions provides configuration for a test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow operation
type CallTestWorkflowOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewCallTestWorkflowOptions initializes a new CallTestWorkflowOptions value
func NewCallTestWorkflowOptions() *CallTestWorkflowOptions {
	return &CallTestWorkflowOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *CallTestWorkflowOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = XnsHeartbeatCallerServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *CallTestWorkflowOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *CallTestWorkflowOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *CallTestWorkflowOptions) WithEnableEagerStart(enable bool) *CallTestWorkflowOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CallTestWorkflowOptions) WithExecutionTimeout(d time.Duration) *CallTestWorkflowOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *CallTestWorkflowOptions) WithID(id string) *CallTestWorkflowOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CallTestWorkflowOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CallTestWorkflowOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CallTestWorkflowOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CallTestWorkflowOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CallTestWorkflowOptions) WithRunTimeout(d time.Duration) *CallTestWorkflowOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CallTestWorkflowOptions) WithSearchAttributes(sa map[string]any) *CallTestWorkflowOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CallTestWorkflowOptions) WithTaskTimeout(d time.Duration) *CallTestWorkflowOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CallTestWorkflowOptions) WithTaskQueue(tq string) *CallTestWorkflowOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *CallTestWorkflowOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *CallTestWorkflowOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *CallTestWorkflowOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *CallTestWorkflowOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// CallTestWorkflowRun describes a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow run
type CallTestWorkflowRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// callTestWorkflowRun provides an internal implementation of a(n) CallTestWorkflowRunRun
type callTestWorkflowRun struct {
	client *xnsHeartbeatCallerServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *callTestWorkflowRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *callTestWorkflowRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *callTestWorkflowRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *callTestWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *callTestWorkflowRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *callTestWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// xnsHeartbeatCallerServiceRegistrationMutex is a mutex for registering test.xnsheartbeat.v1.XnsHeartbeatCallerService workflows
	xnsHeartbeatCallerServiceRegistrationMutex sync.Mutex
	// CallTestWorkflowFunction implements a "test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow" workflow
	CallTestWorkflowFunction func(workflow.Context) error
)

// XnsHeartbeatCallerServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// XnsHeartbeatCallerServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	XnsHeartbeatCallerServiceWorkflowFunctions interface {
		// CallTestWorkflow executes a "test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow" workflow inline
		CallTestWorkflow(workflow.Context) error
	}
	// xnsHeartbeatCallerServiceWorkflowFunctions provides an internal XnsHeartbeatCallerServiceWorkflowFunctions implementation
	xnsHeartbeatCallerServiceWorkflowFunctions struct{}
)

func NewXnsHeartbeatCallerServiceWorkflowFunctions() XnsHeartbeatCallerServiceWorkflowFunctions {
	return &xnsHeartbeatCallerServiceWorkflowFunctions{}
}

// CallTestWorkflow executes a "test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow" workflow inline
func (f *xnsHeartbeatCallerServiceWorkflowFunctions) CallTestWorkflow(ctx workflow.Context) error {
	if CallTestWorkflowFunction == nil {
		return errors.New("CallTestWorkflow requires workflow registration via RegisterXnsHeartbeatCallerServiceWorkflows or RegisterCallTestWorkflowWorkflow")
	}
	return CallTestWorkflowFunction(ctx)
}

// XnsHeartbeatCallerServiceWorkflows provides methods for initializing new test.xnsheartbeat.v1.XnsHeartbeatCallerService workflow values
type XnsHeartbeatCallerServiceWorkflows interface {
	// CallTestWorkflow initializes a new a(n) CallTestWorkflowWorkflow implementation
	CallTestWorkflow(ctx workflow.Context, input *CallTestWorkflowWorkflowInput) (CallTestWorkflowWorkflow, error)
}

// RegisterXnsHeartbeatCallerServiceWorkflows registers test.xnsheartbeat.v1.XnsHeartbeatCallerService workflows with the given worker
func RegisterXnsHeartbeatCallerServiceWorkflows(r worker.WorkflowRegistry, workflows XnsHeartbeatCallerServiceWorkflows) {
	RegisterCallTestWorkflowWorkflow(r, workflows.CallTestWorkflow)
}

// RegisterCallTestWorkflowWorkflow registers a test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow with the given worker
func RegisterCallTestWorkflowWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *CallTestWorkflowWorkflowInput) (CallTestWorkflowWorkflow, error)) {
	xnsHeartbeatCallerServiceRegistrationMutex.Lock()
	defer xnsHeartbeatCallerServiceRegistrationMutex.Unlock()
	CallTestWorkflowFunction = buildCallTestWorkflow(wf)
	r.RegisterWorkflowWithOptions(CallTestWorkflowFunction, workflow.RegisterOptions{Name: CallTestWorkflowWorkflowName})
}

// buildCallTestWorkflow converts a CallTestWorkflow workflow struct into a valid workflow function
func buildCallTestWorkflow(ctor func(workflow.Context, *CallTestWorkflowWorkflowInput) (CallTestWorkflowWorkflow, error)) func(workflow.Context) error {
	return func(ctx workflow.Context) error {
		input := &CallTestWorkflowWorkflowInput{}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// CallTestWorkflowWorkflowInput describes the input to a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow constructor
type CallTestWorkflowWorkflowInput struct{}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *CallTestWorkflowWorkflowInput) ContinueAsNew(ctx workflow.Context, options ...workflow.ContinueAsNewErrorOptions) error {
	if len(options) > 0 {
		return workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], CallTestWorkflowWorkflowName)
	}
	return workflow.NewContinueAsNewError(ctx, CallTestWorkflowWorkflowName)
}

// CallTestWorkflowWorkflow describes a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow implementation
type CallTestWorkflowWorkflow interface {
	// Execute defines the entrypoint to a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow
	Execute(ctx workflow.Context) error
}

// CallTestWorkflowChild executes a child test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow and blocks until error or response received
func CallTestWorkflowChild(ctx workflow.Context, options ...*CallTestWorkflowChildOptions) error {
	childRun, err := CallTestWorkflowChildAsync(ctx, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// CallTestWorkflowChildAsync starts a child test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow and returns a handle to the child workflow run
func CallTestWorkflowChildAsync(ctx workflow.Context, options ...*CallTestWorkflowChildOptions) (*CallTestWorkflowChildRun, error) {
	var o *CallTestWorkflowChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallTestWorkflowChildOptions()
	}
	opts, err := o.Build(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &CallTestWorkflowChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CallTestWorkflowWorkflowName, nil)}, nil
}

// CallTestWorkflowChildOptions provides configuration for a child test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow operation
type CallTestWorkflowChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewCallTestWorkflowChildOptions initializes a new CallTestWorkflowChildOptions value
func NewCallTestWorkflowChildOptions() *CallTestWorkflowChildOptions {
	return &CallTestWorkflowChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *CallTestWorkflowChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = XnsHeartbeatCallerServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *CallTestWorkflowChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *CallTestWorkflowChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *CallTestWorkflowChildOptions) WithDataConverter(dc converter.DataConverter) *CallTestWorkflowChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CallTestWorkflowChildOptions) WithExecutionTimeout(d time.Duration) *CallTestWorkflowChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *CallTestWorkflowChildOptions) WithID(id string) *CallTestWorkflowChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CallTestWorkflowChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CallTestWorkflowChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *CallTestWorkflowChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *CallTestWorkflowChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CallTestWorkflowChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CallTestWorkflowChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CallTestWorkflowChildOptions) WithRunTimeout(d time.Duration) *CallTestWorkflowChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CallTestWorkflowChildOptions) WithSearchAttributes(sa map[string]any) *CallTestWorkflowChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CallTestWorkflowChildOptions) WithTaskTimeout(d time.Duration) *CallTestWorkflowChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CallTestWorkflowChildOptions) WithTaskQueue(tq string) *CallTestWorkflowChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *CallTestWorkflowChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *CallTestWorkflowChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CallTestWorkflowChildOptions) WithWaitForCancellation(wait bool) *CallTestWorkflowChildOptions {
	o.waitForCancellation = &wait
	return o
}

// CallTestWorkflowChildRun describes a child CallTestWorkflow workflow run
type CallTestWorkflowChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CallTestWorkflowChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CallTestWorkflowChildRun) Select(sel workflow.Selector, fn func(*CallTestWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CallTestWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(*CallTestWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CallTestWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// XnsHeartbeatCallerServiceActivities describes available worker activities
type XnsHeartbeatCallerServiceActivities interface{}

// RegisterXnsHeartbeatCallerServiceActivities registers activities with a worker
func RegisterXnsHeartbeatCallerServiceActivities(r worker.ActivityRegistry, activities XnsHeartbeatCallerServiceActivities) {
}

// TestClient provides a testsuite-compatible Client
type TestXnsHeartbeatCallerServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows XnsHeartbeatCallerServiceWorkflows
}

var _ XnsHeartbeatCallerServiceClient = &TestXnsHeartbeatCallerServiceClient{}

// NewTestXnsHeartbeatCallerServiceClient initializes a new TestXnsHeartbeatCallerServiceClient value
func NewTestXnsHeartbeatCallerServiceClient(env *testsuite.TestWorkflowEnvironment, workflows XnsHeartbeatCallerServiceWorkflows, activities XnsHeartbeatCallerServiceActivities) *TestXnsHeartbeatCallerServiceClient {
	if workflows != nil {
		RegisterXnsHeartbeatCallerServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterXnsHeartbeatCallerServiceActivities(env, activities)
	}
	return &TestXnsHeartbeatCallerServiceClient{env, workflows}
}

// CallTestWorkflow executes a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow in the test environment
func (c *TestXnsHeartbeatCallerServiceClient) CallTestWorkflow(ctx context.Context, opts ...*CallTestWorkflowOptions) error {
	run, err := c.CallTestWorkflowAsync(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// CallTestWorkflowAsync executes a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow in the test environment
func (c *TestXnsHeartbeatCallerServiceClient) CallTestWorkflowAsync(ctx context.Context, options ...*CallTestWorkflowOptions) (CallTestWorkflowRun, error) {
	var o *CallTestWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallTestWorkflowOptions()
	}
	opts, err := o.Build(nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testCallTestWorkflowRun{client: c, env: c.env, opts: &opts, workflows: c.workflows}, nil
}

// GetCallTestWorkflow is a noop
func (c *TestXnsHeartbeatCallerServiceClient) GetCallTestWorkflow(ctx context.Context, workflowID string, runID string) CallTestWorkflowRun {
	return &testCallTestWorkflowRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestXnsHeartbeatCallerServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestXnsHeartbeatCallerServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ CallTestWorkflowRun = &testCallTestWorkflowRun{}

// testCallTestWorkflowRun provides convenience methods for interacting with a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow in the test environment
type testCallTestWorkflowRun struct {
	client    *TestXnsHeartbeatCallerServiceClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	workflows XnsHeartbeatCallerServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testCallTestWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow result
func (r *testCallTestWorkflowRun) Get(context.Context) error {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(CallTestWorkflowWorkflowName)
	}
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow run's workflow ID
func (r *testCallTestWorkflowRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testCallTestWorkflowRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testCallTestWorkflowRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testCallTestWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// XnsHeartbeatCallerServiceCliOptions describes runtime configuration for test.xnsheartbeat.v1.XnsHeartbeatCallerService cli
type XnsHeartbeatCallerServiceCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewXnsHeartbeatCallerServiceCliOptions initializes a new XnsHeartbeatCallerServiceCliOptions value
func NewXnsHeartbeatCallerServiceCliOptions() *XnsHeartbeatCallerServiceCliOptions {
	return &XnsHeartbeatCallerServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *XnsHeartbeatCallerServiceCliOptions) WithAfter(fn func(*v2.Context) error) *XnsHeartbeatCallerServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *XnsHeartbeatCallerServiceCliOptions) WithBefore(fn func(*v2.Context) error) *XnsHeartbeatCallerServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *XnsHeartbeatCallerServiceCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *XnsHeartbeatCallerServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *XnsHeartbeatCallerServiceCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *XnsHeartbeatCallerServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewXnsHeartbeatCallerServiceCli initializes a cli for a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService service
func NewXnsHeartbeatCallerServiceCli(options ...*XnsHeartbeatCallerServiceCliOptions) (*v2.App, error) {
	commands, err := newXnsHeartbeatCallerServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:                      "xns-heartbeat-caller-service",
		Usage:                     "test.xnsheartbeat.v1.XnsHeartbeatCallerService operations",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// NewXnsHeartbeatCallerServiceCliCommand initializes a cli command for a test.xnsheartbeat.v1.XnsHeartbeatCallerService service with subcommands for each query, signal, update, and workflow
func NewXnsHeartbeatCallerServiceCliCommand(options ...*XnsHeartbeatCallerServiceCliOptions) (*v2.Command, error) {
	subcommands, err := newXnsHeartbeatCallerServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "xns-heartbeat-caller-service",
		Usage:       "test.xnsheartbeat.v1.XnsHeartbeatCallerService operations",
		Subcommands: subcommands,
	}, nil
}

// newXnsHeartbeatCallerServiceCommands initializes (sub)commands for a test.xnsheartbeat.v1.XnsHeartbeatCallerService cli or command
func newXnsHeartbeatCallerServiceCommands(options ...*XnsHeartbeatCallerServiceCliOptions) ([]*v2.Command, error) {
	opts := &XnsHeartbeatCallerServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "call-test-workflow",
			Usage:                  "executes a(n) test.xnsheartbeat.v1.XnsHeartbeatCallerService.CallTestWorkflow workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "xnsheartbeat-caller-v1",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewXnsHeartbeatCallerServiceClient(tc)
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.CallTestWorkflowAsync(cmd.Context, NewCallTestWorkflowOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CallTestWorkflowWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.xnsheartbeat.v1.XnsHeartbeatCallerService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// WithXnsHeartbeatCallerServiceSchemeTypes registers all XnsHeartbeatCallerService protobuf types with the given scheme
func WithXnsHeartbeatCallerServiceSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {}
}
