// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/activity/v1/activity.proto
package activityv1

import (
	"context"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	activity "go.temporal.io/sdk/activity"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	"time"
)

// ExampleTaskQueue is the default task-queue for a test.activity.v1.Example worker
var ExampleTaskQueue = "example-v1"

// test.activity.v1.Example activity names
const (
	BarActivityName = "test.activity.v1.Example.Bar"
	BazActivityName = "test.activity.v1.Example.Baz"
	FooActivityName = "test.activity.v1.Example.Foo"
	QuxActivityName = "test.activity.v1.Example.Qux"
)

// ExampleActivities describes available worker activities
type ExampleActivities interface {
	// test.activity.v1.Example.Bar implements a(n) test.activity.v1.Example.Bar activity definition
	Bar(ctx context.Context, req *BarInput) error

	// test.activity.v1.Example.Baz implements a(n) test.activity.v1.Example.Baz activity definition
	Baz(ctx context.Context) (*BazOutput, error)

	// test.activity.v1.Example.Foo implements a(n) test.activity.v1.Example.Foo activity definition
	Foo(ctx context.Context, req *FooInput) (*FooOutput, error)

	// test.activity.v1.Example.Qux implements a(n) test.activity.v1.Example.Qux activity definition
	Qux(ctx context.Context) error
}

// RegisterExampleActivities registers activities with a worker
func RegisterExampleActivities(r worker.ActivityRegistry, activities ExampleActivities) {
	RegisterBarActivity(r, activities.Bar)
	RegisterBazActivity(r, activities.Baz)
	RegisterFooActivity(r, activities.Foo)
	RegisterQuxActivity(r, activities.Qux)
}

// RegisterBarActivity registers a test.activity.v1.Example.Bar activity
func RegisterBarActivity(r worker.ActivityRegistry, fn func(context.Context, *BarInput) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: BarActivityName,
	})
}

// BarFuture describes a(n) test.activity.v1.Example.Bar activity execution
type BarFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *BarFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *BarFuture) Select(sel workflow.Selector, fn func(*BarFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Bar executes a(n) test.activity.v1.Example.Bar activity
func Bar(ctx workflow.Context, req *BarInput, options ...*BarActivityOptions) error {
	return BarAsync(ctx, req, options...).Get(ctx)
}

// BarAsync executes a(n) test.activity.v1.Example.Bar activity (asynchronously)
func BarAsync(ctx workflow.Context, req *BarInput, options ...*BarActivityOptions) *BarFuture {
	var o *BarActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &BarFuture{Future: errF}
	}
	activity := BarActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &BarFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// BarLocal executes a(n) test.activity.v1.Example.Bar activity (locally)
func BarLocal(ctx workflow.Context, req *BarInput, options ...*BarLocalActivityOptions) error {
	return BarLocalAsync(ctx, req, options...).Get(ctx)
}

// BarLocalAsync executes a(n) test.activity.v1.Example.Bar activity (asynchronously, locally)
func BarLocalAsync(ctx workflow.Context, req *BarInput, options ...*BarLocalActivityOptions) *BarFuture {
	var o *BarLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &BarFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = BarActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &BarFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// BarActivityOptions provides configuration for a(n) test.activity.v1.Example.Bar activity
type BarActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewBarActivityOptions initializes a new BarActivityOptions value
func NewBarActivityOptions() *BarActivityOptions {
	return &BarActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *BarActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *BarActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *BarActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *BarActivityOptions) WithDataConverter(dc converter.DataConverter) *BarActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *BarActivityOptions) WithHeartbeatTimeout(d time.Duration) *BarActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BarActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BarActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *BarActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *BarActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *BarActivityOptions) WithScheduleToStartTimeout(d time.Duration) *BarActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *BarActivityOptions) WithStartToCloseTimeout(d time.Duration) *BarActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BarActivityOptions) WithTaskQueue(tq string) *BarActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *BarActivityOptions) WithWaitForCancellation(wait bool) *BarActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// BarLocalActivityOptions provides configuration for a(n) test.activity.v1.Example.Bar activity
type BarLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *BarInput) error
}

// NewBarLocalActivityOptions initializes a new BarLocalActivityOptions value
func NewBarLocalActivityOptions() *BarLocalActivityOptions {
	return &BarLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *BarLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.activity.v1.Example.Bar implementation
func (o *BarLocalActivityOptions) Local(fn func(context.Context, *BarInput) error) *BarLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *BarLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *BarLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *BarLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *BarLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BarLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BarLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *BarLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *BarLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *BarLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *BarLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterBazActivity registers a test.activity.v1.Example.Baz activity
func RegisterBazActivity(r worker.ActivityRegistry, fn func(context.Context) (*BazOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: BazActivityName,
	})
}

// BazFuture describes a(n) test.activity.v1.Example.Baz activity execution
type BazFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *BazFuture) Get(ctx workflow.Context) (*BazOutput, error) {
	var resp BazOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *BazFuture) Select(sel workflow.Selector, fn func(*BazFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Baz executes a(n) test.activity.v1.Example.Baz activity
func Baz(ctx workflow.Context, options ...*BazActivityOptions) (*BazOutput, error) {
	return BazAsync(ctx, options...).Get(ctx)
}

// BazAsync executes a(n) test.activity.v1.Example.Baz activity (asynchronously)
func BazAsync(ctx workflow.Context, options ...*BazActivityOptions) *BazFuture {
	var o *BazActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBazActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &BazFuture{Future: errF}
	}
	activity := BazActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &BazFuture{Future: workflow.ExecuteActivity(ctx, activity)}
	return future
}

// BazLocal executes a(n) test.activity.v1.Example.Baz activity (locally)
func BazLocal(ctx workflow.Context, options ...*BazLocalActivityOptions) (*BazOutput, error) {
	return BazLocalAsync(ctx, options...).Get(ctx)
}

// BazLocalAsync executes a(n) test.activity.v1.Example.Baz activity (asynchronously, locally)
func BazLocalAsync(ctx workflow.Context, options ...*BazLocalActivityOptions) *BazFuture {
	var o *BazLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBazLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &BazFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = BazActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &BazFuture{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future
}

// BazActivityOptions provides configuration for a(n) test.activity.v1.Example.Baz activity
type BazActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewBazActivityOptions initializes a new BazActivityOptions value
func NewBazActivityOptions() *BazActivityOptions {
	return &BazActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *BazActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *BazActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *BazActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *BazActivityOptions) WithDataConverter(dc converter.DataConverter) *BazActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *BazActivityOptions) WithHeartbeatTimeout(d time.Duration) *BazActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BazActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BazActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *BazActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *BazActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *BazActivityOptions) WithScheduleToStartTimeout(d time.Duration) *BazActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *BazActivityOptions) WithStartToCloseTimeout(d time.Duration) *BazActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BazActivityOptions) WithTaskQueue(tq string) *BazActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *BazActivityOptions) WithWaitForCancellation(wait bool) *BazActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// BazLocalActivityOptions provides configuration for a(n) test.activity.v1.Example.Baz activity
type BazLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context) (*BazOutput, error)
}

// NewBazLocalActivityOptions initializes a new BazLocalActivityOptions value
func NewBazLocalActivityOptions() *BazLocalActivityOptions {
	return &BazLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *BazLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.activity.v1.Example.Baz implementation
func (o *BazLocalActivityOptions) Local(fn func(context.Context) (*BazOutput, error)) *BazLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *BazLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *BazLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *BazLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *BazLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BazLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BazLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *BazLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *BazLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *BazLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *BazLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterFooActivity registers a test.activity.v1.Example.Foo activity
func RegisterFooActivity(r worker.ActivityRegistry, fn func(context.Context, *FooInput) (*FooOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: FooActivityName,
	})
}

// FooFuture describes a(n) test.activity.v1.Example.Foo activity execution
type FooFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *FooFuture) Get(ctx workflow.Context) (*FooOutput, error) {
	var resp FooOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *FooFuture) Select(sel workflow.Selector, fn func(*FooFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Foo executes a(n) test.activity.v1.Example.Foo activity
func Foo(ctx workflow.Context, req *FooInput, options ...*FooActivityOptions) (*FooOutput, error) {
	return FooAsync(ctx, req, options...).Get(ctx)
}

// FooAsync executes a(n) test.activity.v1.Example.Foo activity (asynchronously)
func FooAsync(ctx workflow.Context, req *FooInput, options ...*FooActivityOptions) *FooFuture {
	var o *FooActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &FooFuture{Future: errF}
	}
	activity := FooActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &FooFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// FooLocal executes a(n) test.activity.v1.Example.Foo activity (locally)
func FooLocal(ctx workflow.Context, req *FooInput, options ...*FooLocalActivityOptions) (*FooOutput, error) {
	return FooLocalAsync(ctx, req, options...).Get(ctx)
}

// FooLocalAsync executes a(n) test.activity.v1.Example.Foo activity (asynchronously, locally)
func FooLocalAsync(ctx workflow.Context, req *FooInput, options ...*FooLocalActivityOptions) *FooFuture {
	var o *FooLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &FooFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = FooActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &FooFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// FooActivityOptions provides configuration for a(n) test.activity.v1.Example.Foo activity
type FooActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewFooActivityOptions initializes a new FooActivityOptions value
func NewFooActivityOptions() *FooActivityOptions {
	return &FooActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *FooActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *FooActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *FooActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *FooActivityOptions) WithDataConverter(dc converter.DataConverter) *FooActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *FooActivityOptions) WithHeartbeatTimeout(d time.Duration) *FooActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *FooActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *FooActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *FooActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *FooActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *FooActivityOptions) WithScheduleToStartTimeout(d time.Duration) *FooActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *FooActivityOptions) WithStartToCloseTimeout(d time.Duration) *FooActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *FooActivityOptions) WithTaskQueue(tq string) *FooActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *FooActivityOptions) WithWaitForCancellation(wait bool) *FooActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// FooLocalActivityOptions provides configuration for a(n) test.activity.v1.Example.Foo activity
type FooLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *FooInput) (*FooOutput, error)
}

// NewFooLocalActivityOptions initializes a new FooLocalActivityOptions value
func NewFooLocalActivityOptions() *FooLocalActivityOptions {
	return &FooLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *FooLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.activity.v1.Example.Foo implementation
func (o *FooLocalActivityOptions) Local(fn func(context.Context, *FooInput) (*FooOutput, error)) *FooLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *FooLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *FooLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *FooLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *FooLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *FooLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *FooLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *FooLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *FooLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *FooLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *FooLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterQuxActivity registers a test.activity.v1.Example.Qux activity
func RegisterQuxActivity(r worker.ActivityRegistry, fn func(context.Context) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: QuxActivityName,
	})
}

// QuxFuture describes a(n) test.activity.v1.Example.Qux activity execution
type QuxFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *QuxFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *QuxFuture) Select(sel workflow.Selector, fn func(*QuxFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Qux executes a(n) test.activity.v1.Example.Qux activity
func Qux(ctx workflow.Context, options ...*QuxActivityOptions) error {
	return QuxAsync(ctx, options...).Get(ctx)
}

// QuxAsync executes a(n) test.activity.v1.Example.Qux activity (asynchronously)
func QuxAsync(ctx workflow.Context, options ...*QuxActivityOptions) *QuxFuture {
	var o *QuxActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewQuxActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &QuxFuture{Future: errF}
	}
	activity := QuxActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &QuxFuture{Future: workflow.ExecuteActivity(ctx, activity)}
	return future
}

// QuxLocal executes a(n) test.activity.v1.Example.Qux activity (locally)
func QuxLocal(ctx workflow.Context, options ...*QuxLocalActivityOptions) error {
	return QuxLocalAsync(ctx, options...).Get(ctx)
}

// QuxLocalAsync executes a(n) test.activity.v1.Example.Qux activity (asynchronously, locally)
func QuxLocalAsync(ctx workflow.Context, options ...*QuxLocalActivityOptions) *QuxFuture {
	var o *QuxLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewQuxLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &QuxFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = QuxActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &QuxFuture{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future
}

// QuxActivityOptions provides configuration for a(n) test.activity.v1.Example.Qux activity
type QuxActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewQuxActivityOptions initializes a new QuxActivityOptions value
func NewQuxActivityOptions() *QuxActivityOptions {
	return &QuxActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *QuxActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *QuxActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *QuxActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *QuxActivityOptions) WithDataConverter(dc converter.DataConverter) *QuxActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *QuxActivityOptions) WithHeartbeatTimeout(d time.Duration) *QuxActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *QuxActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *QuxActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *QuxActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *QuxActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *QuxActivityOptions) WithScheduleToStartTimeout(d time.Duration) *QuxActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *QuxActivityOptions) WithStartToCloseTimeout(d time.Duration) *QuxActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *QuxActivityOptions) WithTaskQueue(tq string) *QuxActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *QuxActivityOptions) WithWaitForCancellation(wait bool) *QuxActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// QuxLocalActivityOptions provides configuration for a(n) test.activity.v1.Example.Qux activity
type QuxLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context) error
}

// NewQuxLocalActivityOptions initializes a new QuxLocalActivityOptions value
func NewQuxLocalActivityOptions() *QuxLocalActivityOptions {
	return &QuxLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *QuxLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.activity.v1.Example.Qux implementation
func (o *QuxLocalActivityOptions) Local(fn func(context.Context) error) *QuxLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *QuxLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *QuxLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *QuxLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *QuxLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *QuxLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *QuxLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *QuxLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *QuxLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *QuxLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *QuxLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithExampleSchemeTypes registers all Example protobuf types with the given scheme
func WithExampleSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_activity_v1_activity_proto.Messages().ByName("BarInput"))
		s.RegisterType(File_test_activity_v1_activity_proto.Messages().ByName("BazOutput"))
		s.RegisterType(File_test_activity_v1_activity_proto.Messages().ByName("FooInput"))
		s.RegisterType(File_test_activity_v1_activity_proto.Messages().ByName("FooOutput"))
	}
}
