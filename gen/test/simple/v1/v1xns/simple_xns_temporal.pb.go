// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/simple/v1/simple.proto
package v1xns

import (
	"context"
	"errors"
	"fmt"
	temporalv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/v1"
	xnsv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/xns/v1"
	v11 "github.com/cludden/protoc-gen-go-temporal/gen/test/simple/common/v1"
	v1 "github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1"
	convert "github.com/cludden/protoc-gen-go-temporal/pkg/convert"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	xns "github.com/cludden/protoc-gen-go-temporal/pkg/xns"
	uuid "github.com/google/uuid"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"time"
)

// SimpleOptions is used to configure mycompany.simple.Simple xns activity registration
type SimpleOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewSimpleOptions initializes a new SimpleOptions value
func NewSimpleOptions() *SimpleOptions {
	return &SimpleOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *SimpleOptions) WithErrorConverter(errorConverter func(error) error) *SimpleOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *SimpleOptions) WithFilter(filter func(string) string) *SimpleOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *SimpleOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *SimpleOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// simpleOptions is a reference to the SimpleOptions initialized at registration
var simpleOptions *SimpleOptions

// RegisterSimpleActivities registers mycompany.simple.Simple cross-namespace activities
func RegisterSimpleActivities(r worker.ActivityRegistry, c v1.SimpleClient, options ...*SimpleOptions) {
	if simpleOptions == nil && len(options) > 0 && options[0] != nil {
		simpleOptions = options[0]
	}
	a := &simpleActivities{c}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeWorkflow1WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow1"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomeWorkflow1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow1WithSomeUpdate2"); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow1WithSomeUpdate2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeWorkflow2WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow2"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomeWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1"); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow2WithSomeSignal1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow2WithSomeUpdate1"); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow2WithSomeUpdate1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeWorkflow3WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow3, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow3"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomeWorkflow3, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2"); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow3WithSomeSignal2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeWorkflow4WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeWorkflow4, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow4"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomeWorkflow4, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeQuery1QueryName); name != "" {
		r.RegisterActivityWithOptions(a.SomeQuery1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeQuery2QueryName); name != "" {
		r.RegisterActivityWithOptions(a.SomeQuery2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeSignal1SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeSignal1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeSignal2SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeSignal2, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeSignal3SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeSignal3, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeUpdate1UpdateName); name != "" {
		r.RegisterActivityWithOptions(a.SomeUpdate1, activity.RegisterOptions{Name: name})
	}
	if name := simpleOptions.filterActivity(v1.SomeUpdate2UpdateName); name != "" {
		r.RegisterActivityWithOptions(a.SomeUpdate2, activity.RegisterOptions{Name: name})
	}
}

// SomeWorkflow1WorkflowOptions are used to configure a(n) mycompany.simple.SomeWorkflow1 workflow execution
type SomeWorkflow1WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow1WorkflowOptions initializes a new SomeWorkflow1WorkflowOptions value
func NewSomeWorkflow1WorkflowOptions() *SomeWorkflow1WorkflowOptions {
	return &SomeWorkflow1WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomeWorkflow1WorkflowOptions) Build(ctx workflow.Context, input *v1.SomeWorkflow1Request) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeWorkflow1Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeWorkflow1\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow1WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow1WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow1WorkflowOptions) WithDetached(d bool) *SomeWorkflow1WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow1WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow1WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeWorkflow1WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomeWorkflow1WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeWorkflow1WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow1WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow1WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow1WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow1Run provides a handle to a mycompany.simple.SomeWorkflow1 workflow execution
type SomeWorkflow1Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeWorkflow1Response, error)

	// ID returns the workflow id
	ID() string

	// SomeQuery1 queries some thing.
	SomeQuery1(workflow.Context, ...*SomeQuery1QueryOptions) (*v1.SomeQuery1Response, error)

	// SomeQuery1 queries some thing.
	SomeQuery1Async(workflow.Context, ...*SomeQuery1QueryOptions) (SomeQuery1QueryHandle, error)

	// SomeQuery2 queries some thing.
	SomeQuery2(workflow.Context, *v1.SomeQuery2Request, ...*SomeQuery2QueryOptions) (*v1.SomeQuery2Response, error)

	// SomeQuery2 queries some thing.
	SomeQuery2Async(workflow.Context, *v1.SomeQuery2Request, ...*SomeQuery2QueryOptions) (SomeQuery2QueryHandle, error)

	// SomeSignal1 is a signal.
	SomeSignal1(workflow.Context, ...*SomeSignal1SignalOptions) error

	// SomeSignal1 is a signal.
	SomeSignal1Async(workflow.Context, ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error)

	// SomeSignal2 is a signal.
	SomeSignal2(workflow.Context, *v1.SomeSignal2Request, ...*SomeSignal2SignalOptions) error

	// SomeSignal2 is a signal.
	SomeSignal2Async(workflow.Context, *v1.SomeSignal2Request, ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error)

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(workflow.Context, *v1.SomeUpdate1Request, ...*SomeUpdate1UpdateOptions) (*v1.SomeUpdate1Response, error)

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1Async(workflow.Context, *v1.SomeUpdate1Request, ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error)

	// SomeUpdate2 executes a(n) mycompany.simple.Simple.SomeUpdate2 update and blocks until completion
	SomeUpdate2(workflow.Context, *v1.SomeUpdate2Request, ...*SomeUpdate2UpdateOptions) (*v1.SomeUpdate2Response, error)

	// SomeUpdate2Async executes a(n) mycompany.simple.Simple.SomeUpdate2 update and returns a handle to the underlying activity
	SomeUpdate2Async(workflow.Context, *v1.SomeUpdate2Request, ...*SomeUpdate2UpdateOptions) (SomeUpdate2Handle, error)
}

// someWorkflow1Run provides a(n) SomeWorkflow1Run implementation
type someWorkflow1Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *someWorkflow1Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow1Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomeWorkflow1Async(r.ctx, r.id, "").(*someWorkflow1Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow1Run) Get(ctx workflow.Context) (*v1.SomeWorkflow1Response, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomeWorkflow1Async(ctx, r.id, "", NewGetSomeWorkflow1Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*someWorkflow1Run)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.SomeWorkflow1Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someWorkflow1Run) ID() string {
	return r.id
}

// SomeQuery1 queries some thing.
func (r *someWorkflow1Run) SomeQuery1(ctx workflow.Context, opts ...*SomeQuery1QueryOptions) (*v1.SomeQuery1Response, error) {
	return SomeQuery1(ctx, r.ID(), "", opts...)
}

// SomeQuery1 queries some thing.
func (r *someWorkflow1Run) SomeQuery1Async(ctx workflow.Context, opts ...*SomeQuery1QueryOptions) (SomeQuery1QueryHandle, error) {
	return SomeQuery1Async(ctx, r.ID(), "", opts...)
}

// SomeQuery2 queries some thing.
func (r *someWorkflow1Run) SomeQuery2(ctx workflow.Context, req *v1.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (*v1.SomeQuery2Response, error) {
	return SomeQuery2(ctx, r.ID(), "", req, opts...)
}

// SomeQuery2 queries some thing.
func (r *someWorkflow1Run) SomeQuery2Async(ctx workflow.Context, req *v1.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (SomeQuery2QueryHandle, error) {
	return SomeQuery2Async(ctx, r.ID(), "", req, opts...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow1Run) SomeSignal1(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) error {
	return SomeSignal1(ctx, r.ID(), "", opts...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow1Run) SomeSignal1Async(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error) {
	return SomeSignal1Async(ctx, r.ID(), "", opts...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow1Run) SomeSignal2(ctx workflow.Context, req *v1.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) error {
	return SomeSignal2(ctx, r.ID(), "", req, opts...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow1Run) SomeSignal2Async(ctx workflow.Context, req *v1.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error) {
	return SomeSignal2Async(ctx, r.ID(), "", req, opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow1Run) SomeUpdate1(ctx workflow.Context, req *v1.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (*v1.SomeUpdate1Response, error) {
	return SomeUpdate1(ctx, r.ID(), "", req, opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow1Run) SomeUpdate1Async(ctx workflow.Context, req *v1.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error) {
	return SomeUpdate1Async(ctx, r.ID(), "", req, opts...)
}

// SomeUpdate2 executes a(n) mycompany.simple.Simple.SomeUpdate2 update and blocks until completion
func (r *someWorkflow1Run) SomeUpdate2(ctx workflow.Context, req *v1.SomeUpdate2Request, opts ...*SomeUpdate2UpdateOptions) (*v1.SomeUpdate2Response, error) {
	return SomeUpdate2(ctx, r.ID(), "", req, opts...)
}

// SomeUpdate2Async executes a(n) mycompany.simple.Simple.SomeUpdate2 update and returns a handle to the underlying activity
func (r *someWorkflow1Run) SomeUpdate2Async(ctx workflow.Context, req *v1.SomeUpdate2Request, opts ...*SomeUpdate2UpdateOptions) (SomeUpdate2Handle, error) {
	return SomeUpdate2Async(ctx, r.ID(), "", req, opts...)
}

// SomeWorkflow1 does some workflow thing.
func SomeWorkflow1(ctx workflow.Context, req *v1.SomeWorkflow1Request, opts ...*SomeWorkflow1WorkflowOptions) (*v1.SomeWorkflow1Response, error) {
	run, err := SomeWorkflow1Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow1 does some workflow thing.
func SomeWorkflow1Async(ctx workflow.Context, input *v1.SomeWorkflow1Request, opts ...*SomeWorkflow1WorkflowOptions) (SomeWorkflow1Run, error) {
	activityName := simpleOptions.filterActivity(v1.SomeWorkflow1WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeWorkflow1WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeWorkflow1WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeWorkflow1WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow1Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomeWorkflow1 returns a(n) mycompany.simple.SomeWorkflow1 workflow execution
func GetSomeWorkflow1(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow1Options) (out *v1.SomeWorkflow1Response, err error) {
	out, err = GetSomeWorkflow1Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetSomeWorkflow1Async returns a handle to a(n) mycompany.simple.SomeWorkflow1 workflow execution
func GetSomeWorkflow1Async(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow1Options) SomeWorkflow1Run {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow1")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &someWorkflow1Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomeWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomeWorkflow1Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(simpleOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &someWorkflow1Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow1Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomeWorkflow1Options are used to configure a(n) mycompany.simple.SomeWorkflow1 workflow execution getter activity
type GetSomeWorkflow1Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomeWorkflow1Options initializes a new GetSomeWorkflow1Options value
func NewGetSomeWorkflow1Options() *GetSomeWorkflow1Options {
	return &GetSomeWorkflow1Options{}
}

// Build initializes the activity context and input
func (opt *GetSomeWorkflow1Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomeWorkflow1Options) WithActivityOptions(ao workflow.ActivityOptions) *GetSomeWorkflow1Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomeWorkflow1Options) WithHeartbeatInterval(d time.Duration) *GetSomeWorkflow1Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomeWorkflow1Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomeWorkflow1Options {
	o.parentClosePolicy = policy
	return o
}

// SomeWorkflow1WithSomeUpdate2Options are used to configure a(n) mycompany.simple.Simple.SomeUpdate2 update for a(n) mycompany.simple.SomeWorkflow1 workflow
type SomeWorkflow1WithSomeUpdate2Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	updateOptions     *SomeUpdate2UpdateOptions
	parentClosePolicy enumsv1.ParentClosePolicy
	workflowOptions   *SomeWorkflow1WorkflowOptions
}

// NewSomeWorkflow1WithSomeUpdate2Options initializes a new SomeWorkflow1WithSomeUpdate2Options value
func NewSomeWorkflow1WithSomeUpdate2Options() *SomeWorkflow1WithSomeUpdate2Options {
	return &SomeWorkflow1WithSomeUpdate2Options{}
}

// Build builds the activity context and input for an update with start workflow activity
func (o *SomeWorkflow1WithSomeUpdate2Options) Build(ctx workflow.Context, input *v1.SomeWorkflow1Request, update *v1.SomeUpdate2Request) (workflow.Context, *xnsv1.UpdateWithStartRequest, error) {
	wo := o.workflowOptions
	if wo == nil {
		wo = NewSomeWorkflow1WorkflowOptions()
	}

	_, swreq, err := wo.Build(ctx, input)
	if err != nil {
		return nil, nil, fmt.Errorf("error building start workflow options: %w", err)
	}

	uo := o.updateOptions
	if uo == nil {
		uo = NewSomeUpdate2UpdateOptions()
	}

	ctx, ureq, err := uo.Build(ctx, swreq.GetStartWorkflowOptions().GetId(), "", update)
	if err != nil {
		return nil, nil, fmt.Errorf("error building update options: %w", err)
	}

	var ao workflow.ActivityOptions
	if o.activityOptions != nil {
		ao = *o.activityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if o.heartbeatInterval == 0 {
		o.heartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.UpdateWithStartRequest{
		HeartbeatInterval:     durationpb.New(o.heartbeatInterval),
		Input:                 swreq.GetRequest(),
		ParentClosePolicy:     convert.ToParentClosePolicy(o.parentClosePolicy),
		StartWorkflowOptions:  swreq.GetStartWorkflowOptions(),
		Update:                ureq.GetRequest(),
		UpdateWorkflowOptions: ureq.GetUpdateWorkflowOptions(),
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *SomeWorkflow1WithSomeUpdate2Options) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow1WithSomeUpdate2Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *SomeWorkflow1WithSomeUpdate2Options) WithHeartbeatInterval(d time.Duration) *SomeWorkflow1WithSomeUpdate2Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the parent close policy for the workflow
func (o *SomeWorkflow1WithSomeUpdate2Options) WithParentClosePolicy(p enumsv1.ParentClosePolicy) *SomeWorkflow1WithSomeUpdate2Options {
	o.parentClosePolicy = p
	return o
}

// WithUpdateOptions can be used to customize the update options
func (o *SomeWorkflow1WithSomeUpdate2Options) WithUpdateOptions(uo *SomeUpdate2UpdateOptions) *SomeWorkflow1WithSomeUpdate2Options {
	o.updateOptions = uo
	return o
}

// WithWorkflowOptions can be used to customize the workflow options
func (o *SomeWorkflow1WithSomeUpdate2Options) WithWorkflowOptions(wo *SomeWorkflow1WorkflowOptions) *SomeWorkflow1WithSomeUpdate2Options {
	o.workflowOptions = wo
	return o
}

// SomeWorkflow1WithSomeUpdate2 executes a(n) mycompany.simple.Simple.SomeUpdate2 update for a(n) mycompany.simple.SomeWorkflow1 workflow, starting it if necessary, and blocks until error or update is complete
func SomeWorkflow1WithSomeUpdate2(ctx workflow.Context, input *v1.SomeWorkflow1Request, update *v1.SomeUpdate2Request, options ...*SomeWorkflow1WithSomeUpdate2Options) (*v1.SomeUpdate2Response, SomeWorkflow1Run, error) {
	handle, run, err := SomeWorkflow1WithSomeUpdate2Async(ctx, input, update, options...)
	if err != nil {
		return nil, run, err
	}
	if out, err := handle.Get(ctx); err != nil {
		return nil, run, err
	} else {
		return out, run, nil
	}
}

// SomeWorkflow1WithSomeUpdate2Async executes a(n) mycompany.simple.Simple.SomeUpdate2 update for a(n) mycompany.simple.SomeWorkflow1 workflow, starting it if necessary, and returns a handle to the update and workflow execution
func SomeWorkflow1WithSomeUpdate2Async(ctx workflow.Context, input *v1.SomeWorkflow1Request, update *v1.SomeUpdate2Request, options ...*SomeWorkflow1WithSomeUpdate2Options) (SomeUpdate2Handle, SomeWorkflow1Run, error) {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow1WithSomeUpdate2")
	if activityName == "" {
		return nil, nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
	}
	var o *SomeWorkflow1WithSomeUpdate2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow1WithSomeUpdate2Options()
	}
	ctx, req, err := o.Build(ctx, input, update)
	if err != nil {
		return nil, nil, simpleOptions.convertError(err)
	}
	var parentClosePolicy enumsv1.ParentClosePolicy
	if p := req.GetParentClosePolicy(); p != temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_UNSPECIFIED {
		parentClosePolicy = enumsv1.ParentClosePolicy(p)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	handle := &someUpdate2Handle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
	}
	run := &someWorkflow1Run{
		cancel:            cancel,
		ctx:               ctx,
		heartbeatInterval: req.GetHeartbeatInterval().AsDuration(),
		id:                req.GetStartWorkflowOptions().GetId(),
		parentClosePolicy: parentClosePolicy,
	}
	return handle, run, nil
}

// SomeWorkflow2WorkflowOptions are used to configure a(n) mycompany.simple.SomeWorkflow2 workflow execution
type SomeWorkflow2WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow2WorkflowOptions initializes a new SomeWorkflow2WorkflowOptions value
func NewSomeWorkflow2WorkflowOptions() *SomeWorkflow2WorkflowOptions {
	return &SomeWorkflow2WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomeWorkflow2WorkflowOptions) Build(ctx workflow.Context) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeWorkflow2Idexpression, nil)
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeWorkflow2\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow2WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow2WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow2WorkflowOptions) WithDetached(d bool) *SomeWorkflow2WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow2WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow2WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeWorkflow2WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomeWorkflow2WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeWorkflow2WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow2WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow2WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow2WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow2Run provides a handle to a mycompany.simple.SomeWorkflow2 workflow execution
type SomeWorkflow2Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) error

	// ID returns the workflow id
	ID() string

	// SomeSignal1 is a signal.
	SomeSignal1(workflow.Context, ...*SomeSignal1SignalOptions) error

	// SomeSignal1 is a signal.
	SomeSignal1Async(workflow.Context, ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error)

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(workflow.Context, *v1.SomeUpdate1Request, ...*SomeUpdate1UpdateOptions) (*v1.SomeUpdate1Response, error)

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1Async(workflow.Context, *v1.SomeUpdate1Request, ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error)
}

// someWorkflow2Run provides a(n) SomeWorkflow2Run implementation
type someWorkflow2Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *someWorkflow2Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow2Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomeWorkflow2Async(r.ctx, r.id, "").(*someWorkflow2Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow2Run) Get(ctx workflow.Context) error {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomeWorkflow2Async(ctx, r.id, "", NewGetSomeWorkflow2Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*someWorkflow2Run)
		r.future = rr.future
		r.cancel = cancel
	}
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *someWorkflow2Run) ID() string {
	return r.id
}

// SomeSignal1 is a signal.
func (r *someWorkflow2Run) SomeSignal1(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) error {
	return SomeSignal1(ctx, r.ID(), "", opts...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow2Run) SomeSignal1Async(ctx workflow.Context, opts ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error) {
	return SomeSignal1Async(ctx, r.ID(), "", opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow2Run) SomeUpdate1(ctx workflow.Context, req *v1.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (*v1.SomeUpdate1Response, error) {
	return SomeUpdate1(ctx, r.ID(), "", req, opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow2Run) SomeUpdate1Async(ctx workflow.Context, req *v1.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error) {
	return SomeUpdate1Async(ctx, r.ID(), "", req, opts...)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2(ctx workflow.Context, opts ...*SomeWorkflow2WorkflowOptions) error {
	run, err := SomeWorkflow2Async(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2Async(ctx workflow.Context, opts ...*SomeWorkflow2WorkflowOptions) (SomeWorkflow2Run, error) {
	activityName := simpleOptions.filterActivity(v1.SomeWorkflow2WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeWorkflow2WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeWorkflow2WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeWorkflow2WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx)
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomeWorkflow2 returns a(n) mycompany.simple.SomeWorkflow2 workflow execution
func GetSomeWorkflow2(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow2Options) (err error) {
	err = GetSomeWorkflow2Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return err
	}
	return nil
}

// GetSomeWorkflow2Async returns a handle to a(n) mycompany.simple.SomeWorkflow2 workflow execution
func GetSomeWorkflow2Async(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow2Options) SomeWorkflow2Run {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow2")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &someWorkflow2Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomeWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomeWorkflow2Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(simpleOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &someWorkflow2Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomeWorkflow2Options are used to configure a(n) mycompany.simple.SomeWorkflow2 workflow execution getter activity
type GetSomeWorkflow2Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomeWorkflow2Options initializes a new GetSomeWorkflow2Options value
func NewGetSomeWorkflow2Options() *GetSomeWorkflow2Options {
	return &GetSomeWorkflow2Options{}
}

// Build initializes the activity context and input
func (opt *GetSomeWorkflow2Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomeWorkflow2Options) WithActivityOptions(ao workflow.ActivityOptions) *GetSomeWorkflow2Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomeWorkflow2Options) WithHeartbeatInterval(d time.Duration) *GetSomeWorkflow2Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomeWorkflow2Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomeWorkflow2Options {
	o.parentClosePolicy = policy
	return o
}

// SomeWorkflow2WithSomeSignal1Options are used to configure a(n) mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1 activity
type SomeWorkflow2WithSomeSignal1Options struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow2WithSomeSignal1Options initializes a new SomeWorkflow2WithSomeSignal1Options value
func NewSomeWorkflow2WithSomeSignal1Options() *SomeWorkflow2WithSomeSignal1Options {
	return &SomeWorkflow2WithSomeSignal1Options{}
}

// Build initializes the activity context and input
func (opts *SomeWorkflow2WithSomeSignal1Options) Build(ctx workflow.Context) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeWorkflow2Idexpression, nil)
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeWorkflow2\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow2WithSomeSignal1Options) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow2WithSomeSignal1Options {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow2WithSomeSignal1Options) WithDetached(d bool) *SomeWorkflow2WithSomeSignal1Options {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow2WithSomeSignal1Options) WithHeartbeatInterval(d time.Duration) *SomeWorkflow2WithSomeSignal1Options {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeWorkflow2WithSomeSignal1Options) WithHeartbeatTimeout(d time.Duration) *SomeWorkflow2WithSomeSignal1Options {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeWorkflow2WithSomeSignal1Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow2WithSomeSignal1Options {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow2WithSomeSignal1Options) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow2WithSomeSignal1Options {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2WithSomeSignal1(ctx workflow.Context, opts ...*SomeWorkflow2WithSomeSignal1Options) error {
	run, err := SomeWorkflow2WithSomeSignal1Async(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2WithSomeSignal1Async executes a(n) mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1 activity and returns a handle to the activity
func SomeWorkflow2WithSomeSignal1Async(ctx workflow.Context, opts ...*SomeWorkflow2WithSomeSignal1Options) (SomeWorkflow2Run, error) {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "mycompany.simple.Simple.SomeWorkflow2WithSomeSignal1"),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeWorkflow2WithSomeSignal1Options
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeWorkflow2WithSomeSignal1Options()
	}
	ctx, req, err := opt.Build(ctx)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// SomeWorkflow2WithSomeUpdate1Options are used to configure a(n) mycompany.simple.Simple.SomeUpdate1 update for a(n) mycompany.simple.SomeWorkflow2 workflow
type SomeWorkflow2WithSomeUpdate1Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	updateOptions     *SomeUpdate1UpdateOptions
	parentClosePolicy enumsv1.ParentClosePolicy
	workflowOptions   *SomeWorkflow2WorkflowOptions
}

// NewSomeWorkflow2WithSomeUpdate1Options initializes a new SomeWorkflow2WithSomeUpdate1Options value
func NewSomeWorkflow2WithSomeUpdate1Options() *SomeWorkflow2WithSomeUpdate1Options {
	return &SomeWorkflow2WithSomeUpdate1Options{}
}

// Build builds the activity context and input for an update with start workflow activity
func (o *SomeWorkflow2WithSomeUpdate1Options) Build(ctx workflow.Context, update *v1.SomeUpdate1Request) (workflow.Context, *xnsv1.UpdateWithStartRequest, error) {
	wo := o.workflowOptions
	if wo == nil {
		wo = NewSomeWorkflow2WorkflowOptions()
	}

	_, swreq, err := wo.Build(ctx)
	if err != nil {
		return nil, nil, fmt.Errorf("error building start workflow options: %w", err)
	}

	uo := o.updateOptions
	if uo == nil {
		uo = NewSomeUpdate1UpdateOptions()
	}

	ctx, ureq, err := uo.Build(ctx, swreq.GetStartWorkflowOptions().GetId(), "", update)
	if err != nil {
		return nil, nil, fmt.Errorf("error building update options: %w", err)
	}

	var ao workflow.ActivityOptions
	if o.activityOptions != nil {
		ao = *o.activityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if o.heartbeatInterval == 0 {
		o.heartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.UpdateWithStartRequest{
		HeartbeatInterval:     durationpb.New(o.heartbeatInterval),
		ParentClosePolicy:     convert.ToParentClosePolicy(o.parentClosePolicy),
		StartWorkflowOptions:  swreq.GetStartWorkflowOptions(),
		Update:                ureq.GetRequest(),
		UpdateWorkflowOptions: ureq.GetUpdateWorkflowOptions(),
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *SomeWorkflow2WithSomeUpdate1Options) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow2WithSomeUpdate1Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *SomeWorkflow2WithSomeUpdate1Options) WithHeartbeatInterval(d time.Duration) *SomeWorkflow2WithSomeUpdate1Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the parent close policy for the workflow
func (o *SomeWorkflow2WithSomeUpdate1Options) WithParentClosePolicy(p enumsv1.ParentClosePolicy) *SomeWorkflow2WithSomeUpdate1Options {
	o.parentClosePolicy = p
	return o
}

// WithUpdateOptions can be used to customize the update options
func (o *SomeWorkflow2WithSomeUpdate1Options) WithUpdateOptions(uo *SomeUpdate1UpdateOptions) *SomeWorkflow2WithSomeUpdate1Options {
	o.updateOptions = uo
	return o
}

// WithWorkflowOptions can be used to customize the workflow options
func (o *SomeWorkflow2WithSomeUpdate1Options) WithWorkflowOptions(wo *SomeWorkflow2WorkflowOptions) *SomeWorkflow2WithSomeUpdate1Options {
	o.workflowOptions = wo
	return o
}

// SomeWorkflow2WithSomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update for a(n) mycompany.simple.SomeWorkflow2 workflow, starting it if necessary, and blocks until error or update is complete
func SomeWorkflow2WithSomeUpdate1(ctx workflow.Context, update *v1.SomeUpdate1Request, options ...*SomeWorkflow2WithSomeUpdate1Options) (*v1.SomeUpdate1Response, SomeWorkflow2Run, error) {
	handle, run, err := SomeWorkflow2WithSomeUpdate1Async(ctx, update, options...)
	if err != nil {
		return nil, run, err
	}
	if out, err := handle.Get(ctx); err != nil {
		return nil, run, err
	} else {
		return out, run, nil
	}
}

// SomeWorkflow2WithSomeUpdate1Async executes a(n) mycompany.simple.Simple.SomeUpdate1 update for a(n) mycompany.simple.SomeWorkflow2 workflow, starting it if necessary, and returns a handle to the update and workflow execution
func SomeWorkflow2WithSomeUpdate1Async(ctx workflow.Context, update *v1.SomeUpdate1Request, options ...*SomeWorkflow2WithSomeUpdate1Options) (SomeUpdate1Handle, SomeWorkflow2Run, error) {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow2WithSomeUpdate1")
	if activityName == "" {
		return nil, nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
	}
	var o *SomeWorkflow2WithSomeUpdate1Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow2WithSomeUpdate1Options()
	}
	ctx, req, err := o.Build(ctx, update)
	if err != nil {
		return nil, nil, simpleOptions.convertError(err)
	}
	var parentClosePolicy enumsv1.ParentClosePolicy
	if p := req.GetParentClosePolicy(); p != temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_UNSPECIFIED {
		parentClosePolicy = enumsv1.ParentClosePolicy(p)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	handle := &someUpdate1Handle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
	}
	run := &someWorkflow2Run{
		cancel:            cancel,
		ctx:               ctx,
		heartbeatInterval: req.GetHeartbeatInterval().AsDuration(),
		id:                req.GetStartWorkflowOptions().GetId(),
		parentClosePolicy: parentClosePolicy,
	}
	return handle, run, nil
}

// SomeWorkflow3WorkflowOptions are used to configure a(n) mycompany.simple.Simple.SomeWorkflow3 workflow execution
type SomeWorkflow3WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow3WorkflowOptions initializes a new SomeWorkflow3WorkflowOptions value
func NewSomeWorkflow3WorkflowOptions() *SomeWorkflow3WorkflowOptions {
	return &SomeWorkflow3WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomeWorkflow3WorkflowOptions) Build(ctx workflow.Context, input *v1.SomeWorkflow3Request) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeWorkflow3Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeWorkflow3\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.RetryPolicy == nil {
		ao.RetryPolicy = &temporal.RetryPolicy{
			MaximumAttempts: int32(2),
		}
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow3WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow3WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow3WorkflowOptions) WithDetached(d bool) *SomeWorkflow3WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow3WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow3WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeWorkflow3WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomeWorkflow3WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeWorkflow3WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow3WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow3WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow3WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow3Run provides a handle to a mycompany.simple.Simple.SomeWorkflow3 workflow execution
type SomeWorkflow3Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) error

	// ID returns the workflow id
	ID() string

	// SomeSignal2 is a signal.
	SomeSignal2(workflow.Context, *v1.SomeSignal2Request, ...*SomeSignal2SignalOptions) error

	// SomeSignal2 is a signal.
	SomeSignal2Async(workflow.Context, *v1.SomeSignal2Request, ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error)
}

// someWorkflow3Run provides a(n) SomeWorkflow3Run implementation
type someWorkflow3Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *someWorkflow3Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow3Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomeWorkflow3Async(r.ctx, r.id, "").(*someWorkflow3Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow3Run) Get(ctx workflow.Context) error {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomeWorkflow3Async(ctx, r.id, "", NewGetSomeWorkflow3Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*someWorkflow3Run)
		r.future = rr.future
		r.cancel = cancel
	}
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *someWorkflow3Run) ID() string {
	return r.id
}

// SomeSignal2 is a signal.
func (r *someWorkflow3Run) SomeSignal2(ctx workflow.Context, req *v1.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) error {
	return SomeSignal2(ctx, r.ID(), "", req, opts...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow3Run) SomeSignal2Async(ctx workflow.Context, req *v1.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error) {
	return SomeSignal2Async(ctx, r.ID(), "", req, opts...)
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func SomeWorkflow3(ctx workflow.Context, req *v1.SomeWorkflow3Request, opts ...*SomeWorkflow3WorkflowOptions) error {
	run, err := SomeWorkflow3Async(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func SomeWorkflow3Async(ctx workflow.Context, input *v1.SomeWorkflow3Request, opts ...*SomeWorkflow3WorkflowOptions) (SomeWorkflow3Run, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeWorkflow3WorkflowName)

	activityName := simpleOptions.filterActivity(v1.SomeWorkflow3WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeWorkflow3WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeWorkflow3WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeWorkflow3WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow3Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomeWorkflow3 returns a(n) mycompany.simple.Simple.SomeWorkflow3 workflow execution
//
// Deprecated: Do not use.
func GetSomeWorkflow3(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow3Options) (err error) {
	err = GetSomeWorkflow3Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return err
	}
	return nil
}

// GetSomeWorkflow3Async returns a handle to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow execution
//
// Deprecated: Do not use.
func GetSomeWorkflow3Async(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow3Options) SomeWorkflow3Run {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow3")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &someWorkflow3Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomeWorkflow3Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomeWorkflow3Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(simpleOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &someWorkflow3Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow3Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomeWorkflow3Options are used to configure a(n) mycompany.simple.Simple.SomeWorkflow3 workflow execution getter activity
//
// Deprecated: Do not use.
type GetSomeWorkflow3Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomeWorkflow3Options initializes a new GetSomeWorkflow3Options value
//
// Deprecated: Do not use.
func NewGetSomeWorkflow3Options() *GetSomeWorkflow3Options {
	return &GetSomeWorkflow3Options{}
}

// Build initializes the activity context and input
func (opt *GetSomeWorkflow3Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomeWorkflow3Options) WithActivityOptions(ao workflow.ActivityOptions) *GetSomeWorkflow3Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomeWorkflow3Options) WithHeartbeatInterval(d time.Duration) *GetSomeWorkflow3Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomeWorkflow3Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomeWorkflow3Options {
	o.parentClosePolicy = policy
	return o
}

// SomeWorkflow3WithSomeSignal2Options are used to configure a(n) mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2 activity
type SomeWorkflow3WithSomeSignal2Options struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow3WithSomeSignal2Options initializes a new SomeWorkflow3WithSomeSignal2Options value
func NewSomeWorkflow3WithSomeSignal2Options() *SomeWorkflow3WithSomeSignal2Options {
	return &SomeWorkflow3WithSomeSignal2Options{}
}

// Build initializes the activity context and input
func (opts *SomeWorkflow3WithSomeSignal2Options) Build(ctx workflow.Context, input *v1.SomeWorkflow3Request, signal *v1.SomeSignal2Request) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeWorkflow3Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeWorkflow3\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal signal request protobuf message
	signalpb, err := anypb.New(signal)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling signal request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.RetryPolicy == nil {
		ao.RetryPolicy = &temporal.RetryPolicy{
			MaximumAttempts: int32(2),
		}
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		Signal:               signalpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow3WithSomeSignal2Options) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow3WithSomeSignal2Options {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow3WithSomeSignal2Options) WithDetached(d bool) *SomeWorkflow3WithSomeSignal2Options {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow3WithSomeSignal2Options) WithHeartbeatInterval(d time.Duration) *SomeWorkflow3WithSomeSignal2Options {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeWorkflow3WithSomeSignal2Options) WithHeartbeatTimeout(d time.Duration) *SomeWorkflow3WithSomeSignal2Options {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeWorkflow3WithSomeSignal2Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow3WithSomeSignal2Options {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow3WithSomeSignal2Options) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow3WithSomeSignal2Options {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func SomeWorkflow3WithSomeSignal2(ctx workflow.Context, input *v1.SomeWorkflow3Request, signal *v1.SomeSignal2Request, opts ...*SomeWorkflow3WithSomeSignal2Options) error {
	run, err := SomeWorkflow3WithSomeSignal2Async(ctx, input, signal, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3WithSomeSignal2Async executes a(n) mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2 activity and returns a handle to the activity
//
// Deprecated: Do not use.
func SomeWorkflow3WithSomeSignal2Async(ctx workflow.Context, input *v1.SomeWorkflow3Request, signal *v1.SomeSignal2Request, opts ...*SomeWorkflow3WithSomeSignal2Options) (SomeWorkflow3Run, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeWorkflow3WorkflowName)

	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "mycompany.simple.Simple.SomeWorkflow3WithSomeSignal2"),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeWorkflow3WithSomeSignal2Options
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeWorkflow3WithSomeSignal2Options()
	}
	ctx, req, err := opt.Build(ctx, input, signal)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow3Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// SomeWorkflow4WorkflowOptions are used to configure a(n) mycompany.simple.Simple.SomeWorkflow4 workflow execution
type SomeWorkflow4WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeWorkflow4WorkflowOptions initializes a new SomeWorkflow4WorkflowOptions value
func NewSomeWorkflow4WorkflowOptions() *SomeWorkflow4WorkflowOptions {
	return &SomeWorkflow4WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomeWorkflow4WorkflowOptions) Build(ctx workflow.Context, input *v11.PaginatedRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeWorkflow4Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeWorkflow4\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeWorkflow4WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeWorkflow4WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeWorkflow4WorkflowOptions) WithDetached(d bool) *SomeWorkflow4WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeWorkflow4WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeWorkflow4WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeWorkflow4WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomeWorkflow4WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeWorkflow4WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow4WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeWorkflow4WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeWorkflow4WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeWorkflow4Run provides a handle to a mycompany.simple.Simple.SomeWorkflow4 workflow execution
type SomeWorkflow4Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v11.PaginatedResponse, error)

	// ID returns the workflow id
	ID() string
}

// someWorkflow4Run provides a(n) SomeWorkflow4Run implementation
type someWorkflow4Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *someWorkflow4Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelSimpleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someWorkflow4Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomeWorkflow4Async(r.ctx, r.id, "").(*someWorkflow4Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someWorkflow4Run) Get(ctx workflow.Context) (*v11.PaginatedResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomeWorkflow4Async(ctx, r.id, "", NewGetSomeWorkflow4Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*someWorkflow4Run)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v11.PaginatedResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someWorkflow4Run) ID() string {
	return r.id
}

// SomeWorkflow4 retrieves a paginated list of items
func SomeWorkflow4(ctx workflow.Context, req *v11.PaginatedRequest, opts ...*SomeWorkflow4WorkflowOptions) (*v11.PaginatedResponse, error) {
	run, err := SomeWorkflow4Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow4 retrieves a paginated list of items
func SomeWorkflow4Async(ctx workflow.Context, input *v11.PaginatedRequest, opts ...*SomeWorkflow4WorkflowOptions) (SomeWorkflow4Run, error) {
	activityName := simpleOptions.filterActivity(v1.SomeWorkflow4WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeWorkflow4WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeWorkflow4WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeWorkflow4WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow4Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomeWorkflow4 returns a(n) mycompany.simple.Simple.SomeWorkflow4 workflow execution
func GetSomeWorkflow4(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow4Options) (out *v11.PaginatedResponse, err error) {
	out, err = GetSomeWorkflow4Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetSomeWorkflow4Async returns a handle to a(n) mycompany.simple.Simple.SomeWorkflow4 workflow execution
func GetSomeWorkflow4Async(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeWorkflow4Options) SomeWorkflow4Run {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.GetSomeWorkflow4")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &someWorkflow4Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomeWorkflow4Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomeWorkflow4Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(simpleOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &someWorkflow4Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someWorkflow4Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomeWorkflow4Options are used to configure a(n) mycompany.simple.Simple.SomeWorkflow4 workflow execution getter activity
type GetSomeWorkflow4Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomeWorkflow4Options initializes a new GetSomeWorkflow4Options value
func NewGetSomeWorkflow4Options() *GetSomeWorkflow4Options {
	return &GetSomeWorkflow4Options{}
}

// Build initializes the activity context and input
func (opt *GetSomeWorkflow4Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomeWorkflow4Options) WithActivityOptions(ao workflow.ActivityOptions) *GetSomeWorkflow4Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomeWorkflow4Options) WithHeartbeatInterval(d time.Duration) *GetSomeWorkflow4Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomeWorkflow4Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomeWorkflow4Options {
	o.parentClosePolicy = policy
	return o
}

// SomeQuery1QueryOptions are used to configure a(n) mycompany.simple.Simple.SomeQuery1 query execution
type SomeQuery1QueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeQuery1QueryOptions initializes a new SomeQuery1QueryOptions value
func NewSomeQuery1QueryOptions() *SomeQuery1QueryOptions {
	return &SomeQuery1QueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeQuery1QueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeQuery1QueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeQuery1QueryOptions) WithHeartbeatInterval(d time.Duration) *SomeQuery1QueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeQuery1QueryHandle provides a handle for a mycompany.simple.Simple.SomeQuery1 query activity
type SomeQuery1QueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeQuery1Response, error)
}

// someQuery1QueryHandle provides a(n) SomeQuery1QueryHandle implementation
type someQuery1QueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *someQuery1QueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someQuery1QueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *someQuery1QueryHandle) Get(ctx workflow.Context) (*v1.SomeQuery1Response, error) {
	var resp v1.SomeQuery1Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeQuery1 queries some thing.
func SomeQuery1(ctx workflow.Context, workflowID string, runID string, opts ...*SomeQuery1QueryOptions) (*v1.SomeQuery1Response, error) {
	handle, err := SomeQuery1Async(ctx, workflowID, runID, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeQuery1Async executes a(n) mycompany.simple.Simple.SomeQuery1 query and returns a handle to the activity
func SomeQuery1Async(ctx workflow.Context, workflowID string, runID string, opts ...*SomeQuery1QueryOptions) (SomeQuery1QueryHandle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeQuery1QueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeQuery1QueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeQuery1QueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	ctx, cancel := workflow.WithCancel(ctx)
	return &someQuery1QueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
		}),
	}, nil
}

// SomeQuery2QueryOptions are used to configure a(n) mycompany.simple.Simple.SomeQuery2 query execution
type SomeQuery2QueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeQuery2QueryOptions initializes a new SomeQuery2QueryOptions value
func NewSomeQuery2QueryOptions() *SomeQuery2QueryOptions {
	return &SomeQuery2QueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeQuery2QueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeQuery2QueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeQuery2QueryOptions) WithHeartbeatInterval(d time.Duration) *SomeQuery2QueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeQuery2QueryHandle provides a handle for a mycompany.simple.Simple.SomeQuery2 query activity
type SomeQuery2QueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeQuery2Response, error)
}

// someQuery2QueryHandle provides a(n) SomeQuery2QueryHandle implementation
type someQuery2QueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *someQuery2QueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someQuery2QueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *someQuery2QueryHandle) Get(ctx workflow.Context) (*v1.SomeQuery2Response, error) {
	var resp v1.SomeQuery2Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeQuery2 queries some thing.
func SomeQuery2(ctx workflow.Context, workflowID string, runID string, req *v1.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (*v1.SomeQuery2Response, error) {
	handle, err := SomeQuery2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeQuery2Async executes a(n) mycompany.simple.Simple.SomeQuery2 query and returns a handle to the activity
func SomeQuery2Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeQuery2Request, opts ...*SomeQuery2QueryOptions) (SomeQuery2QueryHandle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeQuery2QueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeQuery2QueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeQuery2QueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someQuery2QueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeSignal1SignalOptions are used to configure a(n) mycompany.simple.Simple.SomeSignal1 signal execution
type SomeSignal1SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeSignal1SignalOptions initializes a new SomeSignal1SignalOptions value
func NewSomeSignal1SignalOptions() *SomeSignal1SignalOptions {
	return &SomeSignal1SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeSignal1SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeSignal1SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeSignal1SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeSignal1SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeSignal1SignalHandle provides a handle for a mycompany.simple.Simple.SomeSignal1 signal activity
type SomeSignal1SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someSignal1SignalHandle provides a(n) SomeSignal1QueryHandle implementation
type someSignal1SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someSignal1SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someSignal1SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someSignal1SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeSignal1 is a signal.
func SomeSignal1(ctx workflow.Context, workflowID string, runID string, opts ...*SomeSignal1SignalOptions) error {
	handle, err := SomeSignal1Async(ctx, workflowID, runID, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeSignal1Async executes a(n) mycompany.simple.Simple.SomeSignal1 signal
func SomeSignal1Async(ctx workflow.Context, workflowID string, runID string, opts ...*SomeSignal1SignalOptions) (SomeSignal1SignalHandle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeSignal1SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeSignal1SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeSignal1SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	ctx, cancel := workflow.WithCancel(ctx)
	return &someSignal1SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
		}),
	}, nil
}

// SomeSignal2SignalOptions are used to configure a(n) mycompany.simple.Simple.SomeSignal2 signal execution
type SomeSignal2SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeSignal2SignalOptions initializes a new SomeSignal2SignalOptions value
func NewSomeSignal2SignalOptions() *SomeSignal2SignalOptions {
	return &SomeSignal2SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeSignal2SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeSignal2SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeSignal2SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeSignal2SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeSignal2SignalHandle provides a handle for a mycompany.simple.Simple.SomeSignal2 signal activity
type SomeSignal2SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someSignal2SignalHandle provides a(n) SomeSignal2QueryHandle implementation
type someSignal2SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someSignal2SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someSignal2SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someSignal2SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeSignal2 is a signal.
func SomeSignal2(ctx workflow.Context, workflowID string, runID string, req *v1.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) error {
	handle, err := SomeSignal2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeSignal2Async executes a(n) mycompany.simple.Simple.SomeSignal2 signal
func SomeSignal2Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeSignal2Request, opts ...*SomeSignal2SignalOptions) (SomeSignal2SignalHandle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeSignal2SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeSignal2SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeSignal2SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someSignal2SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeSignal3SignalOptions are used to configure a(n) mycompany.simple.Simple.SomeSignal3 signal execution
type SomeSignal3SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeSignal3SignalOptions initializes a new SomeSignal3SignalOptions value
func NewSomeSignal3SignalOptions() *SomeSignal3SignalOptions {
	return &SomeSignal3SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeSignal3SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeSignal3SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeSignal3SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeSignal3SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeSignal3SignalHandle provides a handle for a mycompany.simple.Simple.SomeSignal3 signal activity
type SomeSignal3SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someSignal3SignalHandle provides a(n) SomeSignal3QueryHandle implementation
type someSignal3SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someSignal3SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someSignal3SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someSignal3SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeSignal3 is a signal.
func SomeSignal3(ctx workflow.Context, workflowID string, runID string, req *v1.SomeSignal3Request, opts ...*SomeSignal3SignalOptions) error {
	handle, err := SomeSignal3Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeSignal3Async executes a(n) mycompany.simple.Simple.SomeSignal3 signal
func SomeSignal3Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeSignal3Request, opts ...*SomeSignal3SignalOptions) (SomeSignal3SignalHandle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeSignal3SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeSignal3SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeSignal3SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someSignal3SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeUpdate1UpdateOptions are used to configure a(n) mycompany.simple.Simple.SomeUpdate1 update execution
type SomeUpdate1UpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowOptions
}

// NewSomeUpdate1UpdateOptions initializes a new SomeUpdate1UpdateOptions value
func NewSomeUpdate1UpdateOptions() *SomeUpdate1UpdateOptions {
	return &SomeUpdate1UpdateOptions{}
}

// Build initializes the update options
func (opt *SomeUpdate1UpdateOptions) Build(ctx workflow.Context, workflowID string, runID string, input *v1.SomeUpdate1Request) (workflow.Context, *xnsv1.UpdateRequest, error) {
	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowOptions{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeUpdate1Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeUpdate1\" update", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	inpb, err := anypb.New(input)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	return ctx, &xnsv1.UpdateRequest{
		HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
		Request:               inpb,
		UpdateWorkflowOptions: uopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeUpdate1UpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeUpdate1UpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeUpdate1UpdateOptions) WithHeartbeatInterval(d time.Duration) *SomeUpdate1UpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *SomeUpdate1UpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowOptions) *SomeUpdate1UpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// SomeUpdate1Handle provides a handle to a mycompany.simple.Simple.SomeUpdate1 workflow update
type SomeUpdate1Handle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*v1.SomeUpdate1Response, error)

	// ID returns the update id
	ID() string
}

// someUpdate1Handle provides a(n) SomeUpdate1Handle implementation
type someUpdate1Handle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *someUpdate1Handle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someUpdate1Handle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *someUpdate1Handle) Get(ctx workflow.Context) (*v1.SomeUpdate1Response, error) {
	var resp v1.SomeUpdate1Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someUpdate1Handle) ID() string {
	return r.id
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1(ctx workflow.Context, workflowID string, runID string, req *v1.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (*v1.SomeUpdate1Response, error) {
	run, err := SomeUpdate1Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeUpdate1Async executes a(n) mycompany.simple.Simple.SomeUpdate1 update and blocks until error or response received
func SomeUpdate1Async(ctx workflow.Context, workflowID string, runID string, input *v1.SomeUpdate1Request, opts ...*SomeUpdate1UpdateOptions) (SomeUpdate1Handle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeUpdate1UpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeUpdate1UpdateName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeUpdate1UpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeUpdate1UpdateOptions()
	}

	ctx, req, err := opt.Build(ctx, workflowID, runID, input)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someUpdate1Handle{
		cancel: cancel,
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
		future: workflow.ExecuteActivity(ctx, activityName, req),
	}, nil
}

// SomeUpdate2UpdateOptions are used to configure a(n) mycompany.simple.Simple.SomeUpdate2 update execution
type SomeUpdate2UpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowOptions
}

// NewSomeUpdate2UpdateOptions initializes a new SomeUpdate2UpdateOptions value
func NewSomeUpdate2UpdateOptions() *SomeUpdate2UpdateOptions {
	return &SomeUpdate2UpdateOptions{}
}

// Build initializes the update options
func (opt *SomeUpdate2UpdateOptions) Build(ctx workflow.Context, workflowID string, runID string, input *v1.SomeUpdate2Request) (workflow.Context, *xnsv1.UpdateRequest, error) {
	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowOptions{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomeUpdate2Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Simple.SomeUpdate2\" update", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	inpb, err := anypb.New(input)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	return ctx, &xnsv1.UpdateRequest{
		HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
		Request:               inpb,
		UpdateWorkflowOptions: uopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeUpdate2UpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeUpdate2UpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeUpdate2UpdateOptions) WithHeartbeatInterval(d time.Duration) *SomeUpdate2UpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *SomeUpdate2UpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowOptions) *SomeUpdate2UpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// SomeUpdate2Handle provides a handle to a mycompany.simple.Simple.SomeUpdate2 workflow update
type SomeUpdate2Handle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*v1.SomeUpdate2Response, error)

	// ID returns the update id
	ID() string
}

// someUpdate2Handle provides a(n) SomeUpdate2Handle implementation
type someUpdate2Handle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *someUpdate2Handle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someUpdate2Handle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *someUpdate2Handle) Get(ctx workflow.Context) (*v1.SomeUpdate2Response, error) {
	var resp v1.SomeUpdate2Response
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someUpdate2Handle) ID() string {
	return r.id
}

// SomeUpdate2 executes a(n) mycompany.simple.Simple.SomeUpdate2 update and blocks until error or response received
func SomeUpdate2(ctx workflow.Context, workflowID string, runID string, req *v1.SomeUpdate2Request, opts ...*SomeUpdate2UpdateOptions) (*v1.SomeUpdate2Response, error) {
	run, err := SomeUpdate2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeUpdate2Async executes a(n) mycompany.simple.Simple.SomeUpdate2 update and blocks until error or response received
func SomeUpdate2Async(ctx workflow.Context, workflowID string, runID string, input *v1.SomeUpdate2Request, opts ...*SomeUpdate2UpdateOptions) (SomeUpdate2Handle, error) {
	activityName := simpleOptions.filterActivity(v1.SomeUpdate2UpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeUpdate2UpdateName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeUpdate2UpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeUpdate2UpdateOptions()
	}

	ctx, req, err := opt.Build(ctx, workflowID, runID, input)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someUpdate2Handle{
		cancel: cancel,
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
		future: workflow.ExecuteActivity(ctx, activityName, req),
	}, nil
}

// CancelSimpleWorkflow cancels an existing workflow
func CancelSimpleWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelSimpleWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelSimpleWorkflowAsync cancels an existing workflow
func CancelSimpleWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := simpleOptions.filterActivity("mycompany.simple.Simple.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Simple.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// simpleActivities provides activities that can be used to interact with a(n) Simple service's workflow, queries, signals, and updates across namespaces
type simpleActivities struct {
	client v1.SimpleClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *simpleActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// GetSomeWorkflow1 retrieves a(n) mycompany.simple.SomeWorkflow1 workflow via an activity
func (a *simpleActivities) GetSomeWorkflow1(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.SomeWorkflow1Response, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomeWorkflow1(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, simpleOptions.convertError(err)
					}
				}
				return nil, simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow1 executes a(n) mycompany.simple.SomeWorkflow1 workflow via an activity
func (a *simpleActivities) SomeWorkflow1(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomeWorkflow1Response, err error) {
	// unmarshal workflow request
	var req v1.SomeWorkflow1Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeWorkflow1Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeWorkflow1Run
	run, err = a.client.SomeWorkflow1Async(actx, &req, v1.NewSomeWorkflow1Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, simpleOptions.convertError(err)
					}
				}
				return nil, simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow1WithSomeUpdate2 executes a(n) mycompany.simple.SomeWorkflow1 workflow with a(n) mycompany.simple.Simple.SomeUpdate2 update via an activity
func (a *simpleActivities) SomeWorkflow1WithSomeUpdate2(ctx context.Context, input *xnsv1.UpdateWithStartRequest) (out *v1.SomeUpdate2Response, err error) {
	// unmarshal workflow request
	var req v1.SomeWorkflow1Request
	if err := input.GetInput().UnmarshalTo(&req); err != nil {
		return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeWorkflow1Request", input.GetInput().GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal update request
	var update v1.SomeUpdate2Request
	if err := input.GetUpdate().UnmarshalTo(&update); err != nil {
		return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeUpdate2Request", input.GetUpdate().GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal workflow and update options
	swo := xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions())
	uwo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())

	// execute update with start asynchronously
	handle, run, err := a.client.SomeWorkflow1WithSomeUpdate2Async(
		ctx,
		&req,
		&update,
		v1.NewSomeWorkflow1WithSomeUpdate2Options().WithSomeWorkflow1Options(
			v1.NewSomeWorkflow1Options().WithStartWorkflowOptions(swo),
		).WithSomeUpdate2Options(
			v1.NewSomeUpdate2Options().WithUpdateWorkflowOptions(uwo),
		),
	)
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}

	// return early if detached
	if input.GetDetached() {
		return nil, nil
	}

	// initialize heartbeat interval duration
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatTimeout := activity.GetInfo(ctx).HeartbeatTimeout
		if heartbeatTimeout > 0 {
			heartbeatInterval = heartbeatTimeout / 2
		} else {
			heartbeatInterval = time.Second * 30
		}
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		defer close(doneCh)
		out, err = handle.Get(ctx)
	}()

	// heartbeat activity while waiting for update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())

		case <-activity.GetWorkerStopChannel(ctx):
			return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopping"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopping"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(ctx, time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, simpleOptions.convertError(err)
					}
				}
				return nil, simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		case <-doneCh:
			return out, simpleOptions.convertError(err)
		}
	}
}

// GetSomeWorkflow2 retrieves a(n) mycompany.simple.SomeWorkflow2 workflow via an activity
func (a *simpleActivities) GetSomeWorkflow2(ctx context.Context, input *xnsv1.GetWorkflowRequest) (err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomeWorkflow2(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return simpleOptions.convertError(err)
					}
				}
				return simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow2 executes a(n) mycompany.simple.SomeWorkflow2 workflow via an activity
func (a *simpleActivities) SomeWorkflow2(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeWorkflow2Run
	run, err = a.client.SomeWorkflow2Async(actx, v1.NewSomeWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return simpleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return simpleOptions.convertError(err)
					}
				}
				return simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow2WithSomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal to a(n) mycompany.simple.SomeWorkflow2 workflow via an activity
func (a *simpleActivities) SomeWorkflow2WithSomeSignal1(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeWorkflow2Run
	run, err = a.client.SomeWorkflow2WithSomeSignal1Async(actx, v1.NewSomeWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return simpleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return simpleOptions.convertError(err)
					}
				}
				return simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow2WithSomeUpdate1 executes a(n) mycompany.simple.SomeWorkflow2 workflow with a(n) mycompany.simple.Simple.SomeUpdate1 update via an activity
func (a *simpleActivities) SomeWorkflow2WithSomeUpdate1(ctx context.Context, input *xnsv1.UpdateWithStartRequest) (out *v1.SomeUpdate1Response, err error) {
	// unmarshal update request
	var update v1.SomeUpdate1Request
	if err := input.GetUpdate().UnmarshalTo(&update); err != nil {
		return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeUpdate1Request", input.GetUpdate().GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal workflow and update options
	swo := xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions())
	uwo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())

	// execute update with start asynchronously
	handle, run, err := a.client.SomeWorkflow2WithSomeUpdate1Async(
		ctx,
		&update,
		v1.NewSomeWorkflow2WithSomeUpdate1Options().WithSomeWorkflow2Options(
			v1.NewSomeWorkflow2Options().WithStartWorkflowOptions(swo),
		).WithSomeUpdate1Options(
			v1.NewSomeUpdate1Options().WithUpdateWorkflowOptions(uwo),
		),
	)
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}

	// return early if detached
	if input.GetDetached() {
		return nil, nil
	}

	// initialize heartbeat interval duration
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatTimeout := activity.GetInfo(ctx).HeartbeatTimeout
		if heartbeatTimeout > 0 {
			heartbeatInterval = heartbeatTimeout / 2
		} else {
			heartbeatInterval = time.Second * 30
		}
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		defer close(doneCh)
		out, err = handle.Get(ctx)
	}()

	// heartbeat activity while waiting for update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())

		case <-activity.GetWorkerStopChannel(ctx):
			return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopping"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopping"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(ctx, time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, simpleOptions.convertError(err)
					}
				}
				return nil, simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		case <-doneCh:
			return out, simpleOptions.convertError(err)
		}
	}
}

// GetSomeWorkflow3 retrieves a(n) mycompany.simple.Simple.SomeWorkflow3 workflow via an activity
//
// Deprecated: Do not use.
func (a *simpleActivities) GetSomeWorkflow3(ctx context.Context, input *xnsv1.GetWorkflowRequest) (err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeWorkflow3WorkflowName)

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomeWorkflow3(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return simpleOptions.convertError(err)
					}
				}
				return simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow3 executes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow via an activity
//
// Deprecated: Do not use.
func (a *simpleActivities) SomeWorkflow3(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeWorkflow3WorkflowName)

	// unmarshal workflow request
	var req v1.SomeWorkflow3Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeWorkflow3Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeWorkflow3Run
	run, err = a.client.SomeWorkflow3Async(actx, &req, v1.NewSomeWorkflow3Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return simpleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return simpleOptions.convertError(err)
					}
				}
				return simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow3WithSomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow via an activity
//
// Deprecated: Do not use.
func (a *simpleActivities) SomeWorkflow3WithSomeSignal2(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeWorkflow3WorkflowName)

	// unmarshal workflow request
	var req v1.SomeWorkflow3Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeWorkflow3Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal signal request
	var signal v1.SomeSignal2Request
	if err := input.Signal.UnmarshalTo(&signal); err != nil {
		return simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeSignal2Request", input.Signal.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeWorkflow3Run
	run, err = a.client.SomeWorkflow3WithSomeSignal2Async(actx, &req, &signal, v1.NewSomeWorkflow3Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return simpleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return simpleOptions.convertError(err)
					}
				}
				return simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// GetSomeWorkflow4 retrieves a(n) mycompany.simple.Simple.SomeWorkflow4 workflow via an activity
func (a *simpleActivities) GetSomeWorkflow4(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v11.PaginatedResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomeWorkflow4(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, simpleOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, simpleOptions.convertError(err)
					}
				}
				return nil, simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, simpleOptions.convertError(err)
		}
	}
}

// SomeWorkflow4 executes a(n) mycompany.simple.Simple.SomeWorkflow4 workflow via an activity
func (a *simpleActivities) SomeWorkflow4(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v11.PaginatedResponse, err error) {
	// unmarshal workflow request
	var req v11.PaginatedRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/common/v1.PaginatedRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeWorkflow4Run
	run, err = a.client.SomeWorkflow4Async(actx, &req, v1.NewSomeWorkflow4Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, simpleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, simpleOptions.convertError(err)
					}
				}
				return nil, simpleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, simpleOptions.convertError(err)
		}
	}
}

// SomeQuery1 executes a(n) mycompany.simple.Simple.SomeQuery1 query via an activity
func (a *simpleActivities) SomeQuery1(ctx context.Context, input *xnsv1.QueryRequest) (resp *v1.SomeQuery1Response, err error) {
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.SomeQuery1(ctx, input.GetWorkflowId(), input.GetRunId())
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, simpleOptions.convertError(err)
		}
	}
}

// SomeQuery2 executes a(n) mycompany.simple.Simple.SomeQuery2 query via an activity
func (a *simpleActivities) SomeQuery2(ctx context.Context, input *xnsv1.QueryRequest) (resp *v1.SomeQuery2Response, err error) {
	// unmarshal query request
	var req v1.SomeQuery2Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling query request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeQuery2Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.SomeQuery2(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, simpleOptions.convertError(err)
		}
	}
}

// SomeSignal1 executes a(n) mycompany.simple.Simple.SomeSignal1 signal via an activity
func (a *simpleActivities) SomeSignal1(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeSignal1(ctx, input.GetWorkflowId(), input.GetRunId())
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeSignal2 executes a(n) mycompany.simple.Simple.SomeSignal2 signal via an activity
func (a *simpleActivities) SomeSignal2(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// unmarshal signal request
	var req v1.SomeSignal2Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeSignal2Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeSignal2(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeSignal3 executes a(n) mycompany.simple.Simple.SomeSignal3 signal via an activity
func (a *simpleActivities) SomeSignal3(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// unmarshal signal request
	var req v1.SomeSignal3Request
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeSignal3Request", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeSignal3(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return simpleOptions.convertError(err)
		}
	}
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update via an activity
func (a *simpleActivities) SomeUpdate1(ctx context.Context, input *xnsv1.UpdateRequest) (resp *v1.SomeUpdate1Response, err error) {
	var handle v1.SomeUpdate1Handle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, simpleOptions.convertError(err)
		}

		// retrieve handle for existing update
		handle, err = a.client.GetSomeUpdate1(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, simpleOptions.convertError(err)
		}
	} else {
		// unmarshal update request
		var req v1.SomeUpdate1Request
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeUpdate1Request", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			))
		}

		uo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())
		uo.WaitForStage = client.WorkflowUpdateStageAccepted

		// initialize update execution
		handle, err = a.client.SomeUpdate1Async(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			v1.NewSomeUpdate1Options().WithUpdateWorkflowOptions(uo),
		)
		if err != nil {
			return nil, simpleOptions.convertError(err)
		}
		activity.RecordHeartbeat(ctx, handle.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = handle.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())
		case <-ctx.Done():
			return nil, simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, simpleOptions.convertError(err)
		}
	}
}

// SomeUpdate2 executes a(n) mycompany.simple.Simple.SomeUpdate2 update via an activity
func (a *simpleActivities) SomeUpdate2(ctx context.Context, input *xnsv1.UpdateRequest) (resp *v1.SomeUpdate2Response, err error) {
	var handle v1.SomeUpdate2Handle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, simpleOptions.convertError(err)
		}

		// retrieve handle for existing update
		handle, err = a.client.GetSomeUpdate2(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, simpleOptions.convertError(err)
		}
	} else {
		// unmarshal update request
		var req v1.SomeUpdate2Request
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, simpleOptions.convertError(temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeUpdate2Request", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			))
		}

		uo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())
		uo.WaitForStage = client.WorkflowUpdateStageAccepted

		// initialize update execution
		handle, err = a.client.SomeUpdate2Async(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			v1.NewSomeUpdate2Options().WithUpdateWorkflowOptions(uo),
		)
		if err != nil {
			return nil, simpleOptions.convertError(err)
		}
		activity.RecordHeartbeat(ctx, handle.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = handle.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())
		case <-ctx.Done():
			return nil, simpleOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, simpleOptions.convertError(err)
		}
	}
}

// OtherOptions is used to configure mycompany.simple.Other xns activity registration
type OtherOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewOtherOptions initializes a new OtherOptions value
func NewOtherOptions() *OtherOptions {
	return &OtherOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *OtherOptions) WithErrorConverter(errorConverter func(error) error) *OtherOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *OtherOptions) WithFilter(filter func(string) string) *OtherOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *OtherOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *OtherOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// otherOptions is a reference to the OtherOptions initialized at registration
var otherOptions *OtherOptions

// RegisterOtherActivities registers mycompany.simple.Other cross-namespace activities
func RegisterOtherActivities(r worker.ActivityRegistry, c v1.OtherClient, options ...*OtherOptions) {
	if otherOptions == nil && len(options) > 0 && options[0] != nil {
		otherOptions = options[0]
	}
	a := &otherActivities{c}
	if name := otherOptions.filterActivity("mycompany.simple.Other.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity(v1.OtherWorkflowWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.OtherWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity("mycompany.simple.Other.GetOtherWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.GetOtherWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity(v1.OtherWorkflow2WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.OtherWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity("mycompany.simple.Other.GetOtherWorkflow2"); name != "" {
		r.RegisterActivityWithOptions(a.GetOtherWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity(v1.OtherQueryQueryName); name != "" {
		r.RegisterActivityWithOptions(a.OtherQuery, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity(v1.OtherSignalSignalName); name != "" {
		r.RegisterActivityWithOptions(a.OtherSignal, activity.RegisterOptions{Name: name})
	}
	if name := otherOptions.filterActivity(v1.OtherUpdateUpdateName); name != "" {
		r.RegisterActivityWithOptions(a.OtherUpdate, activity.RegisterOptions{Name: name})
	}
}

// OtherWorkflowWorkflowOptions are used to configure a(n) mycompany.simple.Other.OtherWorkflow workflow execution
type OtherWorkflowWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewOtherWorkflowWorkflowOptions initializes a new OtherWorkflowWorkflowOptions value
func NewOtherWorkflowWorkflowOptions() *OtherWorkflowWorkflowOptions {
	return &OtherWorkflowWorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *OtherWorkflowWorkflowOptions) Build(ctx workflow.Context, input *v1.OtherWorkflowRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.OtherWorkflowIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Other.OtherWorkflow\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherWorkflowWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherWorkflowWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *OtherWorkflowWorkflowOptions) WithDetached(d bool) *OtherWorkflowWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherWorkflowWorkflowOptions) WithHeartbeatInterval(d time.Duration) *OtherWorkflowWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *OtherWorkflowWorkflowOptions) WithHeartbeatTimeout(d time.Duration) *OtherWorkflowWorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *OtherWorkflowWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *OtherWorkflowWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *OtherWorkflowWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *OtherWorkflowWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// OtherWorkflowRun provides a handle to a mycompany.simple.Other.OtherWorkflow workflow execution
type OtherWorkflowRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.OtherWorkflowResponse, error)

	// ID returns the workflow id
	ID() string
}

// otherWorkflowRun provides a(n) OtherWorkflowRun implementation
type otherWorkflowRun struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *otherWorkflowRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelOtherWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *otherWorkflowRun) Future() workflow.Future {
	if r.future == nil {
		rr := GetOtherWorkflowAsync(r.ctx, r.id, "").(*otherWorkflowRun)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *otherWorkflowRun) Get(ctx workflow.Context) (*v1.OtherWorkflowResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetOtherWorkflowAsync(ctx, r.id, "", NewGetOtherWorkflowOptions().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*otherWorkflowRun)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.OtherWorkflowResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *otherWorkflowRun) ID() string {
	return r.id
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response is received
func OtherWorkflow(ctx workflow.Context, req *v1.OtherWorkflowRequest, opts ...*OtherWorkflowWorkflowOptions) (*v1.OtherWorkflowResponse, error) {
	run, err := OtherWorkflowAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflowAsync executes a(n) mycompany.simple.Other.OtherWorkflow workflow and returns a handle to the underlying activity
func OtherWorkflowAsync(ctx workflow.Context, input *v1.OtherWorkflowRequest, opts ...*OtherWorkflowWorkflowOptions) (OtherWorkflowRun, error) {
	activityName := otherOptions.filterActivity(v1.OtherWorkflowWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.OtherWorkflowWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *OtherWorkflowWorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewOtherWorkflowWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, otherOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &otherWorkflowRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetOtherWorkflow returns a(n) mycompany.simple.Other.OtherWorkflow workflow execution
func GetOtherWorkflow(ctx workflow.Context, workflowID string, runID string, options ...*GetOtherWorkflowOptions) (out *v1.OtherWorkflowResponse, err error) {
	out, err = GetOtherWorkflowAsync(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetOtherWorkflowAsync returns a handle to a(n) mycompany.simple.Other.OtherWorkflow workflow execution
func GetOtherWorkflowAsync(ctx workflow.Context, workflowID string, runID string, options ...*GetOtherWorkflowOptions) OtherWorkflowRun {
	activityName := otherOptions.filterActivity("mycompany.simple.Other.GetOtherWorkflow")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &otherWorkflowRun{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetOtherWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetOtherWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(otherOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &otherWorkflowRun{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &otherWorkflowRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetOtherWorkflowOptions are used to configure a(n) mycompany.simple.Other.OtherWorkflow workflow execution getter activity
type GetOtherWorkflowOptions struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetOtherWorkflowOptions initializes a new GetOtherWorkflowOptions value
func NewGetOtherWorkflowOptions() *GetOtherWorkflowOptions {
	return &GetOtherWorkflowOptions{}
}

// Build initializes the activity context and input
func (opt *GetOtherWorkflowOptions) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetOtherWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *GetOtherWorkflowOptions {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetOtherWorkflowOptions) WithHeartbeatInterval(d time.Duration) *GetOtherWorkflowOptions {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetOtherWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetOtherWorkflowOptions {
	o.parentClosePolicy = policy
	return o
}

// OtherWorkflow2WorkflowOptions are used to configure a(n) mycompany.simple.Other.OtherWorkflow2 workflow execution
type OtherWorkflow2WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewOtherWorkflow2WorkflowOptions initializes a new OtherWorkflow2WorkflowOptions value
func NewOtherWorkflow2WorkflowOptions() *OtherWorkflow2WorkflowOptions {
	return &OtherWorkflow2WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *OtherWorkflow2WorkflowOptions) Build(ctx workflow.Context, input *v11.PaginatedRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.OtherWorkflow2Idexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Other.OtherWorkflow2\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherWorkflow2WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherWorkflow2WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *OtherWorkflow2WorkflowOptions) WithDetached(d bool) *OtherWorkflow2WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherWorkflow2WorkflowOptions) WithHeartbeatInterval(d time.Duration) *OtherWorkflow2WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *OtherWorkflow2WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *OtherWorkflow2WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *OtherWorkflow2WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *OtherWorkflow2WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *OtherWorkflow2WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *OtherWorkflow2WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// OtherWorkflow2Run provides a handle to a mycompany.simple.Other.OtherWorkflow2 workflow execution
type OtherWorkflow2Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v11.PaginatedResponse, error)

	// ID returns the workflow id
	ID() string
}

// otherWorkflow2Run provides a(n) OtherWorkflow2Run implementation
type otherWorkflow2Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *otherWorkflow2Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelOtherWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *otherWorkflow2Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetOtherWorkflow2Async(r.ctx, r.id, "").(*otherWorkflow2Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *otherWorkflow2Run) Get(ctx workflow.Context) (*v11.PaginatedResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetOtherWorkflow2Async(ctx, r.id, "", NewGetOtherWorkflow2Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*otherWorkflow2Run)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v11.PaginatedResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *otherWorkflow2Run) ID() string {
	return r.id
}

// OtherWorkflow2 executes a(n) mycompany.simple.Other.OtherWorkflow2 workflow and blocks until error or response is received
func OtherWorkflow2(ctx workflow.Context, req *v11.PaginatedRequest, opts ...*OtherWorkflow2WorkflowOptions) (*v11.PaginatedResponse, error) {
	run, err := OtherWorkflow2Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflow2Async executes a(n) mycompany.simple.Other.OtherWorkflow2 workflow and returns a handle to the underlying activity
func OtherWorkflow2Async(ctx workflow.Context, input *v11.PaginatedRequest, opts ...*OtherWorkflow2WorkflowOptions) (OtherWorkflow2Run, error) {
	activityName := otherOptions.filterActivity(v1.OtherWorkflow2WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.OtherWorkflow2WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *OtherWorkflow2WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewOtherWorkflow2WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, otherOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &otherWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetOtherWorkflow2 returns a(n) mycompany.simple.Other.OtherWorkflow2 workflow execution
func GetOtherWorkflow2(ctx workflow.Context, workflowID string, runID string, options ...*GetOtherWorkflow2Options) (out *v11.PaginatedResponse, err error) {
	out, err = GetOtherWorkflow2Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetOtherWorkflow2Async returns a handle to a(n) mycompany.simple.Other.OtherWorkflow2 workflow execution
func GetOtherWorkflow2Async(ctx workflow.Context, workflowID string, runID string, options ...*GetOtherWorkflow2Options) OtherWorkflow2Run {
	activityName := otherOptions.filterActivity("mycompany.simple.Other.GetOtherWorkflow2")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &otherWorkflow2Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetOtherWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetOtherWorkflow2Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(otherOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &otherWorkflow2Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &otherWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetOtherWorkflow2Options are used to configure a(n) mycompany.simple.Other.OtherWorkflow2 workflow execution getter activity
type GetOtherWorkflow2Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetOtherWorkflow2Options initializes a new GetOtherWorkflow2Options value
func NewGetOtherWorkflow2Options() *GetOtherWorkflow2Options {
	return &GetOtherWorkflow2Options{}
}

// Build initializes the activity context and input
func (opt *GetOtherWorkflow2Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetOtherWorkflow2Options) WithActivityOptions(ao workflow.ActivityOptions) *GetOtherWorkflow2Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetOtherWorkflow2Options) WithHeartbeatInterval(d time.Duration) *GetOtherWorkflow2Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetOtherWorkflow2Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetOtherWorkflow2Options {
	o.parentClosePolicy = policy
	return o
}

// OtherQueryQueryOptions are used to configure a(n) mycompany.simple.Other.OtherQuery query execution
type OtherQueryQueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewOtherQueryQueryOptions initializes a new OtherQueryQueryOptions value
func NewOtherQueryQueryOptions() *OtherQueryQueryOptions {
	return &OtherQueryQueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherQueryQueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherQueryQueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherQueryQueryOptions) WithHeartbeatInterval(d time.Duration) *OtherQueryQueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// OtherQueryQueryHandle provides a handle for a mycompany.simple.Other.OtherQuery query activity
type OtherQueryQueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.OtherQueryResponse, error)
}

// otherQueryQueryHandle provides a(n) OtherQueryQueryHandle implementation
type otherQueryQueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *otherQueryQueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *otherQueryQueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *otherQueryQueryHandle) Get(ctx workflow.Context) (*v1.OtherQueryResponse, error) {
	var resp v1.OtherQueryResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// OtherQuery executes a(n) mycompany.simple.Other.OtherQuery query and blocks until error or response received
func OtherQuery(ctx workflow.Context, workflowID string, runID string, opts ...*OtherQueryQueryOptions) (*v1.OtherQueryResponse, error) {
	handle, err := OtherQueryAsync(ctx, workflowID, runID, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// OtherQueryAsync executes a(n) mycompany.simple.Other.OtherQuery query and returns a handle to the activity
func OtherQueryAsync(ctx workflow.Context, workflowID string, runID string, opts ...*OtherQueryQueryOptions) (OtherQueryQueryHandle, error) {
	activityName := otherOptions.filterActivity(v1.OtherQueryQueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.OtherQueryQueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &OtherQueryQueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	ctx, cancel := workflow.WithCancel(ctx)
	return &otherQueryQueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
		}),
	}, nil
}

// OtherSignalSignalOptions are used to configure a(n) mycompany.simple.Other.OtherSignal signal execution
type OtherSignalSignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewOtherSignalSignalOptions initializes a new OtherSignalSignalOptions value
func NewOtherSignalSignalOptions() *OtherSignalSignalOptions {
	return &OtherSignalSignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherSignalSignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherSignalSignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherSignalSignalOptions) WithHeartbeatInterval(d time.Duration) *OtherSignalSignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// OtherSignalSignalHandle provides a handle for a mycompany.simple.Other.OtherSignal signal activity
type OtherSignalSignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// otherSignalSignalHandle provides a(n) OtherSignalQueryHandle implementation
type otherSignalSignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *otherSignalSignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *otherSignalSignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *otherSignalSignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// OtherSignal executes a(n) mycompany.simple.Other.OtherSignal signal
func OtherSignal(ctx workflow.Context, workflowID string, runID string, req *v1.OtherSignalRequest, opts ...*OtherSignalSignalOptions) error {
	handle, err := OtherSignalAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// OtherSignalAsync executes a(n) mycompany.simple.Other.OtherSignal signal
func OtherSignalAsync(ctx workflow.Context, workflowID string, runID string, req *v1.OtherSignalRequest, opts ...*OtherSignalSignalOptions) (OtherSignalSignalHandle, error) {
	activityName := otherOptions.filterActivity(v1.OtherSignalSignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.OtherSignalSignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &OtherSignalSignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &otherSignalSignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// OtherUpdateUpdateOptions are used to configure a(n) mycompany.simple.Other.OtherUpdate update execution
type OtherUpdateUpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowOptions
}

// NewOtherUpdateUpdateOptions initializes a new OtherUpdateUpdateOptions value
func NewOtherUpdateUpdateOptions() *OtherUpdateUpdateOptions {
	return &OtherUpdateUpdateOptions{}
}

// Build initializes the update options
func (opt *OtherUpdateUpdateOptions) Build(ctx workflow.Context, workflowID string, runID string, input *v1.OtherUpdateRequest) (workflow.Context, *xnsv1.UpdateRequest, error) {
	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowOptions{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.OtherUpdateIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Other.OtherUpdate\" update", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	inpb, err := anypb.New(input)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	return ctx, &xnsv1.UpdateRequest{
		HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
		Request:               inpb,
		UpdateWorkflowOptions: uopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *OtherUpdateUpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *OtherUpdateUpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *OtherUpdateUpdateOptions) WithHeartbeatInterval(d time.Duration) *OtherUpdateUpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *OtherUpdateUpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowOptions) *OtherUpdateUpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// OtherUpdateHandle provides a handle to a mycompany.simple.Other.OtherUpdate workflow update
type OtherUpdateHandle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*v1.OtherUpdateResponse, error)

	// ID returns the update id
	ID() string
}

// otherUpdateHandle provides a(n) OtherUpdateHandle implementation
type otherUpdateHandle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *otherUpdateHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *otherUpdateHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *otherUpdateHandle) Get(ctx workflow.Context) (*v1.OtherUpdateResponse, error) {
	var resp v1.OtherUpdateResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *otherUpdateHandle) ID() string {
	return r.id
}

// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until error or response received
func OtherUpdate(ctx workflow.Context, workflowID string, runID string, req *v1.OtherUpdateRequest, opts ...*OtherUpdateUpdateOptions) (*v1.OtherUpdateResponse, error) {
	run, err := OtherUpdateAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherUpdateAsync executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until error or response received
func OtherUpdateAsync(ctx workflow.Context, workflowID string, runID string, input *v1.OtherUpdateRequest, opts ...*OtherUpdateUpdateOptions) (OtherUpdateHandle, error) {
	activityName := otherOptions.filterActivity(v1.OtherUpdateUpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.OtherUpdateUpdateName),
			"Unimplemented",
			nil,
		)
	}

	var opt *OtherUpdateUpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewOtherUpdateUpdateOptions()
	}

	ctx, req, err := opt.Build(ctx, workflowID, runID, input)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &otherUpdateHandle{
		cancel: cancel,
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
		future: workflow.ExecuteActivity(ctx, activityName, req),
	}, nil
}

// CancelOtherWorkflow cancels an existing workflow
func CancelOtherWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelOtherWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelOtherWorkflowAsync cancels an existing workflow
func CancelOtherWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := otherOptions.filterActivity("mycompany.simple.Other.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Other.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// otherActivities provides activities that can be used to interact with a(n) Other service's workflow, queries, signals, and updates across namespaces
type otherActivities struct {
	client v1.OtherClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *otherActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// GetOtherWorkflow retrieves a(n) mycompany.simple.Other.OtherWorkflow workflow via an activity
func (a *otherActivities) GetOtherWorkflow(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.OtherWorkflowResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetOtherWorkflow(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, otherOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, otherOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, otherOptions.convertError(err)
					}
				}
				return nil, otherOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, otherOptions.convertError(err)
		}
	}
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow via an activity
func (a *otherActivities) OtherWorkflow(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.OtherWorkflowResponse, err error) {
	// unmarshal workflow request
	var req v1.OtherWorkflowRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, otherOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.OtherWorkflowRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.OtherWorkflowRun
	run, err = a.client.OtherWorkflowAsync(actx, &req, v1.NewOtherWorkflowOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, otherOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, otherOptions.convertError(err)
					}
				}
				return nil, otherOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, otherOptions.convertError(err)
		}
	}
}

// GetOtherWorkflow2 retrieves a(n) mycompany.simple.Other.OtherWorkflow2 workflow via an activity
func (a *otherActivities) GetOtherWorkflow2(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v11.PaginatedResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetOtherWorkflow2(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, otherOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, otherOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, otherOptions.convertError(err)
					}
				}
				return nil, otherOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, otherOptions.convertError(err)
		}
	}
}

// OtherWorkflow2 executes a(n) mycompany.simple.Other.OtherWorkflow2 workflow via an activity
func (a *otherActivities) OtherWorkflow2(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v11.PaginatedResponse, err error) {
	// unmarshal workflow request
	var req v11.PaginatedRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, otherOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/common/v1.PaginatedRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.OtherWorkflow2Run
	run, err = a.client.OtherWorkflow2Async(actx, &req, v1.NewOtherWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, otherOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, otherOptions.convertError(err)
					}
				}
				return nil, otherOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, otherOptions.convertError(err)
		}
	}
}

// OtherQuery executes a(n) mycompany.simple.Other.OtherQuery query via an activity
func (a *otherActivities) OtherQuery(ctx context.Context, input *xnsv1.QueryRequest) (resp *v1.OtherQueryResponse, err error) {
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.OtherQuery(ctx, input.GetWorkflowId(), input.GetRunId())
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, otherOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, otherOptions.convertError(err)
		}
	}
}

// OtherSignal executes a(n) mycompany.simple.Other.OtherSignal signal via an activity
func (a *otherActivities) OtherSignal(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// unmarshal signal request
	var req v1.OtherSignalRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return otherOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.OtherSignalRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.OtherSignal(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			otherOptions.convertError(ctx.Err())
		case <-doneCh:
			return otherOptions.convertError(err)
		}
	}
}

// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update via an activity
func (a *otherActivities) OtherUpdate(ctx context.Context, input *xnsv1.UpdateRequest) (resp *v1.OtherUpdateResponse, err error) {
	var handle v1.OtherUpdateHandle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, otherOptions.convertError(err)
		}

		// retrieve handle for existing update
		handle, err = a.client.GetOtherUpdate(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, otherOptions.convertError(err)
		}
	} else {
		// unmarshal update request
		var req v1.OtherUpdateRequest
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, otherOptions.convertError(temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.OtherUpdateRequest", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			))
		}

		uo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())
		uo.WaitForStage = client.WorkflowUpdateStageAccepted

		// initialize update execution
		handle, err = a.client.OtherUpdateAsync(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			v1.NewOtherUpdateOptions().WithUpdateWorkflowOptions(uo),
		)
		if err != nil {
			return nil, otherOptions.convertError(err)
		}
		activity.RecordHeartbeat(ctx, handle.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = handle.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())
		case <-ctx.Done():
			return nil, otherOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, otherOptions.convertError(err)
		}
	}
}

// IgnoredOptions is used to configure mycompany.simple.Ignored xns activity registration
type IgnoredOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewIgnoredOptions initializes a new IgnoredOptions value
func NewIgnoredOptions() *IgnoredOptions {
	return &IgnoredOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *IgnoredOptions) WithErrorConverter(errorConverter func(error) error) *IgnoredOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *IgnoredOptions) WithFilter(filter func(string) string) *IgnoredOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *IgnoredOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *IgnoredOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// ignoredOptions is a reference to the IgnoredOptions initialized at registration
var ignoredOptions *IgnoredOptions

// RegisterIgnoredActivities registers mycompany.simple.Ignored cross-namespace activities
func RegisterIgnoredActivities(r worker.ActivityRegistry, c v1.IgnoredClient, options ...*IgnoredOptions) {
	if ignoredOptions == nil && len(options) > 0 && options[0] != nil {
		ignoredOptions = options[0]
	}
	a := &ignoredActivities{c}
	if name := ignoredOptions.filterActivity("mycompany.simple.Ignored.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := ignoredOptions.filterActivity(v1.WhatWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.What, activity.RegisterOptions{Name: name})
	}
	if name := ignoredOptions.filterActivity("mycompany.simple.Ignored.GetWhat"); name != "" {
		r.RegisterActivityWithOptions(a.GetWhat, activity.RegisterOptions{Name: name})
	}
}

// WhatWorkflowOptions are used to configure a(n) mycompany.simple.Ignored.What workflow execution
type WhatWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewWhatWorkflowOptions initializes a new WhatWorkflowOptions value
func NewWhatWorkflowOptions() *WhatWorkflowOptions {
	return &WhatWorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *WhatWorkflowOptions) Build(ctx workflow.Context, input *v1.WhatRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.WhatIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"mycompany.simple.Ignored.What\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *WhatWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *WhatWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *WhatWorkflowOptions) WithDetached(d bool) *WhatWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *WhatWorkflowOptions) WithHeartbeatInterval(d time.Duration) *WhatWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *WhatWorkflowOptions) WithHeartbeatTimeout(d time.Duration) *WhatWorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *WhatWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *WhatWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *WhatWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *WhatWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// WhatRun provides a handle to a mycompany.simple.Ignored.What workflow execution
type WhatRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) error

	// ID returns the workflow id
	ID() string
}

// whatRun provides a(n) WhatRun implementation
type whatRun struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *whatRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelIgnoredWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *whatRun) Future() workflow.Future {
	if r.future == nil {
		rr := GetWhatAsync(r.ctx, r.id, "").(*whatRun)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *whatRun) Get(ctx workflow.Context) error {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetWhatAsync(ctx, r.id, "", NewGetWhatOptions().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*whatRun)
		r.future = rr.future
		r.cancel = cancel
	}
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *whatRun) ID() string {
	return r.id
}

// What executes a(n) mycompany.simple.Ignored.What workflow and blocks until error or response is received
func What(ctx workflow.Context, req *v1.WhatRequest, opts ...*WhatWorkflowOptions) error {
	run, err := WhatAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// WhatAsync executes a(n) mycompany.simple.Ignored.What workflow and returns a handle to the underlying activity
func WhatAsync(ctx workflow.Context, input *v1.WhatRequest, opts ...*WhatWorkflowOptions) (WhatRun, error) {
	activityName := ignoredOptions.filterActivity(v1.WhatWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.WhatWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *WhatWorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewWhatWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, ignoredOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &whatRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetWhat returns a(n) mycompany.simple.Ignored.What workflow execution
func GetWhat(ctx workflow.Context, workflowID string, runID string, options ...*GetWhatOptions) (err error) {
	err = GetWhatAsync(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return err
	}
	return nil
}

// GetWhatAsync returns a handle to a(n) mycompany.simple.Ignored.What workflow execution
func GetWhatAsync(ctx workflow.Context, workflowID string, runID string, options ...*GetWhatOptions) WhatRun {
	activityName := ignoredOptions.filterActivity("mycompany.simple.Ignored.GetWhat")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &whatRun{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetWhatOptions
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetWhatOptions()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(ignoredOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &whatRun{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &whatRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetWhatOptions are used to configure a(n) mycompany.simple.Ignored.What workflow execution getter activity
type GetWhatOptions struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetWhatOptions initializes a new GetWhatOptions value
func NewGetWhatOptions() *GetWhatOptions {
	return &GetWhatOptions{}
}

// Build initializes the activity context and input
func (opt *GetWhatOptions) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetWhatOptions) WithActivityOptions(ao workflow.ActivityOptions) *GetWhatOptions {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetWhatOptions) WithHeartbeatInterval(d time.Duration) *GetWhatOptions {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetWhatOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetWhatOptions {
	o.parentClosePolicy = policy
	return o
}

// CancelIgnoredWorkflow cancels an existing workflow
func CancelIgnoredWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelIgnoredWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelIgnoredWorkflowAsync cancels an existing workflow
func CancelIgnoredWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := ignoredOptions.filterActivity("mycompany.simple.Ignored.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Ignored.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// ignoredActivities provides activities that can be used to interact with a(n) Ignored service's workflow, queries, signals, and updates across namespaces
type ignoredActivities struct {
	client v1.IgnoredClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *ignoredActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// GetWhat retrieves a(n) mycompany.simple.Ignored.What workflow via an activity
func (a *ignoredActivities) GetWhat(ctx context.Context, input *xnsv1.GetWorkflowRequest) (err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetWhat(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return ignoredOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return ignoredOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return ignoredOptions.convertError(err)
					}
				}
				return ignoredOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return ignoredOptions.convertError(err)
		}
	}
}

// What executes a(n) mycompany.simple.Ignored.What workflow via an activity
func (a *ignoredActivities) What(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req v1.WhatRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return ignoredOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.WhatRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.WhatRun
	run, err = a.client.WhatAsync(actx, &req, v1.NewWhatOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return ignoredOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return ignoredOptions.convertError(err)
					}
				}
				return ignoredOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return ignoredOptions.convertError(err)
		}
	}
}

// DeprecatedOptions is used to configure mycompany.simple.Deprecated xns activity registration
type DeprecatedOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewDeprecatedOptions initializes a new DeprecatedOptions value
func NewDeprecatedOptions() *DeprecatedOptions {
	return &DeprecatedOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *DeprecatedOptions) WithErrorConverter(errorConverter func(error) error) *DeprecatedOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *DeprecatedOptions) WithFilter(filter func(string) string) *DeprecatedOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *DeprecatedOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *DeprecatedOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// deprecatedOptions is a reference to the DeprecatedOptions initialized at registration
var deprecatedOptions *DeprecatedOptions

// RegisterDeprecatedActivities registers mycompany.simple.Deprecated cross-namespace activities
func RegisterDeprecatedActivities(r worker.ActivityRegistry, c v1.DeprecatedClient, options ...*DeprecatedOptions) {
	if deprecatedOptions == nil && len(options) > 0 && options[0] != nil {
		deprecatedOptions = options[0]
	}
	a := &deprecatedActivities{c}
	if name := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedWorkflow1WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedWorkflow1, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.GetSomeDeprecatedWorkflow1"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomeDeprecatedWorkflow1, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1"); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedWorkflow2WorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.GetSomeDeprecatedWorkflow2"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomeDeprecatedWorkflow2, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2"); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedQuery1QueryName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedQuery1, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedQuery2QueryName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedQuery2, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedSignal1SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedSignal1, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedSignal2SignalName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedSignal2, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedUpdate1UpdateName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedUpdate1, activity.RegisterOptions{Name: name})
	}
	if name := deprecatedOptions.filterActivity(v1.SomeDeprecatedUpdate2UpdateName); name != "" {
		r.RegisterActivityWithOptions(a.SomeDeprecatedUpdate2, activity.RegisterOptions{Name: name})
	}
}

// SomeDeprecatedWorkflow1WorkflowOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow execution
type SomeDeprecatedWorkflow1WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeDeprecatedWorkflow1WorkflowOptions initializes a new SomeDeprecatedWorkflow1WorkflowOptions value
func NewSomeDeprecatedWorkflow1WorkflowOptions() *SomeDeprecatedWorkflow1WorkflowOptions {
	return &SomeDeprecatedWorkflow1WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) Build(ctx workflow.Context, input *v1.SomeDeprecatedMessage) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedWorkflow1WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) WithDetached(d bool) *SomeDeprecatedWorkflow1WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedWorkflow1WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomeDeprecatedWorkflow1WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeDeprecatedWorkflow1WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeDeprecatedWorkflow1WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeDeprecatedWorkflow1WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeDeprecatedWorkflow1Run provides a handle to a mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow execution
type SomeDeprecatedWorkflow1Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeDeprecatedMessage, error)

	// ID returns the workflow id
	ID() string

	// SomeDeprecatedQuery1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedQuery1(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedQuery1QueryOptions) (*v1.SomeDeprecatedMessage, error)

	// SomeDeprecatedQuery1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedQuery1Async(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedQuery1QueryOptions) (SomeDeprecatedQuery1QueryHandle, error)

	// SomeDeprecatedSignal1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedSignal1(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedSignal1SignalOptions) error

	// SomeDeprecatedSignal1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedSignal1Async(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedSignal1SignalOptions) (SomeDeprecatedSignal1SignalHandle, error)

	// SomeDeprecatedUpdate1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedUpdate1UpdateOptions) (*v1.SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1Async(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedUpdate1UpdateOptions) (SomeDeprecatedUpdate1Handle, error)
}

// someDeprecatedWorkflow1Run provides a(n) SomeDeprecatedWorkflow1Run implementation
type someDeprecatedWorkflow1Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *someDeprecatedWorkflow1Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelDeprecatedWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someDeprecatedWorkflow1Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomeDeprecatedWorkflow1Async(r.ctx, r.id, "").(*someDeprecatedWorkflow1Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someDeprecatedWorkflow1Run) Get(ctx workflow.Context) (*v1.SomeDeprecatedMessage, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomeDeprecatedWorkflow1Async(ctx, r.id, "", NewGetSomeDeprecatedWorkflow1Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*someDeprecatedWorkflow1Run)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.SomeDeprecatedMessage
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someDeprecatedWorkflow1Run) ID() string {
	return r.id
}

// SomeDeprecatedQuery1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedQuery1(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery1QueryOptions) (*v1.SomeDeprecatedMessage, error) {
	return SomeDeprecatedQuery1(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedQuery1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedQuery1Async(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery1QueryOptions) (SomeDeprecatedQuery1QueryHandle, error) {
	return SomeDeprecatedQuery1Async(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedSignal1(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal1SignalOptions) error {
	return SomeDeprecatedSignal1(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedSignal1Async(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal1SignalOptions) (SomeDeprecatedSignal1SignalHandle, error) {
	return SomeDeprecatedSignal1Async(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedUpdate1(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1UpdateOptions) (*v1.SomeDeprecatedMessage, error) {
	return SomeDeprecatedUpdate1(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedUpdate1Async(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1UpdateOptions) (SomeDeprecatedUpdate1Handle, error) {
	return SomeDeprecatedUpdate1Async(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow1(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1WorkflowOptions) (*v1.SomeDeprecatedMessage, error) {
	run, err := SomeDeprecatedWorkflow1Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow1Async(ctx workflow.Context, input *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1WorkflowOptions) (SomeDeprecatedWorkflow1Run, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow1WorkflowName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedWorkflow1WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedWorkflow1WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeDeprecatedWorkflow1WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeDeprecatedWorkflow1WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, deprecatedOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedWorkflow1Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomeDeprecatedWorkflow1 returns a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow execution
//
// Deprecated: Do not use.
func GetSomeDeprecatedWorkflow1(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeDeprecatedWorkflow1Options) (out *v1.SomeDeprecatedMessage, err error) {
	out, err = GetSomeDeprecatedWorkflow1Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetSomeDeprecatedWorkflow1Async returns a handle to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow execution
//
// Deprecated: Do not use.
func GetSomeDeprecatedWorkflow1Async(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeDeprecatedWorkflow1Options) SomeDeprecatedWorkflow1Run {
	activityName := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.GetSomeDeprecatedWorkflow1")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &someDeprecatedWorkflow1Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomeDeprecatedWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomeDeprecatedWorkflow1Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &someDeprecatedWorkflow1Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedWorkflow1Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomeDeprecatedWorkflow1Options are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow execution getter activity
//
// Deprecated: Do not use.
type GetSomeDeprecatedWorkflow1Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomeDeprecatedWorkflow1Options initializes a new GetSomeDeprecatedWorkflow1Options value
//
// Deprecated: Do not use.
func NewGetSomeDeprecatedWorkflow1Options() *GetSomeDeprecatedWorkflow1Options {
	return &GetSomeDeprecatedWorkflow1Options{}
}

// Build initializes the activity context and input
func (opt *GetSomeDeprecatedWorkflow1Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomeDeprecatedWorkflow1Options) WithActivityOptions(ao workflow.ActivityOptions) *GetSomeDeprecatedWorkflow1Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomeDeprecatedWorkflow1Options) WithHeartbeatInterval(d time.Duration) *GetSomeDeprecatedWorkflow1Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomeDeprecatedWorkflow1Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomeDeprecatedWorkflow1Options {
	o.parentClosePolicy = policy
	return o
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1 activity
type SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options initializes a new SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options value
func NewSomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options() *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	return &SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options{}
}

// Build initializes the activity context and input
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) Build(ctx workflow.Context, input *v1.SomeDeprecatedMessage, signal *v1.SomeDeprecatedMessage) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal signal request protobuf message
	signalpb, err := anypb.New(signal)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling signal request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		Signal:               signalpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) WithDetached(d bool) *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) WithHeartbeatTimeout(d time.Duration) *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1(ctx workflow.Context, input *v1.SomeDeprecatedMessage, signal *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) (*v1.SomeDeprecatedMessage, error) {
	run, err := SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(ctx, input, signal, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1 activity and returns a handle to the activity
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(ctx workflow.Context, input *v1.SomeDeprecatedMessage, signal *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options) (SomeDeprecatedWorkflow1Run, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow1WorkflowName)
	workflow.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal1SignalName)

	activityName := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "mycompany.simple.Deprecated.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1"),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Options()
	}
	ctx, req, err := opt.Build(ctx, input, signal)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedWorkflow1Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// SomeDeprecatedWorkflow2WorkflowOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow execution
type SomeDeprecatedWorkflow2WorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeDeprecatedWorkflow2WorkflowOptions initializes a new SomeDeprecatedWorkflow2WorkflowOptions value
func NewSomeDeprecatedWorkflow2WorkflowOptions() *SomeDeprecatedWorkflow2WorkflowOptions {
	return &SomeDeprecatedWorkflow2WorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) Build(ctx workflow.Context, input *v1.SomeDeprecatedMessage) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedWorkflow2WorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) WithDetached(d bool) *SomeDeprecatedWorkflow2WorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedWorkflow2WorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomeDeprecatedWorkflow2WorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeDeprecatedWorkflow2WorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeDeprecatedWorkflow2WorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeDeprecatedWorkflow2WorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeDeprecatedWorkflow2Run provides a handle to a mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow execution
type SomeDeprecatedWorkflow2Run interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeDeprecatedMessage, error)

	// ID returns the workflow id
	ID() string

	// SomeDeprecatedQuery2 does something else
	//
	// Deprecated: a custom query deprecation message.
	SomeDeprecatedQuery2(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedQuery2QueryOptions) (*v1.SomeDeprecatedMessage, error)

	// SomeDeprecatedQuery2 does something else
	//
	// Deprecated: a custom query deprecation message.
	SomeDeprecatedQuery2Async(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedQuery2QueryOptions) (SomeDeprecatedQuery2QueryHandle, error)

	// SomeDeprecatedSignal2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedSignal2(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedSignal2SignalOptions) error

	// SomeDeprecatedSignal2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedSignal2Async(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedSignal2SignalOptions) (SomeDeprecatedSignal2SignalHandle, error)

	// SomeDeprecatedUpdate2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedUpdate2(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedUpdate2UpdateOptions) (*v1.SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedUpdate2Async(workflow.Context, *v1.SomeDeprecatedMessage, ...*SomeDeprecatedUpdate2UpdateOptions) (SomeDeprecatedUpdate2Handle, error)
}

// someDeprecatedWorkflow2Run provides a(n) SomeDeprecatedWorkflow2Run implementation
type someDeprecatedWorkflow2Run struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *someDeprecatedWorkflow2Run) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelDeprecatedWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *someDeprecatedWorkflow2Run) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomeDeprecatedWorkflow2Async(r.ctx, r.id, "").(*someDeprecatedWorkflow2Run)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *someDeprecatedWorkflow2Run) Get(ctx workflow.Context) (*v1.SomeDeprecatedMessage, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomeDeprecatedWorkflow2Async(ctx, r.id, "", NewGetSomeDeprecatedWorkflow2Options().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*someDeprecatedWorkflow2Run)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.SomeDeprecatedMessage
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someDeprecatedWorkflow2Run) ID() string {
	return r.id
}

// SomeDeprecatedQuery2 does something else
//
// Deprecated: a custom query deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedQuery2(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery2QueryOptions) (*v1.SomeDeprecatedMessage, error) {
	return SomeDeprecatedQuery2(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedQuery2 does something else
//
// Deprecated: a custom query deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedQuery2Async(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery2QueryOptions) (SomeDeprecatedQuery2QueryHandle, error) {
	return SomeDeprecatedQuery2Async(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedSignal2(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal2SignalOptions) error {
	return SomeDeprecatedSignal2(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedSignal2Async(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal2SignalOptions) (SomeDeprecatedSignal2SignalHandle, error) {
	return SomeDeprecatedSignal2Async(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedUpdate2(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2UpdateOptions) (*v1.SomeDeprecatedMessage, error) {
	return SomeDeprecatedUpdate2(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedUpdate2Async(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2UpdateOptions) (SomeDeprecatedUpdate2Handle, error) {
	return SomeDeprecatedUpdate2Async(ctx, r.ID(), "", req, opts...)
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func SomeDeprecatedWorkflow2(ctx workflow.Context, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2WorkflowOptions) (*v1.SomeDeprecatedMessage, error) {
	run, err := SomeDeprecatedWorkflow2Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func SomeDeprecatedWorkflow2Async(ctx workflow.Context, input *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2WorkflowOptions) (SomeDeprecatedWorkflow2Run, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow2WorkflowName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedWorkflow2WorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedWorkflow2WorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeDeprecatedWorkflow2WorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeDeprecatedWorkflow2WorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, deprecatedOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomeDeprecatedWorkflow2 returns a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow execution
//
// Deprecated: Do not use.
func GetSomeDeprecatedWorkflow2(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeDeprecatedWorkflow2Options) (out *v1.SomeDeprecatedMessage, err error) {
	out, err = GetSomeDeprecatedWorkflow2Async(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetSomeDeprecatedWorkflow2Async returns a handle to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow execution
//
// Deprecated: Do not use.
func GetSomeDeprecatedWorkflow2Async(ctx workflow.Context, workflowID string, runID string, options ...*GetSomeDeprecatedWorkflow2Options) SomeDeprecatedWorkflow2Run {
	activityName := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.GetSomeDeprecatedWorkflow2")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &someDeprecatedWorkflow2Run{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomeDeprecatedWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomeDeprecatedWorkflow2Options()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &someDeprecatedWorkflow2Run{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomeDeprecatedWorkflow2Options are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow execution getter activity
//
// Deprecated: Do not use.
type GetSomeDeprecatedWorkflow2Options struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomeDeprecatedWorkflow2Options initializes a new GetSomeDeprecatedWorkflow2Options value
//
// Deprecated: Do not use.
func NewGetSomeDeprecatedWorkflow2Options() *GetSomeDeprecatedWorkflow2Options {
	return &GetSomeDeprecatedWorkflow2Options{}
}

// Build initializes the activity context and input
func (opt *GetSomeDeprecatedWorkflow2Options) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomeDeprecatedWorkflow2Options) WithActivityOptions(ao workflow.ActivityOptions) *GetSomeDeprecatedWorkflow2Options {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomeDeprecatedWorkflow2Options) WithHeartbeatInterval(d time.Duration) *GetSomeDeprecatedWorkflow2Options {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomeDeprecatedWorkflow2Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomeDeprecatedWorkflow2Options {
	o.parentClosePolicy = policy
	return o
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2 activity
type SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options initializes a new SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options value
func NewSomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options() *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	return &SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options{}
}

// Build initializes the activity context and input
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) Build(ctx workflow.Context, input *v1.SomeDeprecatedMessage, signal *v1.SomeDeprecatedMessage) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal signal request protobuf message
	signalpb, err := anypb.New(signal)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling signal request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		Signal:               signalpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) WithDetached(d bool) *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) WithHeartbeatTimeout(d time.Duration) *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) WithStartWorkflow(swo client.StartWorkflowOptions) *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2(ctx workflow.Context, input *v1.SomeDeprecatedMessage, signal *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) (*v1.SomeDeprecatedMessage, error) {
	run, err := SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(ctx, input, signal, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2 activity and returns a handle to the activity
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(ctx workflow.Context, input *v1.SomeDeprecatedMessage, signal *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options) (SomeDeprecatedWorkflow2Run, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow2WorkflowName)
	workflow.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal2SignalName)

	activityName := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "mycompany.simple.Deprecated.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2"),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Options()
	}
	ctx, req, err := opt.Build(ctx, input, signal)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedWorkflow2Run{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// SomeDeprecatedQuery1QueryOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedQuery1 query execution
type SomeDeprecatedQuery1QueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeDeprecatedQuery1QueryOptions initializes a new SomeDeprecatedQuery1QueryOptions value
func NewSomeDeprecatedQuery1QueryOptions() *SomeDeprecatedQuery1QueryOptions {
	return &SomeDeprecatedQuery1QueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedQuery1QueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedQuery1QueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedQuery1QueryOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedQuery1QueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeDeprecatedQuery1QueryHandle provides a handle for a mycompany.simple.Deprecated.SomeDeprecatedQuery1 query activity
type SomeDeprecatedQuery1QueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeDeprecatedMessage, error)
}

// someDeprecatedQuery1QueryHandle provides a(n) SomeDeprecatedQuery1QueryHandle implementation
type someDeprecatedQuery1QueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *someDeprecatedQuery1QueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someDeprecatedQuery1QueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *someDeprecatedQuery1QueryHandle) Get(ctx workflow.Context) (*v1.SomeDeprecatedMessage, error) {
	var resp v1.SomeDeprecatedMessage
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeDeprecatedQuery1 does something else
//
// Deprecated: Do not use.
func SomeDeprecatedQuery1(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery1QueryOptions) (*v1.SomeDeprecatedMessage, error) {
	handle, err := SomeDeprecatedQuery1Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeDeprecatedQuery1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedQuery1 query and returns a handle to the activity
//
// Deprecated: Do not use.
func SomeDeprecatedQuery1Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery1QueryOptions) (SomeDeprecatedQuery1QueryHandle, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated query detected", "query", v1.SomeDeprecatedQuery1QueryName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedQuery1QueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedQuery1QueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeDeprecatedQuery1QueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedQuery1QueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeDeprecatedQuery2QueryOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedQuery2 query execution
type SomeDeprecatedQuery2QueryOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeDeprecatedQuery2QueryOptions initializes a new SomeDeprecatedQuery2QueryOptions value
func NewSomeDeprecatedQuery2QueryOptions() *SomeDeprecatedQuery2QueryOptions {
	return &SomeDeprecatedQuery2QueryOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedQuery2QueryOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedQuery2QueryOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedQuery2QueryOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedQuery2QueryOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeDeprecatedQuery2QueryHandle provides a handle for a mycompany.simple.Deprecated.SomeDeprecatedQuery2 query activity
type SomeDeprecatedQuery2QueryHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomeDeprecatedMessage, error)
}

// someDeprecatedQuery2QueryHandle provides a(n) SomeDeprecatedQuery2QueryHandle implementation
type someDeprecatedQuery2QueryHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying query activity
func (r *someDeprecatedQuery2QueryHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someDeprecatedQuery2QueryHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying query result
func (r *someDeprecatedQuery2QueryHandle) Get(ctx workflow.Context) (*v1.SomeDeprecatedMessage, error) {
	var resp v1.SomeDeprecatedMessage
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeDeprecatedQuery2 does something else
//
// Deprecated: a custom query deprecation message.
func SomeDeprecatedQuery2(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery2QueryOptions) (*v1.SomeDeprecatedMessage, error) {
	handle, err := SomeDeprecatedQuery2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeDeprecatedQuery2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedQuery2 query and returns a handle to the activity
//
// Deprecated: Do not use.
func SomeDeprecatedQuery2Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedQuery2QueryOptions) (SomeDeprecatedQuery2QueryHandle, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated query detected", "query", v1.SomeDeprecatedQuery2QueryName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedQuery2QueryName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedQuery2QueryName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeDeprecatedQuery2QueryOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedQuery2QueryHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.QueryRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeDeprecatedSignal1SignalOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal execution
type SomeDeprecatedSignal1SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeDeprecatedSignal1SignalOptions initializes a new SomeDeprecatedSignal1SignalOptions value
func NewSomeDeprecatedSignal1SignalOptions() *SomeDeprecatedSignal1SignalOptions {
	return &SomeDeprecatedSignal1SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedSignal1SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedSignal1SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedSignal1SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedSignal1SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeDeprecatedSignal1SignalHandle provides a handle for a mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal activity
type SomeDeprecatedSignal1SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someDeprecatedSignal1SignalHandle provides a(n) SomeDeprecatedSignal1QueryHandle implementation
type someDeprecatedSignal1SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someDeprecatedSignal1SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someDeprecatedSignal1SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someDeprecatedSignal1SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func SomeDeprecatedSignal1(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal1SignalOptions) error {
	handle, err := SomeDeprecatedSignal1Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeDeprecatedSignal1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal
//
// Deprecated: Do not use.
func SomeDeprecatedSignal1Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal1SignalOptions) (SomeDeprecatedSignal1SignalHandle, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal1SignalName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedSignal1SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedSignal1SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeDeprecatedSignal1SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedSignal1SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeDeprecatedSignal2SignalOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal execution
type SomeDeprecatedSignal2SignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewSomeDeprecatedSignal2SignalOptions initializes a new SomeDeprecatedSignal2SignalOptions value
func NewSomeDeprecatedSignal2SignalOptions() *SomeDeprecatedSignal2SignalOptions {
	return &SomeDeprecatedSignal2SignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedSignal2SignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedSignal2SignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedSignal2SignalOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedSignal2SignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// SomeDeprecatedSignal2SignalHandle provides a handle for a mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal activity
type SomeDeprecatedSignal2SignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// someDeprecatedSignal2SignalHandle provides a(n) SomeDeprecatedSignal2QueryHandle implementation
type someDeprecatedSignal2SignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *someDeprecatedSignal2SignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someDeprecatedSignal2SignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *someDeprecatedSignal2SignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func SomeDeprecatedSignal2(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal2SignalOptions) error {
	handle, err := SomeDeprecatedSignal2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// SomeDeprecatedSignal2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal
//
// Deprecated: Do not use.
func SomeDeprecatedSignal2Async(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedSignal2SignalOptions) (SomeDeprecatedSignal2SignalHandle, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal2SignalName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedSignal2SignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedSignal2SignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SomeDeprecatedSignal2SignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedSignal2SignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// SomeDeprecatedUpdate1UpdateOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update execution
type SomeDeprecatedUpdate1UpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowOptions
}

// NewSomeDeprecatedUpdate1UpdateOptions initializes a new SomeDeprecatedUpdate1UpdateOptions value
func NewSomeDeprecatedUpdate1UpdateOptions() *SomeDeprecatedUpdate1UpdateOptions {
	return &SomeDeprecatedUpdate1UpdateOptions{}
}

// Build initializes the update options
func (opt *SomeDeprecatedUpdate1UpdateOptions) Build(ctx workflow.Context, workflowID string, runID string, input *v1.SomeDeprecatedMessage) (workflow.Context, *xnsv1.UpdateRequest, error) {
	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowOptions{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	inpb, err := anypb.New(input)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	return ctx, &xnsv1.UpdateRequest{
		HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
		Request:               inpb,
		UpdateWorkflowOptions: uopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedUpdate1UpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedUpdate1UpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedUpdate1UpdateOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedUpdate1UpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *SomeDeprecatedUpdate1UpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowOptions) *SomeDeprecatedUpdate1UpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// SomeDeprecatedUpdate1Handle provides a handle to a mycompany.simple.Deprecated.SomeDeprecatedUpdate1 workflow update
type SomeDeprecatedUpdate1Handle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*v1.SomeDeprecatedMessage, error)

	// ID returns the update id
	ID() string
}

// someDeprecatedUpdate1Handle provides a(n) SomeDeprecatedUpdate1Handle implementation
type someDeprecatedUpdate1Handle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *someDeprecatedUpdate1Handle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someDeprecatedUpdate1Handle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *someDeprecatedUpdate1Handle) Get(ctx workflow.Context) (*v1.SomeDeprecatedMessage, error) {
	var resp v1.SomeDeprecatedMessage
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someDeprecatedUpdate1Handle) ID() string {
	return r.id
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func SomeDeprecatedUpdate1(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1UpdateOptions) (*v1.SomeDeprecatedMessage, error) {
	run, err := SomeDeprecatedUpdate1Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedUpdate1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update and blocks until error or response received
//
// Deprecated: Do not use.
func SomeDeprecatedUpdate1Async(ctx workflow.Context, workflowID string, runID string, input *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1UpdateOptions) (SomeDeprecatedUpdate1Handle, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated update detected", "update", v1.SomeDeprecatedUpdate1UpdateName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedUpdate1UpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedUpdate1UpdateName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeDeprecatedUpdate1UpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeDeprecatedUpdate1UpdateOptions()
	}

	ctx, req, err := opt.Build(ctx, workflowID, runID, input)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedUpdate1Handle{
		cancel: cancel,
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
		future: workflow.ExecuteActivity(ctx, activityName, req),
	}, nil
}

// SomeDeprecatedUpdate2UpdateOptions are used to configure a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update execution
type SomeDeprecatedUpdate2UpdateOptions struct {
	ActivityOptions       *workflow.ActivityOptions
	HeartbeatInterval     time.Duration
	UpdateWorkflowOptions *client.UpdateWorkflowOptions
}

// NewSomeDeprecatedUpdate2UpdateOptions initializes a new SomeDeprecatedUpdate2UpdateOptions value
func NewSomeDeprecatedUpdate2UpdateOptions() *SomeDeprecatedUpdate2UpdateOptions {
	return &SomeDeprecatedUpdate2UpdateOptions{}
}

// Build initializes the update options
func (opt *SomeDeprecatedUpdate2UpdateOptions) Build(ctx workflow.Context, workflowID string, runID string, input *v1.SomeDeprecatedMessage) (workflow.Context, *xnsv1.UpdateRequest, error) {
	// configure activity options
	var ao workflow.ActivityOptions
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = 30000000000 // 30 seconds
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	uo := client.UpdateWorkflowOptions{}
	if opt.UpdateWorkflowOptions != nil {
		uo = *opt.UpdateWorkflowOptions
	}
	uo.WorkflowID = workflowID
	uo.RunID = runID
	if uo.UpdateID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating update id", "error", err)
				return nil
			}
			return id
		}).Get(&uo.UpdateID); err != nil {
			return nil, nil, err
		}
	}
	if uo.UpdateID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("update id is required", "InvalidArgument", nil)
	}

	uopb, err := xns.MarshalUpdateWorkflowOptions(uo)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update workflow options: %w", err)
	}

	inpb, err := anypb.New(input)
	if err != nil {
		return nil, nil, fmt.Errorf("error marshalling update request: %w", err)
	}

	return ctx, &xnsv1.UpdateRequest{
		HeartbeatInterval:     durationpb.New(opt.HeartbeatInterval),
		Request:               inpb,
		UpdateWorkflowOptions: uopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomeDeprecatedUpdate2UpdateOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomeDeprecatedUpdate2UpdateOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomeDeprecatedUpdate2UpdateOptions) WithHeartbeatInterval(d time.Duration) *SomeDeprecatedUpdate2UpdateOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithUpdateWorkflowOptions can be used to customize the update workflow options
func (opts *SomeDeprecatedUpdate2UpdateOptions) WithUpdateWorkflowOptions(uwo client.UpdateWorkflowOptions) *SomeDeprecatedUpdate2UpdateOptions {
	opts.UpdateWorkflowOptions = &uwo
	return opts
}

// SomeDeprecatedUpdate2Handle provides a handle to a mycompany.simple.Deprecated.SomeDeprecatedUpdate2 workflow update
type SomeDeprecatedUpdate2Handle interface {
	// Cancel cancels the update activity
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get blocks on update completion and returns the result
	Get(workflow.Context) (*v1.SomeDeprecatedMessage, error)

	// ID returns the update id
	ID() string
}

// someDeprecatedUpdate2Handle provides a(n) SomeDeprecatedUpdate2Handle implementation
type someDeprecatedUpdate2Handle struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow update
func (r *someDeprecatedUpdate2Handle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *someDeprecatedUpdate2Handle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying update result
func (r *someDeprecatedUpdate2Handle) Get(ctx workflow.Context) (*v1.SomeDeprecatedMessage, error) {
	var resp v1.SomeDeprecatedMessage
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *someDeprecatedUpdate2Handle) ID() string {
	return r.id
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func SomeDeprecatedUpdate2(ctx workflow.Context, workflowID string, runID string, req *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2UpdateOptions) (*v1.SomeDeprecatedMessage, error) {
	run, err := SomeDeprecatedUpdate2Async(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedUpdate2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update and blocks until error or response received
//
// Deprecated: Do not use.
func SomeDeprecatedUpdate2Async(ctx workflow.Context, workflowID string, runID string, input *v1.SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2UpdateOptions) (SomeDeprecatedUpdate2Handle, error) {
	workflow.GetLogger(ctx).Warn("use of deprecated update detected", "update", v1.SomeDeprecatedUpdate2UpdateName)

	activityName := deprecatedOptions.filterActivity(v1.SomeDeprecatedUpdate2UpdateName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomeDeprecatedUpdate2UpdateName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomeDeprecatedUpdate2UpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomeDeprecatedUpdate2UpdateOptions()
	}

	ctx, req, err := opt.Build(ctx, workflowID, runID, input)
	if err != nil {
		return nil, err
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &someDeprecatedUpdate2Handle{
		cancel: cancel,
		id:     req.GetUpdateWorkflowOptions().GetUpdateId(),
		future: workflow.ExecuteActivity(ctx, activityName, req),
	}, nil
}

// CancelDeprecatedWorkflow cancels an existing workflow
func CancelDeprecatedWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelDeprecatedWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelDeprecatedWorkflowAsync cancels an existing workflow
func CancelDeprecatedWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := deprecatedOptions.filterActivity("mycompany.simple.Deprecated.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for mycompany.simple.Deprecated.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// deprecatedActivities provides activities that can be used to interact with a(n) Deprecated service's workflow, queries, signals, and updates across namespaces
type deprecatedActivities struct {
	client v1.DeprecatedClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *deprecatedActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// GetSomeDeprecatedWorkflow1 retrieves a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) GetSomeDeprecatedWorkflow1(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow1WorkflowName)

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomeDeprecatedWorkflow1(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, deprecatedOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, deprecatedOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, deprecatedOptions.convertError(err)
					}
				}
				return nil, deprecatedOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedWorkflow1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedWorkflow1(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow1WorkflowName)

	// unmarshal workflow request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeDeprecatedWorkflow1Run
	run, err = a.client.SomeDeprecatedWorkflow1Async(actx, &req, v1.NewSomeDeprecatedWorkflow1Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, deprecatedOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, deprecatedOptions.convertError(err)
					}
				}
				return nil, deprecatedOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1 sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow1WorkflowName)
	activity.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal1SignalName)

	// unmarshal workflow request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal signal request
	var signal v1.SomeDeprecatedMessage
	if err := input.Signal.UnmarshalTo(&signal); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Signal.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeDeprecatedWorkflow1Run
	run, err = a.client.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(actx, &req, &signal, v1.NewSomeDeprecatedWorkflow1Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, deprecatedOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, deprecatedOptions.convertError(err)
					}
				}
				return nil, deprecatedOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// GetSomeDeprecatedWorkflow2 retrieves a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) GetSomeDeprecatedWorkflow2(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow2WorkflowName)

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomeDeprecatedWorkflow2(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, deprecatedOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, deprecatedOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, deprecatedOptions.convertError(err)
					}
				}
				return nil, deprecatedOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedWorkflow2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedWorkflow2(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow2WorkflowName)

	// unmarshal workflow request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeDeprecatedWorkflow2Run
	run, err = a.client.SomeDeprecatedWorkflow2Async(actx, &req, v1.NewSomeDeprecatedWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, deprecatedOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, deprecatedOptions.convertError(err)
					}
				}
				return nil, deprecatedOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2 sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated workflow detected", "workflow", v1.SomeDeprecatedWorkflow2WorkflowName)
	activity.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal2SignalName)

	// unmarshal workflow request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal signal request
	var signal v1.SomeDeprecatedMessage
	if err := input.Signal.UnmarshalTo(&signal); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Signal.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomeDeprecatedWorkflow2Run
	run, err = a.client.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(actx, &req, &signal, v1.NewSomeDeprecatedWorkflow2Options().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, deprecatedOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, deprecatedOptions.convertError(err)
					}
				}
				return nil, deprecatedOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedQuery1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedQuery1 query via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedQuery1(ctx context.Context, input *xnsv1.QueryRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated query detected", "query", v1.SomeDeprecatedQuery1QueryName)

	// unmarshal query request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling query request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.SomeDeprecatedQuery1(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, deprecatedOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedQuery2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedQuery2 query via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedQuery2(ctx context.Context, input *xnsv1.QueryRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated query detected", "query", v1.SomeDeprecatedQuery2QueryName)

	// unmarshal query request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling query request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = a.client.SomeDeprecatedQuery2(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			return nil, deprecatedOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedSignal1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedSignal1(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	activity.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal1SignalName)

	// unmarshal signal request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeDeprecatedSignal1(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			deprecatedOptions.convertError(ctx.Err())
		case <-doneCh:
			return deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedSignal2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedSignal2(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	activity.GetLogger(ctx).Warn("use of deprecated signal detected", "signal", v1.SomeDeprecatedSignal2SignalName)

	// unmarshal signal request
	var req v1.SomeDeprecatedMessage
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.SomeDeprecatedSignal2(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			deprecatedOptions.convertError(ctx.Err())
		case <-doneCh:
			return deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedUpdate1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedUpdate1(ctx context.Context, input *xnsv1.UpdateRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated update detected", "update", v1.SomeDeprecatedUpdate1UpdateName)

	var handle v1.SomeDeprecatedUpdate1Handle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, deprecatedOptions.convertError(err)
		}

		// retrieve handle for existing update
		handle, err = a.client.GetSomeDeprecatedUpdate1(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, deprecatedOptions.convertError(err)
		}
	} else {
		// unmarshal update request
		var req v1.SomeDeprecatedMessage
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			))
		}

		uo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())
		uo.WaitForStage = client.WorkflowUpdateStageAccepted

		// initialize update execution
		handle, err = a.client.SomeDeprecatedUpdate1Async(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			v1.NewSomeDeprecatedUpdate1Options().WithUpdateWorkflowOptions(uo),
		)
		if err != nil {
			return nil, deprecatedOptions.convertError(err)
		}
		activity.RecordHeartbeat(ctx, handle.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = handle.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())
		case <-ctx.Done():
			return nil, deprecatedOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}

// SomeDeprecatedUpdate2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update via an activity
//
// Deprecated: Do not use.
func (a *deprecatedActivities) SomeDeprecatedUpdate2(ctx context.Context, input *xnsv1.UpdateRequest) (resp *v1.SomeDeprecatedMessage, err error) {
	activity.GetLogger(ctx).Warn("use of deprecated update detected", "update", v1.SomeDeprecatedUpdate2UpdateName)

	var handle v1.SomeDeprecatedUpdate2Handle
	if activity.HasHeartbeatDetails(ctx) {
		// extract update id from heartbeat details
		var updateID string
		if err := activity.GetHeartbeatDetails(ctx, &updateID); err != nil {
			return nil, deprecatedOptions.convertError(err)
		}

		// retrieve handle for existing update
		handle, err = a.client.GetSomeDeprecatedUpdate2(ctx, client.GetWorkflowUpdateHandleOptions{
			WorkflowID: input.GetUpdateWorkflowOptions().GetWorkflowId(),
			RunID:      input.GetUpdateWorkflowOptions().GetRunId(),
			UpdateID:   updateID,
		})
		if err != nil {
			return nil, deprecatedOptions.convertError(err)
		}
	} else {
		// unmarshal update request
		var req v1.SomeDeprecatedMessage
		if err := input.Request.UnmarshalTo(&req); err != nil {
			return nil, deprecatedOptions.convertError(temporal.NewNonRetryableApplicationError(
				fmt.Sprintf("error unmarshalling update request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/simple/v1.SomeDeprecatedMessage", input.Request.GetTypeUrl()),
				"InvalidArgument",
				err,
			))
		}

		uo := xns.UnmarshalUpdateWorkflowOptions(input.GetUpdateWorkflowOptions())
		uo.WaitForStage = client.WorkflowUpdateStageAccepted

		// initialize update execution
		handle, err = a.client.SomeDeprecatedUpdate2Async(
			ctx,
			input.GetUpdateWorkflowOptions().GetWorkflowId(),
			input.GetUpdateWorkflowOptions().GetRunId(),
			&req,
			v1.NewSomeDeprecatedUpdate2Options().WithUpdateWorkflowOptions(uo),
		)
		if err != nil {
			return nil, deprecatedOptions.convertError(err)
		}
		activity.RecordHeartbeat(ctx, handle.UpdateID())
	}

	// wait for update to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = handle.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Minute
	}

	// heartbeat activity while waiting for workflow update to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, handle.UpdateID())
		case <-ctx.Done():
			return nil, deprecatedOptions.convertError(ctx.Err())
		case <-doneCh:
			return resp, deprecatedOptions.convertError(err)
		}
	}
}
