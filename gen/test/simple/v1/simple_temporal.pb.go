// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.14.4-next (e82835bad5227fc67a146f370ba42ab3f41c10cf)
//	go go1.22.2
//	protoc (unknown)
//
// source: test/simple/v1/simple.proto
package v1

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	v1 "github.com/cludden/protoc-gen-go-temporal/gen/test/simple/common/v1"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	patch "github.com/cludden/protoc-gen-go-temporal/pkg/patch"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	testutil "github.com/cludden/protoc-gen-go-temporal/pkg/testutil"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	serviceerror "go.temporal.io/api/serviceerror"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	"log/slog"
	"os"
	"sort"
	"strings"
	"time"
)

// SimpleTaskQueue is the default task-queue for a mycompany.simple.Simple worker
const SimpleTaskQueue = "my-task-queue"

// mycompany.simple.Simple workflow names
const (
	SomeWorkflow1WorkflowName = "mycompany.simple.SomeWorkflow1"
	SomeWorkflow2WorkflowName = "mycompany.simple.SomeWorkflow2"
	SomeWorkflow3WorkflowName = "mycompany.simple.Simple.SomeWorkflow3"
	SomeWorkflow4WorkflowName = "mycompany.simple.Simple.SomeWorkflow4"
)

// mycompany.simple.Simple workflow id expressions
var (
	SomeWorkflow1Idexpression = expression.MustParseExpression("some-workflow-1/${! id }/${! uuid_v4() }")
	SomeWorkflow2Idexpression = expression.MustParseExpression("some-workflow-2/${! uuid_v4() }")
	SomeWorkflow3Idexpression = expression.MustParseExpression("some-workflow-3/${! id }/${! requestVal }")
	SomeWorkflow4Idexpression = expression.MustParseExpression("some-workflow-4/${! uuid_v4() }")
)

// mycompany.simple.Simple activity names
const (
	SomeActivity1ActivityName = "mycompany.simple.SomeActivity1"
	SomeActivity2ActivityName = "mycompany.simple.Simple.SomeActivity2"
	SomeActivity3ActivityName = "mycompany.simple.Simple.SomeActivity3"
	SomeActivity4ActivityName = "mycompany.simple.Simple.SomeActivity4"
	SomeSignal1ActivityName   = "mycompany.simple.Simple.SomeSignal1"
	SomeSignal2ActivityName   = "mycompany.simple.Simple.SomeSignal2"
	SomeSignal3ActivityName   = "mycompany.simple.Simple.SomeSignal3"
	SomeUpdate1ActivityName   = "mycompany.simple.Simple.SomeUpdate1"
)

// mycompany.simple.Simple query names
const (
	SomeQuery1QueryName = "mycompany.simple.Simple.SomeQuery1"
	SomeQuery2QueryName = "mycompany.simple.Simple.SomeQuery2"
)

// mycompany.simple.Simple signal names
const (
	SomeSignal1SignalName = "mycompany.simple.Simple.SomeSignal1"
	SomeSignal2SignalName = "mycompany.simple.Simple.SomeSignal2"
	SomeSignal3SignalName = "mycompany.simple.Simple.SomeSignal3"
)

// mycompany.simple.Simple update names
const (
	SomeUpdate1UpdateName = "mycompany.simple.Simple.SomeUpdate1"
)

// mycompany.simple.Simple update id expressions
var (
	SomeUpdate1Idexpression = expression.MustParseExpression("some-update/${! requestVal.not_empty().catch(\"default\").slug() }")
)

// SimpleClient describes a client for a(n) mycompany.simple.Simple worker
type SimpleClient interface {
	// SomeWorkflow1 does some workflow thing.
	SomeWorkflow1(ctx context.Context, req *SomeWorkflow1Request, opts ...*SomeWorkflow1Options) (*SomeWorkflow1Response, error)

	// SomeWorkflow1Async starts a(n) mycompany.simple.SomeWorkflow1 workflow and returns a handle to the workflow run
	SomeWorkflow1Async(ctx context.Context, req *SomeWorkflow1Request, opts ...*SomeWorkflow1Options) (SomeWorkflow1Run, error)

	// GetSomeWorkflow1 retrieves a handle to an existing mycompany.simple.SomeWorkflow1 workflow execution
	GetSomeWorkflow1(ctx context.Context, workflowID string, runID string) SomeWorkflow1Run

	// SomeWorkflow2 does some workflow thing.
	SomeWorkflow2(ctx context.Context, opts ...*SomeWorkflow2Options) error

	// SomeWorkflow2Async starts a(n) mycompany.simple.SomeWorkflow2 workflow and returns a handle to the workflow run
	SomeWorkflow2Async(ctx context.Context, opts ...*SomeWorkflow2Options) (SomeWorkflow2Run, error)

	// GetSomeWorkflow2 retrieves a handle to an existing mycompany.simple.SomeWorkflow2 workflow execution
	GetSomeWorkflow2(ctx context.Context, workflowID string, runID string) SomeWorkflow2Run

	// SomeWorkflow2WithSomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal to a(n) mycompany.simple.SomeWorkflow2 workflow, starting it if necessary, and blocks until workflow completion
	SomeWorkflow2WithSomeSignal1(ctx context.Context, opts ...*SomeWorkflow2Options) error

	// SomeWorkflow2WithSomeSignal1Async sends a(n) mycompany.simple.Simple.SomeSignal1 signal to a(n) mycompany.simple.SomeWorkflow2 workflow, starting it if necessary, and returns a handle to the workflow execution
	SomeWorkflow2WithSomeSignal1Async(ctx context.Context, opts ...*SomeWorkflow2Options) (SomeWorkflow2Run, error)

	// SomeWorkflow3 does some workflow thing.
	// Deprecated: Use SomeWorkflow2 instead.
	SomeWorkflow3(ctx context.Context, req *SomeWorkflow3Request, opts ...*SomeWorkflow3Options) error

	// SomeWorkflow3Async starts a(n) mycompany.simple.Simple.SomeWorkflow3 workflow and returns a handle to the workflow run
	//
	// Deprecated: Do not use.
	SomeWorkflow3Async(ctx context.Context, req *SomeWorkflow3Request, opts ...*SomeWorkflow3Options) (SomeWorkflow3Run, error)

	// GetSomeWorkflow3 retrieves a handle to an existing mycompany.simple.Simple.SomeWorkflow3 workflow execution
	//
	// Deprecated: Do not use.
	GetSomeWorkflow3(ctx context.Context, workflowID string, runID string) SomeWorkflow3Run

	// SomeWorkflow3WithSomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow, starting it if necessary, and blocks until workflow completion
	//
	// Deprecated: Do not use.
	SomeWorkflow3WithSomeSignal2(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) error

	// SomeWorkflow3WithSomeSignal2Async sends a(n) mycompany.simple.Simple.SomeSignal2 signal to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow, starting it if necessary, and returns a handle to the workflow execution
	//
	// Deprecated: Do not use.
	SomeWorkflow3WithSomeSignal2Async(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) (SomeWorkflow3Run, error)

	// SomeWorkflow4 retrieves a paginated list of items
	SomeWorkflow4(ctx context.Context, req *v1.PaginatedRequest, opts ...*SomeWorkflow4Options) (*v1.PaginatedResponse, error)

	// SomeWorkflow4Async starts a(n) mycompany.simple.Simple.SomeWorkflow4 workflow and returns a handle to the workflow run
	SomeWorkflow4Async(ctx context.Context, req *v1.PaginatedRequest, opts ...*SomeWorkflow4Options) (SomeWorkflow4Run, error)

	// GetSomeWorkflow4 retrieves a handle to an existing mycompany.simple.Simple.SomeWorkflow4 workflow execution
	GetSomeWorkflow4(ctx context.Context, workflowID string, runID string) SomeWorkflow4Run

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// SomeQuery1 queries some thing.
	SomeQuery1(ctx context.Context, workflowID string, runID string) (*SomeQuery1Response, error)

	// SomeQuery2 queries some thing.
	SomeQuery2(ctx context.Context, workflowID string, runID string, query *SomeQuery2Request) (*SomeQuery2Response, error)

	// SomeSignal1 is a signal.
	SomeSignal1(ctx context.Context, workflowID string, runID string) error

	// SomeSignal2 is a signal.
	SomeSignal2(ctx context.Context, workflowID string, runID string, signal *SomeSignal2Request) error

	// SomeSignal3 is a signal.
	SomeSignal3(ctx context.Context, workflowID string, runID string, signal *SomeSignal3Request) error

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error)

	// SomeUpdate1Async starts a(n) mycompany.simple.Simple.SomeUpdate1 update and returns a handle to the workflow update
	SomeUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error)

	// GetSomeUpdate1 retrieves a handle to an existing mycompany.simple.Simple.SomeUpdate1 update
	GetSomeUpdate1(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeUpdate1Handle, error)
}

// simpleClient implements a temporal client for a mycompany.simple.Simple service
type simpleClient struct {
	client client.Client
	log    *slog.Logger
}

// NewSimpleClient initializes a new mycompany.simple.Simple client
func NewSimpleClient(c client.Client, options ...*simpleClientOptions) SimpleClient {
	var cfg *simpleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewSimpleClientOptions()
	}
	return &simpleClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewSimpleClientWithOptions initializes a new Simple client with the given options
func NewSimpleClientWithOptions(c client.Client, opts client.Options, options ...*simpleClientOptions) (SimpleClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *simpleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewSimpleClientOptions()
	}
	return &simpleClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// simpleClientOptions describes optional runtime configuration for a SimpleClient
type simpleClientOptions struct {
	log *slog.Logger
}

// NewSimpleClientOptions initializes a new simpleClientOptions value
func NewSimpleClientOptions() *simpleClientOptions {
	return &simpleClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *simpleClientOptions) WithLogger(l *slog.Logger) *simpleClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *simpleClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// SomeWorkflow1 does some workflow thing.
func (c *simpleClient) SomeWorkflow1(ctx context.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1Options) (*SomeWorkflow1Response, error) {
	run, err := c.SomeWorkflow1Async(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow1 does some workflow thing.
func (c *simpleClient) SomeWorkflow1Async(ctx context.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1Options) (SomeWorkflow1Run, error) {
	var o *SomeWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow1Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomeWorkflow1WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow1Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow1 fetches an existing mycompany.simple.SomeWorkflow1 execution
func (c *simpleClient) GetSomeWorkflow1(ctx context.Context, workflowID string, runID string) SomeWorkflow1Run {
	return &someWorkflow1Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeWorkflow2 does some workflow thing.
func (c *simpleClient) SomeWorkflow2(ctx context.Context, options ...*SomeWorkflow2Options) error {
	run, err := c.SomeWorkflow2Async(ctx, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2 does some workflow thing.
func (c *simpleClient) SomeWorkflow2Async(ctx context.Context, options ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	var o *SomeWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow2Options()
	}
	opts, err := o.Build(nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomeWorkflow2WorkflowName)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow2Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow2 fetches an existing mycompany.simple.SomeWorkflow2 execution
func (c *simpleClient) GetSomeWorkflow2(ctx context.Context, workflowID string, runID string) SomeWorkflow2Run {
	return &someWorkflow2Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeWorkflow2WithSomeSignal1 starts a(n) mycompany.simple.SomeWorkflow2 workflow and sends a(n) mycompany.simple.Simple.SomeSignal1 signal in a transaction
func (c *simpleClient) SomeWorkflow2WithSomeSignal1(ctx context.Context, options ...*SomeWorkflow2Options) error {
	run, err := c.SomeWorkflow2WithSomeSignal1Async(ctx, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2WithSomeSignal1Async starts a(n) mycompany.simple.SomeWorkflow2 workflow and sends a(n) mycompany.simple.Simple.SomeSignal1 signal in a transaction
func (c *simpleClient) SomeWorkflow2WithSomeSignal1Async(ctx context.Context, options ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	var o *SomeWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow2Options()
	}
	opts, err := o.Build(nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SomeSignal1SignalName, nil, opts, SomeWorkflow2WorkflowName)
	if run == nil || err != nil {
		return nil, err
	}
	return &someWorkflow2Run{
		client: c,
		run:    run,
	}, nil
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func (c *simpleClient) SomeWorkflow3(ctx context.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3Options) error {
	run, err := c.SomeWorkflow3Async(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func (c *simpleClient) SomeWorkflow3Async(ctx context.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeWorkflow3Async", "workflow", SomeWorkflow3WorkflowName)

	var o *SomeWorkflow3Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow3Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomeWorkflow3WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow3Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow3 fetches an existing mycompany.simple.Simple.SomeWorkflow3 execution
func (c *simpleClient) GetSomeWorkflow3(ctx context.Context, workflowID string, runID string) SomeWorkflow3Run {
	return &someWorkflow3Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeWorkflow3WithSomeSignal2 starts a(n) mycompany.simple.Simple.SomeWorkflow3 workflow and sends a(n) mycompany.simple.Simple.SomeSignal2 signal in a transaction
//
// Deprecated: Do not use.
func (c *simpleClient) SomeWorkflow3WithSomeSignal2(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, options ...*SomeWorkflow3Options) error {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeWorkflow3WithSomeSignal2", "workflow", SomeWorkflow3WorkflowName)

	run, err := c.SomeWorkflow3WithSomeSignal2Async(ctx, req, signal, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3WithSomeSignal2Async starts a(n) mycompany.simple.Simple.SomeWorkflow3 workflow and sends a(n) mycompany.simple.Simple.SomeSignal2 signal in a transaction
//
// Deprecated: Do not use.
func (c *simpleClient) SomeWorkflow3WithSomeSignal2Async(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, options ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeWorkflow3WithSomeSignal2Async", "workflow", SomeWorkflow3WorkflowName)

	var o *SomeWorkflow3Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow3Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SomeSignal2SignalName, signal, opts, SomeWorkflow3WorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &someWorkflow3Run{
		client: c,
		run:    run,
	}, nil
}

// SomeWorkflow4 retrieves a paginated list of items
func (c *simpleClient) SomeWorkflow4(ctx context.Context, req *v1.PaginatedRequest, options ...*SomeWorkflow4Options) (*v1.PaginatedResponse, error) {
	run, err := c.SomeWorkflow4Async(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow4 retrieves a paginated list of items
func (c *simpleClient) SomeWorkflow4Async(ctx context.Context, req *v1.PaginatedRequest, options ...*SomeWorkflow4Options) (SomeWorkflow4Run, error) {
	var o *SomeWorkflow4Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow4Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomeWorkflow4WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow4Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow4 fetches an existing mycompany.simple.Simple.SomeWorkflow4 execution
func (c *simpleClient) GetSomeWorkflow4(ctx context.Context, workflowID string, runID string) SomeWorkflow4Run {
	return &someWorkflow4Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *simpleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *simpleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// SomeQuery1 queries some thing.
func (c *simpleClient) SomeQuery1(ctx context.Context, workflowID string, runID string) (*SomeQuery1Response, error) {
	var resp SomeQuery1Response
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SomeQuery1QueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeQuery2 queries some thing.
func (c *simpleClient) SomeQuery2(ctx context.Context, workflowID string, runID string, query *SomeQuery2Request) (*SomeQuery2Response, error) {
	var resp SomeQuery2Response
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SomeQuery2QueryName, query); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeSignal1 is a signal.
func (c *simpleClient) SomeSignal1(ctx context.Context, workflowID string, runID string) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeSignal1SignalName, nil)
}

// SomeSignal2 is a signal.
func (c *simpleClient) SomeSignal2(ctx context.Context, workflowID string, runID string, signal *SomeSignal2Request) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeSignal2SignalName, signal)
}

// SomeSignal3 is a signal.
func (c *simpleClient) SomeSignal3(ctx context.Context, workflowID string, runID string, signal *SomeSignal3Request) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeSignal3SignalName, signal)
}

// SomeUpdate1 updates a SomeWorkflow2
func (c *simpleClient) SomeUpdate1(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	// initialize update options
	o := NewSomeUpdate1Options()
	if len(opts) > 0 && opts[0].Options != nil {
		o = opts[0]
	}

	// call sync update with WorkflowUpdateStageCompleted wait policy
	handle, err := c.SomeUpdate1Async(ctx, workflowID, runID, req, o.WithWaitPolicy(client.WorkflowUpdateStageCompleted))
	if err != nil {
		return nil, err
	}

	// block on update completion
	return handle.Get(ctx)
}

// SomeUpdate1 updates a SomeWorkflow2
func (c *simpleClient) SomeUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	// initialize update options
	var o *SomeUpdate1Options
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewSomeUpdate1Options()
	}

	// build UpdateWorkflowOptions
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	// update workflow
	handle, err := c.client.UpdateWorkflow(ctx, *options)
	if err != nil {
		return nil, err
	}
	return &someUpdate1Handle{client: c, handle: handle}, nil
}

// GetSomeUpdate1 retrieves a handle to an existing mycompany.simple.Simple.SomeUpdate1 update
func (c *simpleClient) GetSomeUpdate1(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeUpdate1Handle, error) {
	return &someUpdate1Handle{
		client: c,
		handle: c.client.GetWorkflowUpdateHandle(req),
	}, nil
}

// SomeWorkflow1Options provides configuration for a mycompany.simple.SomeWorkflow1 workflow operation
type SomeWorkflow1Options struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewSomeWorkflow1Options initializes a new SomeWorkflow1Options value
func NewSomeWorkflow1Options() *SomeWorkflow1Options {
	return &SomeWorkflow1Options{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow1Options) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow1Idexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow1WorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomeWorkflow1Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow1Options {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow1Options) WithExecutionTimeout(d time.Duration) *SomeWorkflow1Options {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomeWorkflow1Options) WithID(id string) *SomeWorkflow1Options {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow1Options) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow1Options {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow1Options) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow1Options {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow1Options) WithRunTimeout(d time.Duration) *SomeWorkflow1Options {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow1Options) WithSearchAttributes(sa map[string]any) *SomeWorkflow1Options {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow1Options) WithTaskTimeout(d time.Duration) *SomeWorkflow1Options {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow1Options) WithTaskQueue(tq string) *SomeWorkflow1Options {
	o.taskQueue = &tq
	return o
}

// SomeWorkflow1Run describes a(n) mycompany.simple.SomeWorkflow1 workflow run
type SomeWorkflow1Run interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeWorkflow1Response, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// SomeQuery1 queries some thing.
	SomeQuery1(ctx context.Context) (*SomeQuery1Response, error)

	// SomeQuery2 queries some thing.
	SomeQuery2(ctx context.Context, req *SomeQuery2Request) (*SomeQuery2Response, error)

	// SomeSignal1 is a signal.
	SomeSignal1(ctx context.Context) error

	// SomeSignal2 is a signal.
	SomeSignal2(ctx context.Context, req *SomeSignal2Request) error
}

// someWorkflow1Run provides an internal implementation of a(n) SomeWorkflow1RunRun
type someWorkflow1Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow1Run) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *someWorkflow1Run) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *someWorkflow1Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow1Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow1Run) Get(ctx context.Context) (*SomeWorkflow1Response, error) {
	var resp SomeWorkflow1Response
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow1Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeQuery1 queries some thing.
func (r *someWorkflow1Run) SomeQuery1(ctx context.Context) (*SomeQuery1Response, error) {
	return r.client.SomeQuery1(ctx, r.ID(), "")
}

// SomeQuery2 queries some thing.
func (r *someWorkflow1Run) SomeQuery2(ctx context.Context, req *SomeQuery2Request) (*SomeQuery2Response, error) {
	return r.client.SomeQuery2(ctx, r.ID(), "", req)
}

// SomeSignal1 is a signal.
func (r *someWorkflow1Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), "")
}

// SomeSignal2 is a signal.
func (r *someWorkflow1Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), "", req)
}

// SomeWorkflow2Options provides configuration for a mycompany.simple.SomeWorkflow2 workflow operation
type SomeWorkflow2Options struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewSomeWorkflow2Options initializes a new SomeWorkflow2Options value
func NewSomeWorkflow2Options() *SomeWorkflow2Options {
	return &SomeWorkflow2Options{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow2Options) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow2Idexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow2WorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomeWorkflow2Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow2Options {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow2Options) WithExecutionTimeout(d time.Duration) *SomeWorkflow2Options {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomeWorkflow2Options) WithID(id string) *SomeWorkflow2Options {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow2Options) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow2Options {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow2Options) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow2Options {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow2Options) WithRunTimeout(d time.Duration) *SomeWorkflow2Options {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow2Options) WithSearchAttributes(sa map[string]any) *SomeWorkflow2Options {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow2Options) WithTaskTimeout(d time.Duration) *SomeWorkflow2Options {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow2Options) WithTaskQueue(tq string) *SomeWorkflow2Options {
	o.taskQueue = &tq
	return o
}

// SomeWorkflow2Run describes a(n) mycompany.simple.SomeWorkflow2 workflow run
type SomeWorkflow2Run interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// SomeSignal1 is a signal.
	SomeSignal1(ctx context.Context) error

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error)

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1Async(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error)
}

// someWorkflow2Run provides an internal implementation of a(n) SomeWorkflow2RunRun
type someWorkflow2Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow2Run) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *someWorkflow2Run) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *someWorkflow2Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow2Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow2Run) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow2Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal1 is a signal.
func (r *someWorkflow2Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), "")
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow2Run) SomeUpdate1(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	return r.client.SomeUpdate1(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeUpdate1 updates a SomeWorkflow2
func (r *someWorkflow2Run) SomeUpdate1Async(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	return r.client.SomeUpdate1Async(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeWorkflow3Options provides configuration for a mycompany.simple.Simple.SomeWorkflow3 workflow operation
type SomeWorkflow3Options struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewSomeWorkflow3Options initializes a new SomeWorkflow3Options value
func NewSomeWorkflow3Options() *SomeWorkflow3Options {
	return &SomeWorkflow3Options{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow3Options) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow3Idexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow3WorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = "my-task-queue-2"
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{
			MaximumAttempts: int32(2),
		}
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomeWorkflow3Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow3Options {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow3Options) WithExecutionTimeout(d time.Duration) *SomeWorkflow3Options {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomeWorkflow3Options) WithID(id string) *SomeWorkflow3Options {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow3Options) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow3Options {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow3Options) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow3Options {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow3Options) WithRunTimeout(d time.Duration) *SomeWorkflow3Options {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow3Options) WithSearchAttributes(sa map[string]any) *SomeWorkflow3Options {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow3Options) WithTaskTimeout(d time.Duration) *SomeWorkflow3Options {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow3Options) WithTaskQueue(tq string) *SomeWorkflow3Options {
	o.taskQueue = &tq
	return o
}

// SomeWorkflow3Run describes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow run
type SomeWorkflow3Run interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// SomeSignal2 is a signal.
	SomeSignal2(ctx context.Context, req *SomeSignal2Request) error
}

// someWorkflow3Run provides an internal implementation of a(n) SomeWorkflow3RunRun
type someWorkflow3Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow3Run) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *someWorkflow3Run) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *someWorkflow3Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow3Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow3Run) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow3Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal2 is a signal.
func (r *someWorkflow3Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), "", req)
}

// SomeWorkflow4Options provides configuration for a mycompany.simple.Simple.SomeWorkflow4 workflow operation
type SomeWorkflow4Options struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewSomeWorkflow4Options initializes a new SomeWorkflow4Options value
func NewSomeWorkflow4Options() *SomeWorkflow4Options {
	return &SomeWorkflow4Options{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow4Options) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow4Idexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow4WorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomeWorkflow4Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow4Options {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow4Options) WithExecutionTimeout(d time.Duration) *SomeWorkflow4Options {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomeWorkflow4Options) WithID(id string) *SomeWorkflow4Options {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow4Options) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow4Options {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow4Options) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow4Options {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow4Options) WithRunTimeout(d time.Duration) *SomeWorkflow4Options {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow4Options) WithSearchAttributes(sa map[string]any) *SomeWorkflow4Options {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow4Options) WithTaskTimeout(d time.Duration) *SomeWorkflow4Options {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow4Options) WithTaskQueue(tq string) *SomeWorkflow4Options {
	o.taskQueue = &tq
	return o
}

// SomeWorkflow4Run describes a(n) mycompany.simple.Simple.SomeWorkflow4 workflow run
type SomeWorkflow4Run interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*v1.PaginatedResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// someWorkflow4Run provides an internal implementation of a(n) SomeWorkflow4RunRun
type someWorkflow4Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow4Run) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *someWorkflow4Run) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *someWorkflow4Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow4Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow4Run) Get(ctx context.Context) (*v1.PaginatedResponse, error) {
	var resp v1.PaginatedResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow4Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeUpdate1Handle describes a(n) mycompany.simple.Simple.SomeUpdate1 update handle
type SomeUpdate1Handle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeUpdate1Response, error)
}

// someUpdate1Handle provides an internal implementation of a(n) SomeUpdate1Handle
type someUpdate1Handle struct {
	client *simpleClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *someUpdate1Handle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *someUpdate1Handle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *someUpdate1Handle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *someUpdate1Handle) Get(ctx context.Context) (*SomeUpdate1Response, error) {
	var resp SomeUpdate1Response
	var err error
	doneCh := make(chan struct{})
	gctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			var deadlineExceeded *serviceerror.DeadlineExceeded
			if err = h.handle.Get(gctx, &resp); err != nil && ctx.Err() == nil && (errors.As(err, &deadlineExceeded) || strings.Contains(err.Error(), context.DeadlineExceeded.Error())) {
				continue
			}
			break
		}
		close(doneCh)
	}()

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-doneCh:
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}
}

// SomeUpdate1Options provides configuration for a mycompany.simple.Simple.SomeUpdate1 update operation
type SomeUpdate1Options struct {
	Options    *client.UpdateWorkflowOptions
	id         *string
	waitPolicy client.WorkflowUpdateStage
}

// NewSomeUpdate1Options initializes a new SomeUpdate1Options value
func NewSomeUpdate1Options() *SomeUpdate1Options {
	return &SomeUpdate1Options{Options: &client.UpdateWorkflowOptions{}}
}

// Build initializes a new client.UpdateWorkflowOptions with defaults and overrides applied
func (o *SomeUpdate1Options) Build(workflowID string, runID string, req *SomeUpdate1Request) (opts *client.UpdateWorkflowOptions, err error) {
	// use user-provided UpdateWorkflowOptions if exists
	if o.Options != nil {
		opts = o.Options
	} else {
		opts = &client.UpdateWorkflowOptions{}
	}

	// set constants
	opts.Args = []any{req}
	opts.RunID = runID
	opts.UpdateName = SomeUpdate1UpdateName
	opts.WorkflowID = workflowID

	// set UpdateID
	if v := o.id; v != nil {
		opts.UpdateID = *v
	} else if opts.UpdateID == "" {
		id, err := expression.EvalExpression(SomeUpdate1Idexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for %q update: %w", SomeUpdate1UpdateName, err)
		}
		opts.UpdateID = id
	}

	// set WaitPolicy
	if v := o.waitPolicy; v != client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = v
	} else if opts.WaitForStage == client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = client.WorkflowUpdateStageCompleted
	}
	return opts, nil
}

// WithUpdateID sets the UpdateID
func (o *SomeUpdate1Options) WithUpdateID(id string) *SomeUpdate1Options {
	o.id = &id
	return o
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowOptions
func (o *SomeUpdate1Options) WithUpdateWorkflowOptions(options client.UpdateWorkflowOptions) *SomeUpdate1Options {
	o.Options = &options
	return o
}

// WithWaitPolicy sets the WaitPolicy
func (o *SomeUpdate1Options) WithWaitPolicy(policy client.WorkflowUpdateStage) *SomeUpdate1Options {
	o.waitPolicy = policy
	return o
}

// Reference to generated workflow functions
var (
	// SomeWorkflow1 does some workflow thing.
	SomeWorkflow1Function func(workflow.Context, *SomeWorkflow1Request) (*SomeWorkflow1Response, error)
	// SomeWorkflow2 does some workflow thing.
	SomeWorkflow2Function func(workflow.Context) error
	// SomeWorkflow3 does some workflow thing.
	// Deprecated: Use SomeWorkflow2 instead.
	SomeWorkflow3Function func(workflow.Context, *SomeWorkflow3Request) error
	// SomeWorkflow4 retrieves a paginated list of items
	SomeWorkflow4Function func(workflow.Context, *v1.PaginatedRequest) (*v1.PaginatedResponse, error)
)

// SimpleWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// SimpleWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	SimpleWorkflowFunctions interface {
		// SomeWorkflow1 does some workflow thing.
		SomeWorkflow1(workflow.Context, *SomeWorkflow1Request) (*SomeWorkflow1Response, error)
		// SomeWorkflow2 does some workflow thing.
		SomeWorkflow2(workflow.Context) error
		// SomeWorkflow3 does some workflow thing.
		// Deprecated: Use SomeWorkflow2 instead.
		SomeWorkflow3(workflow.Context, *SomeWorkflow3Request) error
		// SomeWorkflow4 retrieves a paginated list of items
		SomeWorkflow4(workflow.Context, *v1.PaginatedRequest) (*v1.PaginatedResponse, error)
	}
	// simpleWorkflowFunctions provides an internal SimpleWorkflowFunctions implementation
	simpleWorkflowFunctions struct{}
)

func NewSimpleWorkflowFunctions() SimpleWorkflowFunctions {
	return &simpleWorkflowFunctions{}
}

// SomeWorkflow1 does some workflow thing.
func (f *simpleWorkflowFunctions) SomeWorkflow1(ctx workflow.Context, req *SomeWorkflow1Request) (*SomeWorkflow1Response, error) {
	if SomeWorkflow1Function == nil {
		return nil, errors.New("SomeWorkflow1 requires workflow registration via RegisterSimpleWorkflows or RegisterSomeWorkflow1Workflow")
	}
	return SomeWorkflow1Function(ctx, req)
}

// SomeWorkflow2 does some workflow thing.
func (f *simpleWorkflowFunctions) SomeWorkflow2(ctx workflow.Context) error {
	if SomeWorkflow2Function == nil {
		return errors.New("SomeWorkflow2 requires workflow registration via RegisterSimpleWorkflows or RegisterSomeWorkflow2Workflow")
	}
	return SomeWorkflow2Function(ctx)
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func (f *simpleWorkflowFunctions) SomeWorkflow3(ctx workflow.Context, req *SomeWorkflow3Request) error {
	if SomeWorkflow3Function == nil {
		return errors.New("SomeWorkflow3 requires workflow registration via RegisterSimpleWorkflows or RegisterSomeWorkflow3Workflow")
	}
	return SomeWorkflow3Function(ctx, req)
}

// SomeWorkflow4 retrieves a paginated list of items
func (f *simpleWorkflowFunctions) SomeWorkflow4(ctx workflow.Context, req *v1.PaginatedRequest) (*v1.PaginatedResponse, error) {
	if SomeWorkflow4Function == nil {
		return nil, errors.New("SomeWorkflow4 requires workflow registration via RegisterSimpleWorkflows or RegisterSomeWorkflow4Workflow")
	}
	return SomeWorkflow4Function(ctx, req)
}

// SimpleWorkflows provides methods for initializing new mycompany.simple.Simple workflow values
type SimpleWorkflows interface {
	// SomeWorkflow1 does some workflow thing.
	SomeWorkflow1(ctx workflow.Context, input *SomeWorkflow1WorkflowInput) (SomeWorkflow1Workflow, error)

	// SomeWorkflow2 does some workflow thing.
	SomeWorkflow2(ctx workflow.Context, input *SomeWorkflow2WorkflowInput) (SomeWorkflow2Workflow, error)

	// SomeWorkflow3 does some workflow thing.
	// Deprecated: Use SomeWorkflow2 instead.
	SomeWorkflow3(ctx workflow.Context, input *SomeWorkflow3WorkflowInput) (SomeWorkflow3Workflow, error)

	// SomeWorkflow4 retrieves a paginated list of items
	SomeWorkflow4(ctx workflow.Context, input *SomeWorkflow4WorkflowInput) (SomeWorkflow4Workflow, error)
}

// RegisterSimpleWorkflows registers mycompany.simple.Simple workflows with the given worker
func RegisterSimpleWorkflows(r worker.WorkflowRegistry, workflows SimpleWorkflows) {
	RegisterSomeWorkflow1Workflow(r, workflows.SomeWorkflow1)
	RegisterSomeWorkflow2Workflow(r, workflows.SomeWorkflow2)
	RegisterSomeWorkflow3Workflow(r, workflows.SomeWorkflow3)
	RegisterSomeWorkflow4Workflow(r, workflows.SomeWorkflow4)
}

// RegisterSomeWorkflow1Workflow registers a mycompany.simple.Simple.SomeWorkflow1 workflow with the given worker
func RegisterSomeWorkflow1Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow1WorkflowInput) (SomeWorkflow1Workflow, error)) {
	SomeWorkflow1Function = buildSomeWorkflow1(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow1Function, workflow.RegisterOptions{Name: SomeWorkflow1WorkflowName})
	r.RegisterWorkflowWithOptions(SomeWorkflow1Function, workflow.RegisterOptions{Name: "mycompany.SomeWorkflow1"})
}

// buildSomeWorkflow1 converts a SomeWorkflow1 workflow struct into a valid workflow function
func buildSomeWorkflow1(ctor func(workflow.Context, *SomeWorkflow1WorkflowInput) (SomeWorkflow1Workflow, error)) func(workflow.Context, *SomeWorkflow1Request) (*SomeWorkflow1Response, error) {
	return func(ctx workflow.Context, req *SomeWorkflow1Request) (*SomeWorkflow1Response, error) {
		input := &SomeWorkflow1WorkflowInput{
			Req: req,
			SomeSignal1: &SomeSignal1Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal1SignalName),
			},
			SomeSignal2: &SomeSignal2Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal2SignalName),
			},
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, SimpleTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		if err := workflow.SetQueryHandler(ctx, SomeQuery1QueryName, wf.SomeQuery1); err != nil {
			return nil, err
		}
		if err := workflow.SetQueryHandler(ctx, SomeQuery2QueryName, wf.SomeQuery2); err != nil {
			return nil, err
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow1WorkflowInput describes the input to a(n) mycompany.simple.SomeWorkflow1 workflow constructor
type SomeWorkflow1WorkflowInput struct {
	Req         *SomeWorkflow1Request
	SomeSignal1 *SomeSignal1Signal
	SomeSignal2 *SomeSignal2Signal
}

// SomeWorkflow1 does some workflow thing.
//
// workflow details: (name: "mycompany.simple.SomeWorkflow1", id: "some-workflow-1/${! id }/${! uuid_v4() }")
type SomeWorkflow1Workflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.SomeWorkflow1 workflow
	Execute(ctx workflow.Context) (*SomeWorkflow1Response, error)

	// SomeQuery1 queries some thing.
	SomeQuery1() (*SomeQuery1Response, error)

	// SomeQuery2 queries some thing.
	SomeQuery2(*SomeQuery2Request) (*SomeQuery2Response, error)
}

// SomeWorkflow1 does some workflow thing.
func SomeWorkflow1Child(ctx workflow.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1ChildOptions) (*SomeWorkflow1Response, error) {
	childRun, err := SomeWorkflow1ChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow1 does some workflow thing.
func SomeWorkflow1ChildAsync(ctx workflow.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1ChildOptions) (*SomeWorkflow1ChildRun, error) {
	var o *SomeWorkflow1ChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow1ChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &SomeWorkflow1ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow1WorkflowName, req)}, nil
}

// SomeWorkflow1ChildOptions provides configuration for a child mycompany.simple.SomeWorkflow1 workflow operation
type SomeWorkflow1ChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewSomeWorkflow1ChildOptions initializes a new SomeWorkflow1ChildOptions value
func NewSomeWorkflow1ChildOptions() *SomeWorkflow1ChildOptions {
	return &SomeWorkflow1ChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow1ChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(SomeWorkflow1Idexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow1WorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow1WorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(SomeWorkflow1Idexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow1WorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomeWorkflow1ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow1ChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow1ChildOptions) WithExecutionTimeout(d time.Duration) *SomeWorkflow1ChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomeWorkflow1ChildOptions) WithID(id string) *SomeWorkflow1ChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow1ChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow1ChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow1ChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow1ChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow1ChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow1ChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow1ChildOptions) WithRunTimeout(d time.Duration) *SomeWorkflow1ChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow1ChildOptions) WithSearchAttributes(sa map[string]any) *SomeWorkflow1ChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow1ChildOptions) WithTaskTimeout(d time.Duration) *SomeWorkflow1ChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow1ChildOptions) WithTaskQueue(tq string) *SomeWorkflow1ChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeWorkflow1ChildOptions) WithWaitForCancellation(wait bool) *SomeWorkflow1ChildOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeWorkflow1ChildRun describes a child SomeWorkflow1 workflow run
type SomeWorkflow1ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow1ChildRun) Get(ctx workflow.Context) (*SomeWorkflow1Response, error) {
	var resp SomeWorkflow1Response
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow1ChildRun) Select(sel workflow.Selector, fn func(*SomeWorkflow1ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow1ChildRun) SelectStart(sel workflow.Selector, fn func(*SomeWorkflow1ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow1ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal1 sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal1(ctx workflow.Context) error {
	return r.SomeSignal1Async(ctx).Get(ctx, nil)
}

// SomeSignal1Async sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal1Async(ctx workflow.Context) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal1SignalName, nil)
}

// SomeSignal2 sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal2(ctx workflow.Context, input *SomeSignal2Request) error {
	return r.SomeSignal2Async(ctx, input).Get(ctx, nil)
}

// SomeSignal2Async sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal2Async(ctx workflow.Context, input *SomeSignal2Request) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal2SignalName, input)
}

// RegisterSomeWorkflow2Workflow registers a mycompany.simple.Simple.SomeWorkflow2 workflow with the given worker
func RegisterSomeWorkflow2Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow2WorkflowInput) (SomeWorkflow2Workflow, error)) {
	SomeWorkflow2Function = buildSomeWorkflow2(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow2Function, workflow.RegisterOptions{Name: SomeWorkflow2WorkflowName})
}

// buildSomeWorkflow2 converts a SomeWorkflow2 workflow struct into a valid workflow function
func buildSomeWorkflow2(ctor func(workflow.Context, *SomeWorkflow2WorkflowInput) (SomeWorkflow2Workflow, error)) func(workflow.Context) error {
	return func(ctx workflow.Context) error {
		input := &SomeWorkflow2WorkflowInput{
			SomeSignal1: &SomeSignal1Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal1SignalName),
			},
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, SimpleTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		{
			opts := workflow.UpdateHandlerOptions{Validator: wf.ValidateSomeUpdate1}
			if err := workflow.SetUpdateHandlerWithOptions(ctx, SomeUpdate1UpdateName, wf.SomeUpdate1, opts); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow2WorkflowInput describes the input to a(n) mycompany.simple.SomeWorkflow2 workflow constructor
type SomeWorkflow2WorkflowInput struct {
	SomeSignal1 *SomeSignal1Signal
}

// SomeWorkflow2 does some workflow thing.
//
// workflow details: (name: "mycompany.simple.SomeWorkflow2", id: "some-workflow-2/${! uuid_v4() }")
type SomeWorkflow2Workflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.SomeWorkflow2 workflow
	Execute(ctx workflow.Context) error

	// ValidateSomeUpdate1 validates a(n) mycompany.simple.Simple.SomeUpdate1 update
	ValidateSomeUpdate1(workflow.Context, *SomeUpdate1Request) error

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(workflow.Context, *SomeUpdate1Request) (*SomeUpdate1Response, error)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2Child(ctx workflow.Context, options ...*SomeWorkflow2ChildOptions) error {
	childRun, err := SomeWorkflow2ChildAsync(ctx, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow2 does some workflow thing.
func SomeWorkflow2ChildAsync(ctx workflow.Context, options ...*SomeWorkflow2ChildOptions) (*SomeWorkflow2ChildRun, error) {
	var o *SomeWorkflow2ChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow2ChildOptions()
	}
	opts, err := o.Build(ctx, nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &SomeWorkflow2ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow2WorkflowName, nil)}, nil
}

// SomeWorkflow2ChildOptions provides configuration for a child mycompany.simple.SomeWorkflow2 workflow operation
type SomeWorkflow2ChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewSomeWorkflow2ChildOptions initializes a new SomeWorkflow2ChildOptions value
func NewSomeWorkflow2ChildOptions() *SomeWorkflow2ChildOptions {
	return &SomeWorkflow2ChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow2ChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		lao := workflow.GetLocalActivityOptions(ctx)
		lao.ScheduleToCloseTimeout = time.Second * 10
		if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
			id, err := expression.EvalExpression(SomeWorkflow2Idexpression, req)
			if err != nil {
				return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow2WorkflowName, err)
			}
			return id, nil
		}).Get(ctx, &opts.WorkflowID); err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow2WorkflowName, err)
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomeWorkflow2ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow2ChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow2ChildOptions) WithExecutionTimeout(d time.Duration) *SomeWorkflow2ChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomeWorkflow2ChildOptions) WithID(id string) *SomeWorkflow2ChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow2ChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow2ChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow2ChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow2ChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow2ChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow2ChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow2ChildOptions) WithRunTimeout(d time.Duration) *SomeWorkflow2ChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow2ChildOptions) WithSearchAttributes(sa map[string]any) *SomeWorkflow2ChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow2ChildOptions) WithTaskTimeout(d time.Duration) *SomeWorkflow2ChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow2ChildOptions) WithTaskQueue(tq string) *SomeWorkflow2ChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeWorkflow2ChildOptions) WithWaitForCancellation(wait bool) *SomeWorkflow2ChildOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeWorkflow2ChildRun describes a child SomeWorkflow2 workflow run
type SomeWorkflow2ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow2ChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow2ChildRun) Select(sel workflow.Selector, fn func(*SomeWorkflow2ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow2ChildRun) SelectStart(sel workflow.Selector, fn func(*SomeWorkflow2ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow2ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal1 sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow2ChildRun) SomeSignal1(ctx workflow.Context) error {
	return r.SomeSignal1Async(ctx).Get(ctx, nil)
}

// SomeSignal1Async sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow2ChildRun) SomeSignal1Async(ctx workflow.Context) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal1SignalName, nil)
}

// RegisterSomeWorkflow3Workflow registers a mycompany.simple.Simple.SomeWorkflow3 workflow with the given worker
func RegisterSomeWorkflow3Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow3WorkflowInput) (SomeWorkflow3Workflow, error)) {
	SomeWorkflow3Function = buildSomeWorkflow3(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow3Function, workflow.RegisterOptions{Name: SomeWorkflow3WorkflowName})
}

// buildSomeWorkflow3 converts a SomeWorkflow3 workflow struct into a valid workflow function
func buildSomeWorkflow3(ctor func(workflow.Context, *SomeWorkflow3WorkflowInput) (SomeWorkflow3Workflow, error)) func(workflow.Context, *SomeWorkflow3Request) error {
	return func(ctx workflow.Context, req *SomeWorkflow3Request) error {
		input := &SomeWorkflow3WorkflowInput{
			Req: req,
			SomeSignal2: &SomeSignal2Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal2SignalName),
			},
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, "my-task-queue-2", workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow3WorkflowInput describes the input to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow constructor
type SomeWorkflow3WorkflowInput struct {
	Req         *SomeWorkflow3Request
	SomeSignal2 *SomeSignal2Signal
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
//
// workflow details: (name: "mycompany.simple.Simple.SomeWorkflow3", id: "some-workflow-3/${! id }/${! requestVal }")
type SomeWorkflow3Workflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow
	//
	// Deprecated: Do not use.
	Execute(ctx workflow.Context) error
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func SomeWorkflow3Child(ctx workflow.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3ChildOptions) error {
	childRun, err := SomeWorkflow3ChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow3 does some workflow thing.
// Deprecated: Use SomeWorkflow2 instead.
func SomeWorkflow3ChildAsync(ctx workflow.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3ChildOptions) (*SomeWorkflow3ChildRun, error) {
	var o *SomeWorkflow3ChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow3ChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &SomeWorkflow3ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow3WorkflowName, req)}, nil
}

// SomeWorkflow3ChildOptions provides configuration for a child mycompany.simple.Simple.SomeWorkflow3 workflow operation
type SomeWorkflow3ChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewSomeWorkflow3ChildOptions initializes a new SomeWorkflow3ChildOptions value
func NewSomeWorkflow3ChildOptions() *SomeWorkflow3ChildOptions {
	return &SomeWorkflow3ChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow3ChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(SomeWorkflow3Idexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow3WorkflowName, err)
		}
		opts.WorkflowID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, "my-task-queue-2"); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = "my-task-queue-2"
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{
			MaximumAttempts: int32(2),
		}
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomeWorkflow3ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow3ChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow3ChildOptions) WithExecutionTimeout(d time.Duration) *SomeWorkflow3ChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomeWorkflow3ChildOptions) WithID(id string) *SomeWorkflow3ChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow3ChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow3ChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow3ChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow3ChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow3ChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow3ChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow3ChildOptions) WithRunTimeout(d time.Duration) *SomeWorkflow3ChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow3ChildOptions) WithSearchAttributes(sa map[string]any) *SomeWorkflow3ChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow3ChildOptions) WithTaskTimeout(d time.Duration) *SomeWorkflow3ChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow3ChildOptions) WithTaskQueue(tq string) *SomeWorkflow3ChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeWorkflow3ChildOptions) WithWaitForCancellation(wait bool) *SomeWorkflow3ChildOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeWorkflow3ChildRun describes a child SomeWorkflow3 workflow run
type SomeWorkflow3ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow3ChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow3ChildRun) Select(sel workflow.Selector, fn func(*SomeWorkflow3ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow3ChildRun) SelectStart(sel workflow.Selector, fn func(*SomeWorkflow3ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow3ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal2 sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow3ChildRun) SomeSignal2(ctx workflow.Context, input *SomeSignal2Request) error {
	return r.SomeSignal2Async(ctx, input).Get(ctx, nil)
}

// SomeSignal2Async sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow3ChildRun) SomeSignal2Async(ctx workflow.Context, input *SomeSignal2Request) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal2SignalName, input)
}

// RegisterSomeWorkflow4Workflow registers a mycompany.simple.Simple.SomeWorkflow4 workflow with the given worker
func RegisterSomeWorkflow4Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow4WorkflowInput) (SomeWorkflow4Workflow, error)) {
	SomeWorkflow4Function = buildSomeWorkflow4(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow4Function, workflow.RegisterOptions{Name: SomeWorkflow4WorkflowName})
}

// buildSomeWorkflow4 converts a SomeWorkflow4 workflow struct into a valid workflow function
func buildSomeWorkflow4(ctor func(workflow.Context, *SomeWorkflow4WorkflowInput) (SomeWorkflow4Workflow, error)) func(workflow.Context, *v1.PaginatedRequest) (*v1.PaginatedResponse, error) {
	return func(ctx workflow.Context, req *v1.PaginatedRequest) (*v1.PaginatedResponse, error) {
		input := &SomeWorkflow4WorkflowInput{
			Req: req,
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, SimpleTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow4WorkflowInput describes the input to a(n) mycompany.simple.Simple.SomeWorkflow4 workflow constructor
type SomeWorkflow4WorkflowInput struct {
	Req *v1.PaginatedRequest
}

// SomeWorkflow4 retrieves a paginated list of items
//
// workflow details: (name: "mycompany.simple.Simple.SomeWorkflow4", id: "some-workflow-4/${! uuid_v4() }")
type SomeWorkflow4Workflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Simple.SomeWorkflow4 workflow
	Execute(ctx workflow.Context) (*v1.PaginatedResponse, error)
}

// SomeWorkflow4 retrieves a paginated list of items
func SomeWorkflow4Child(ctx workflow.Context, req *v1.PaginatedRequest, options ...*SomeWorkflow4ChildOptions) (*v1.PaginatedResponse, error) {
	childRun, err := SomeWorkflow4ChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow4 retrieves a paginated list of items
func SomeWorkflow4ChildAsync(ctx workflow.Context, req *v1.PaginatedRequest, options ...*SomeWorkflow4ChildOptions) (*SomeWorkflow4ChildRun, error) {
	var o *SomeWorkflow4ChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow4ChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &SomeWorkflow4ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow4WorkflowName, req)}, nil
}

// SomeWorkflow4ChildOptions provides configuration for a child mycompany.simple.Simple.SomeWorkflow4 workflow operation
type SomeWorkflow4ChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewSomeWorkflow4ChildOptions initializes a new SomeWorkflow4ChildOptions value
func NewSomeWorkflow4ChildOptions() *SomeWorkflow4ChildOptions {
	return &SomeWorkflow4ChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomeWorkflow4ChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(SomeWorkflow4Idexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow4WorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow4WorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(SomeWorkflow4Idexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomeWorkflow4WorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomeWorkflow4ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow4ChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeWorkflow4ChildOptions) WithExecutionTimeout(d time.Duration) *SomeWorkflow4ChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomeWorkflow4ChildOptions) WithID(id string) *SomeWorkflow4ChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow4ChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeWorkflow4ChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomeWorkflow4ChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeWorkflow4ChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeWorkflow4ChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeWorkflow4ChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeWorkflow4ChildOptions) WithRunTimeout(d time.Duration) *SomeWorkflow4ChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeWorkflow4ChildOptions) WithSearchAttributes(sa map[string]any) *SomeWorkflow4ChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeWorkflow4ChildOptions) WithTaskTimeout(d time.Duration) *SomeWorkflow4ChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeWorkflow4ChildOptions) WithTaskQueue(tq string) *SomeWorkflow4ChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeWorkflow4ChildOptions) WithWaitForCancellation(wait bool) *SomeWorkflow4ChildOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeWorkflow4ChildRun describes a child SomeWorkflow4 workflow run
type SomeWorkflow4ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow4ChildRun) Get(ctx workflow.Context) (*v1.PaginatedResponse, error) {
	var resp v1.PaginatedResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow4ChildRun) Select(sel workflow.Selector, fn func(*SomeWorkflow4ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow4ChildRun) SelectStart(sel workflow.Selector, fn func(*SomeWorkflow4ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow4ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal1Signal describes a(n) mycompany.simple.Simple.SomeSignal1 signal
type SomeSignal1Signal struct {
	Channel workflow.ReceiveChannel
}

// NewSomeSignal1Signal initializes a new mycompany.simple.Simple.SomeSignal1 signal wrapper
func NewSomeSignal1Signal(ctx workflow.Context) *SomeSignal1Signal {
	return &SomeSignal1Signal{Channel: workflow.GetSignalChannel(ctx, SomeSignal1SignalName)}
}

// Receive blocks until a(n) mycompany.simple.Simple.SomeSignal1 signal is received
func (s *SomeSignal1Signal) Receive(ctx workflow.Context) bool {
	more := s.Channel.Receive(ctx, nil)
	return more
}

// ReceiveAsync checks for a mycompany.simple.Simple.SomeSignal1 signal without blocking
func (s *SomeSignal1Signal) ReceiveAsync() bool {
	return s.Channel.ReceiveAsync(nil)
}

// ReceiveWithTimeout blocks until a(n) mycompany.simple.Simple.SomeSignal1 signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
func (s *SomeSignal1Signal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (ok bool, more bool) {
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, nil); !ok {
		return false, more
	}
	return
}

// Select checks for a(n) mycompany.simple.Simple.SomeSignal1 signal without blocking
func (s *SomeSignal1Signal) Select(sel workflow.Selector, fn func()) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		s.ReceiveAsync()
		if fn != nil {
			fn()
		}
	})
}

// SomeSignal1 is a signal.
func SomeSignal1External(ctx workflow.Context, workflowID string, runID string) error {
	return SomeSignal1ExternalAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// SomeSignal1 is a signal.
func SomeSignal1ExternalAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeSignal1SignalName, nil)
}

// SomeSignal2Signal describes a(n) mycompany.simple.Simple.SomeSignal2 signal
type SomeSignal2Signal struct {
	Channel workflow.ReceiveChannel
}

// NewSomeSignal2Signal initializes a new mycompany.simple.Simple.SomeSignal2 signal wrapper
func NewSomeSignal2Signal(ctx workflow.Context) *SomeSignal2Signal {
	return &SomeSignal2Signal{Channel: workflow.GetSignalChannel(ctx, SomeSignal2SignalName)}
}

// Receive blocks until a(n) mycompany.simple.Simple.SomeSignal2 signal is received
func (s *SomeSignal2Signal) Receive(ctx workflow.Context) (*SomeSignal2Request, bool) {
	var resp SomeSignal2Request
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Simple.SomeSignal2 signal without blocking
func (s *SomeSignal2Signal) ReceiveAsync() *SomeSignal2Request {
	var resp SomeSignal2Request
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) mycompany.simple.Simple.SomeSignal2 signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *SomeSignal2Signal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *SomeSignal2Request, ok bool, more bool) {
	resp = &SomeSignal2Request{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) mycompany.simple.Simple.SomeSignal2 signal without blocking
func (s *SomeSignal2Signal) Select(sel workflow.Selector, fn func(*SomeSignal2Request)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SomeSignal2 is a signal.
func SomeSignal2External(ctx workflow.Context, workflowID string, runID string, req *SomeSignal2Request) error {
	return SomeSignal2ExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// SomeSignal2 is a signal.
func SomeSignal2ExternalAsync(ctx workflow.Context, workflowID string, runID string, req *SomeSignal2Request) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeSignal2SignalName, req)
}

// SomeSignal3Signal describes a(n) mycompany.simple.Simple.SomeSignal3 signal
type SomeSignal3Signal struct {
	Channel workflow.ReceiveChannel
}

// NewSomeSignal3Signal initializes a new mycompany.simple.Simple.SomeSignal3 signal wrapper
func NewSomeSignal3Signal(ctx workflow.Context) *SomeSignal3Signal {
	return &SomeSignal3Signal{Channel: workflow.GetSignalChannel(ctx, SomeSignal3SignalName)}
}

// Receive blocks until a(n) mycompany.simple.Simple.SomeSignal3 signal is received
func (s *SomeSignal3Signal) Receive(ctx workflow.Context) (*SomeSignal3Request, bool) {
	var resp SomeSignal3Request
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Simple.SomeSignal3 signal without blocking
func (s *SomeSignal3Signal) ReceiveAsync() *SomeSignal3Request {
	var resp SomeSignal3Request
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) mycompany.simple.Simple.SomeSignal3 signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *SomeSignal3Signal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *SomeSignal3Request, ok bool, more bool) {
	resp = &SomeSignal3Request{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) mycompany.simple.Simple.SomeSignal3 signal without blocking
func (s *SomeSignal3Signal) Select(sel workflow.Selector, fn func(*SomeSignal3Request)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SomeSignal3 is a signal.
func SomeSignal3External(ctx workflow.Context, workflowID string, runID string, req *SomeSignal3Request) error {
	return SomeSignal3ExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// SomeSignal3 is a signal.
func SomeSignal3ExternalAsync(ctx workflow.Context, workflowID string, runID string, req *SomeSignal3Request) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeSignal3SignalName, req)
}

// SimpleActivities describes available worker activities
type SimpleActivities interface {
	// SomeActivity1 does some activity thing.
	SomeActivity1(ctx context.Context) error

	// SomeActivity2 does some activity thing.
	SomeActivity2(ctx context.Context, req *SomeActivity2Request) error

	// SomeActivity3 does some activity thing.
	SomeActivity3(ctx context.Context, req *SomeActivity3Request) (*SomeActivity3Response, error)

	// SomeActivity4 does some activity thing.
	SomeActivity4(ctx context.Context) error

	// SomeSignal1 is a signal.
	SomeSignal1(ctx context.Context) error

	// SomeSignal2 is a signal.
	SomeSignal2(ctx context.Context, req *SomeSignal2Request) error

	// SomeSignal3 is a signal.
	SomeSignal3(ctx context.Context, req *SomeSignal3Request) (*SomeSignal3Response, error)

	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(ctx context.Context, req *SomeUpdate1Request) (*SomeUpdate1Response, error)
}

// RegisterSimpleActivities registers activities with a worker
func RegisterSimpleActivities(r worker.ActivityRegistry, activities SimpleActivities) {
	RegisterSomeActivity1Activity(r, activities.SomeActivity1)
	RegisterSomeActivity2Activity(r, activities.SomeActivity2)
	RegisterSomeActivity3Activity(r, activities.SomeActivity3)
	RegisterSomeActivity4Activity(r, activities.SomeActivity4)
	RegisterSomeSignal1Activity(r, activities.SomeSignal1)
	RegisterSomeSignal2Activity(r, activities.SomeSignal2)
	RegisterSomeSignal3Activity(r, activities.SomeSignal3)
	RegisterSomeUpdate1Activity(r, activities.SomeUpdate1)
}

// RegisterSomeActivity1Activity registers a mycompany.simple.SomeActivity1 activity
func RegisterSomeActivity1Activity(r worker.ActivityRegistry, fn func(context.Context) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity1ActivityName,
	})
}

// SomeActivity1Future describes a(n) mycompany.simple.SomeActivity1 activity execution
type SomeActivity1Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity1Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity1Future) Select(sel workflow.Selector, fn func(*SomeActivity1Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity1 does some activity thing.
func SomeActivity1(ctx workflow.Context, options ...*SomeActivity1ActivityOptions) error {
	return SomeActivity1Async(ctx, options...).Get(ctx)
}

// SomeActivity1 does some activity thing.
func SomeActivity1Async(ctx workflow.Context, options ...*SomeActivity1ActivityOptions) *SomeActivity1Future {
	var o *SomeActivity1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity1ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity1Future{Future: errF}
	}
	activity := SomeActivity1ActivityName
	future := &SomeActivity1Future{Future: workflow.ExecuteActivity(ctx, activity)}
	return future
}

// SomeActivity1 does some activity thing.
func SomeActivity1Local(ctx workflow.Context, options ...*SomeActivity1LocalActivityOptions) error {
	return SomeActivity1LocalAsync(ctx, options...).Get(ctx)
}

// SomeActivity1 does some activity thing.
func SomeActivity1LocalAsync(ctx workflow.Context, options ...*SomeActivity1LocalActivityOptions) *SomeActivity1Future {
	var o *SomeActivity1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity1LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity1Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeActivity1ActivityName
	}
	future := &SomeActivity1Future{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future
}

// SomeActivity1ActivityOptions provides configuration for a(n) mycompany.simple.SomeActivity1 activity
type SomeActivity1ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeActivity1ActivityOptions initializes a new SomeActivity1ActivityOptions value
func NewSomeActivity1ActivityOptions() *SomeActivity1ActivityOptions {
	return &SomeActivity1ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity1ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeActivity1ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity1ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeActivity1ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeActivity1ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity1ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity1ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity1ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity1ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeActivity1ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeActivity1ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity1ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity1ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeActivity1ActivityOptions) WithTaskQueue(tq string) *SomeActivity1ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeActivity1ActivityOptions) WithWaitForCancellation(wait bool) *SomeActivity1ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeActivity1LocalActivityOptions provides configuration for a(n) mycompany.simple.SomeActivity1 activity
type SomeActivity1LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context) error
}

// NewSomeActivity1LocalActivityOptions initializes a new SomeActivity1LocalActivityOptions value
func NewSomeActivity1LocalActivityOptions() *SomeActivity1LocalActivityOptions {
	return &SomeActivity1LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity1LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.SomeActivity1 implementation
func (o *SomeActivity1LocalActivityOptions) Local(fn func(context.Context) error) *SomeActivity1LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeActivity1LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity1LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity1LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity1LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity1LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity1LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity1LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity1LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeActivity2Activity registers a mycompany.simple.Simple.SomeActivity2 activity
func RegisterSomeActivity2Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeActivity2Request) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity2ActivityName,
	})
}

// SomeActivity2Future describes a(n) mycompany.simple.Simple.SomeActivity2 activity execution
type SomeActivity2Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity2Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity2Future) Select(sel workflow.Selector, fn func(*SomeActivity2Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity2 does some activity thing.
func SomeActivity2(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2ActivityOptions) error {
	return SomeActivity2Async(ctx, req, options...).Get(ctx)
}

// SomeActivity2 does some activity thing.
func SomeActivity2Async(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2ActivityOptions) *SomeActivity2Future {
	var o *SomeActivity2ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity2ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity2Future{Future: errF}
	}
	activity := SomeActivity2ActivityName
	future := &SomeActivity2Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeActivity2 does some activity thing.
func SomeActivity2Local(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2LocalActivityOptions) error {
	return SomeActivity2LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeActivity2 does some activity thing.
func SomeActivity2LocalAsync(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2LocalActivityOptions) *SomeActivity2Future {
	var o *SomeActivity2LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity2LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity2Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeActivity2ActivityName
	}
	future := &SomeActivity2Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeActivity2ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity2 activity
type SomeActivity2ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeActivity2ActivityOptions initializes a new SomeActivity2ActivityOptions value
func NewSomeActivity2ActivityOptions() *SomeActivity2ActivityOptions {
	return &SomeActivity2ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity2ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumInterval: 30000000000}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	} else if !opts.WaitForCancellation {
		opts.WaitForCancellation = true
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeActivity2ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity2ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeActivity2ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeActivity2ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity2ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity2ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity2ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity2ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeActivity2ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeActivity2ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity2ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity2ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeActivity2ActivityOptions) WithTaskQueue(tq string) *SomeActivity2ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeActivity2ActivityOptions) WithWaitForCancellation(wait bool) *SomeActivity2ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeActivity2LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity2 activity
type SomeActivity2LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeActivity2Request) error
}

// NewSomeActivity2LocalActivityOptions initializes a new SomeActivity2LocalActivityOptions value
func NewSomeActivity2LocalActivityOptions() *SomeActivity2LocalActivityOptions {
	return &SomeActivity2LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity2LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumInterval: 30000000000}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeActivity2 implementation
func (o *SomeActivity2LocalActivityOptions) Local(fn func(context.Context, *SomeActivity2Request) error) *SomeActivity2LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeActivity2LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity2LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity2LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity2LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity2LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity2LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity2LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity2LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeActivity3Activity registers a mycompany.simple.Simple.SomeActivity3 activity
func RegisterSomeActivity3Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeActivity3Request) (*SomeActivity3Response, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity3ActivityName,
	})
}

// SomeActivity3Future describes a(n) mycompany.simple.Simple.SomeActivity3 activity execution
type SomeActivity3Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity3Future) Get(ctx workflow.Context) (*SomeActivity3Response, error) {
	var resp SomeActivity3Response
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity3Future) Select(sel workflow.Selector, fn func(*SomeActivity3Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity3 does some activity thing.
func SomeActivity3(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3ActivityOptions) (*SomeActivity3Response, error) {
	return SomeActivity3Async(ctx, req, options...).Get(ctx)
}

// SomeActivity3 does some activity thing.
func SomeActivity3Async(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3ActivityOptions) *SomeActivity3Future {
	var o *SomeActivity3ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity3ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity3Future{Future: errF}
	}
	activity := SomeActivity3ActivityName
	future := &SomeActivity3Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeActivity3 does some activity thing.
func SomeActivity3Local(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3LocalActivityOptions) (*SomeActivity3Response, error) {
	return SomeActivity3LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeActivity3 does some activity thing.
func SomeActivity3LocalAsync(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3LocalActivityOptions) *SomeActivity3Future {
	var o *SomeActivity3LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity3LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity3Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeActivity3ActivityName
	}
	future := &SomeActivity3Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeActivity3ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity3 activity
type SomeActivity3ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeActivity3ActivityOptions initializes a new SomeActivity3ActivityOptions value
func NewSomeActivity3ActivityOptions() *SomeActivity3ActivityOptions {
	return &SomeActivity3ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity3ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, "some-other-task-queue"); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = "some-other-task-queue"
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeActivity3ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity3ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeActivity3ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeActivity3ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity3ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity3ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity3ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity3ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeActivity3ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeActivity3ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity3ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity3ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeActivity3ActivityOptions) WithTaskQueue(tq string) *SomeActivity3ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeActivity3ActivityOptions) WithWaitForCancellation(wait bool) *SomeActivity3ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeActivity3LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity3 activity
type SomeActivity3LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeActivity3Request) (*SomeActivity3Response, error)
}

// NewSomeActivity3LocalActivityOptions initializes a new SomeActivity3LocalActivityOptions value
func NewSomeActivity3LocalActivityOptions() *SomeActivity3LocalActivityOptions {
	return &SomeActivity3LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity3LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeActivity3 implementation
func (o *SomeActivity3LocalActivityOptions) Local(fn func(context.Context, *SomeActivity3Request) (*SomeActivity3Response, error)) *SomeActivity3LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeActivity3LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity3LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity3LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity3LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity3LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity3LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity3LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity3LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeActivity4Activity registers a mycompany.simple.Simple.SomeActivity4 activity
func RegisterSomeActivity4Activity(r worker.ActivityRegistry, fn func(context.Context) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity4ActivityName,
	})
}

// SomeActivity4Future describes a(n) mycompany.simple.Simple.SomeActivity4 activity execution
type SomeActivity4Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity4Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity4Future) Select(sel workflow.Selector, fn func(*SomeActivity4Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity4 does some activity thing.
func SomeActivity4(ctx workflow.Context, options ...*SomeActivity4ActivityOptions) error {
	return SomeActivity4Async(ctx, options...).Get(ctx)
}

// SomeActivity4 does some activity thing.
func SomeActivity4Async(ctx workflow.Context, options ...*SomeActivity4ActivityOptions) *SomeActivity4Future {
	var o *SomeActivity4ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity4ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity4Future{Future: errF}
	}
	activity := SomeActivity4ActivityName
	future := &SomeActivity4Future{Future: workflow.ExecuteActivity(ctx, activity)}
	return future
}

// SomeActivity4 does some activity thing.
func SomeActivity4Local(ctx workflow.Context, options ...*SomeActivity4LocalActivityOptions) error {
	return SomeActivity4LocalAsync(ctx, options...).Get(ctx)
}

// SomeActivity4 does some activity thing.
func SomeActivity4LocalAsync(ctx workflow.Context, options ...*SomeActivity4LocalActivityOptions) *SomeActivity4Future {
	var o *SomeActivity4LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeActivity4LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeActivity4Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeActivity4ActivityName
	}
	future := &SomeActivity4Future{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future
}

// SomeActivity4ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity4 activity
type SomeActivity4ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeActivity4ActivityOptions initializes a new SomeActivity4ActivityOptions value
func NewSomeActivity4ActivityOptions() *SomeActivity4ActivityOptions {
	return &SomeActivity4ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity4ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	} else if opts.HeartbeatTimeout == 0 {
		opts.HeartbeatTimeout = 30000000000 // 30 seconds
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 300000000000 // 5 minutes
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	} else if opts.ScheduleToStartTimeout == 0 {
		opts.ScheduleToStartTimeout = 5000000000 // 5 seconds
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 60000000000 // 1 minute
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, "some-other-task-queue"); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = "some-other-task-queue"
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	} else if !opts.WaitForCancellation {
		opts.WaitForCancellation = true
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeActivity4ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity4ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeActivity4ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeActivity4ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity4ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity4ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity4ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity4ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeActivity4ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeActivity4ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity4ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity4ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeActivity4ActivityOptions) WithTaskQueue(tq string) *SomeActivity4ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeActivity4ActivityOptions) WithWaitForCancellation(wait bool) *SomeActivity4ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeActivity4LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity4 activity
type SomeActivity4LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context) error
}

// NewSomeActivity4LocalActivityOptions initializes a new SomeActivity4LocalActivityOptions value
func NewSomeActivity4LocalActivityOptions() *SomeActivity4LocalActivityOptions {
	return &SomeActivity4LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeActivity4LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 300000000000 // 5 minutes
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 60000000000 // 1 minute
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeActivity4 implementation
func (o *SomeActivity4LocalActivityOptions) Local(fn func(context.Context) error) *SomeActivity4LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeActivity4LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity4LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeActivity4LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeActivity4LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeActivity4LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeActivity4LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeActivity4LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeActivity4LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeSignal1Activity registers a mycompany.simple.Simple.SomeSignal1 activity
func RegisterSomeSignal1Activity(r worker.ActivityRegistry, fn func(context.Context) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeSignal1ActivityName,
	})
}

// SomeSignal1Future describes a(n) mycompany.simple.Simple.SomeSignal1 activity execution
type SomeSignal1Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeSignal1Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeSignal1Future) Select(sel workflow.Selector, fn func(*SomeSignal1Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeSignal1 is a signal.
func SomeSignal1(ctx workflow.Context, options ...*SomeSignal1ActivityOptions) error {
	return SomeSignal1Async(ctx, options...).Get(ctx)
}

// SomeSignal1 is a signal.
func SomeSignal1Async(ctx workflow.Context, options ...*SomeSignal1ActivityOptions) *SomeSignal1Future {
	var o *SomeSignal1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeSignal1ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeSignal1Future{Future: errF}
	}
	activity := SomeSignal1ActivityName
	future := &SomeSignal1Future{Future: workflow.ExecuteActivity(ctx, activity)}
	return future
}

// SomeSignal1 is a signal.
func SomeSignal1Local(ctx workflow.Context, options ...*SomeSignal1LocalActivityOptions) error {
	return SomeSignal1LocalAsync(ctx, options...).Get(ctx)
}

// SomeSignal1 is a signal.
func SomeSignal1LocalAsync(ctx workflow.Context, options ...*SomeSignal1LocalActivityOptions) *SomeSignal1Future {
	var o *SomeSignal1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeSignal1LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeSignal1Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeSignal1ActivityName
	}
	future := &SomeSignal1Future{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future
}

// SomeSignal1ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeSignal1 activity
type SomeSignal1ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeSignal1ActivityOptions initializes a new SomeSignal1ActivityOptions value
func NewSomeSignal1ActivityOptions() *SomeSignal1ActivityOptions {
	return &SomeSignal1ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeSignal1ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeSignal1ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeSignal1ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeSignal1ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeSignal1ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeSignal1ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeSignal1ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeSignal1ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeSignal1ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeSignal1ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeSignal1ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeSignal1ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeSignal1ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeSignal1ActivityOptions) WithTaskQueue(tq string) *SomeSignal1ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeSignal1ActivityOptions) WithWaitForCancellation(wait bool) *SomeSignal1ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeSignal1LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeSignal1 activity
type SomeSignal1LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context) error
}

// NewSomeSignal1LocalActivityOptions initializes a new SomeSignal1LocalActivityOptions value
func NewSomeSignal1LocalActivityOptions() *SomeSignal1LocalActivityOptions {
	return &SomeSignal1LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeSignal1LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeSignal1 implementation
func (o *SomeSignal1LocalActivityOptions) Local(fn func(context.Context) error) *SomeSignal1LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeSignal1LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeSignal1LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeSignal1LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeSignal1LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeSignal1LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeSignal1LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeSignal1LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeSignal1LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeSignal2Activity registers a mycompany.simple.Simple.SomeSignal2 activity
func RegisterSomeSignal2Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeSignal2Request) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeSignal2ActivityName,
	})
}

// SomeSignal2Future describes a(n) mycompany.simple.Simple.SomeSignal2 activity execution
type SomeSignal2Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeSignal2Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeSignal2Future) Select(sel workflow.Selector, fn func(*SomeSignal2Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeSignal2 is a signal.
func SomeSignal2(ctx workflow.Context, req *SomeSignal2Request, options ...*SomeSignal2ActivityOptions) error {
	return SomeSignal2Async(ctx, req, options...).Get(ctx)
}

// SomeSignal2 is a signal.
func SomeSignal2Async(ctx workflow.Context, req *SomeSignal2Request, options ...*SomeSignal2ActivityOptions) *SomeSignal2Future {
	var o *SomeSignal2ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeSignal2ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeSignal2Future{Future: errF}
	}
	activity := SomeSignal2ActivityName
	future := &SomeSignal2Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeSignal2 is a signal.
func SomeSignal2Local(ctx workflow.Context, req *SomeSignal2Request, options ...*SomeSignal2LocalActivityOptions) error {
	return SomeSignal2LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeSignal2 is a signal.
func SomeSignal2LocalAsync(ctx workflow.Context, req *SomeSignal2Request, options ...*SomeSignal2LocalActivityOptions) *SomeSignal2Future {
	var o *SomeSignal2LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeSignal2LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeSignal2Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeSignal2ActivityName
	}
	future := &SomeSignal2Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeSignal2ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeSignal2 activity
type SomeSignal2ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeSignal2ActivityOptions initializes a new SomeSignal2ActivityOptions value
func NewSomeSignal2ActivityOptions() *SomeSignal2ActivityOptions {
	return &SomeSignal2ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeSignal2ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeSignal2ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeSignal2ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeSignal2ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeSignal2ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeSignal2ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeSignal2ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeSignal2ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeSignal2ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeSignal2ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeSignal2ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeSignal2ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeSignal2ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeSignal2ActivityOptions) WithTaskQueue(tq string) *SomeSignal2ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeSignal2ActivityOptions) WithWaitForCancellation(wait bool) *SomeSignal2ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeSignal2LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeSignal2 activity
type SomeSignal2LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeSignal2Request) error
}

// NewSomeSignal2LocalActivityOptions initializes a new SomeSignal2LocalActivityOptions value
func NewSomeSignal2LocalActivityOptions() *SomeSignal2LocalActivityOptions {
	return &SomeSignal2LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeSignal2LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeSignal2 implementation
func (o *SomeSignal2LocalActivityOptions) Local(fn func(context.Context, *SomeSignal2Request) error) *SomeSignal2LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeSignal2LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeSignal2LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeSignal2LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeSignal2LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeSignal2LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeSignal2LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeSignal2LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeSignal2LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeSignal3Activity registers a mycompany.simple.Simple.SomeSignal3 activity
func RegisterSomeSignal3Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeSignal3Request) (*SomeSignal3Response, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeSignal3ActivityName,
	})
}

// SomeSignal3Future describes a(n) mycompany.simple.Simple.SomeSignal3 activity execution
type SomeSignal3Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeSignal3Future) Get(ctx workflow.Context) (*SomeSignal3Response, error) {
	var resp SomeSignal3Response
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeSignal3Future) Select(sel workflow.Selector, fn func(*SomeSignal3Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeSignal3 is a signal.
func SomeSignal3(ctx workflow.Context, req *SomeSignal3Request, options ...*SomeSignal3ActivityOptions) (*SomeSignal3Response, error) {
	return SomeSignal3Async(ctx, req, options...).Get(ctx)
}

// SomeSignal3 is a signal.
func SomeSignal3Async(ctx workflow.Context, req *SomeSignal3Request, options ...*SomeSignal3ActivityOptions) *SomeSignal3Future {
	var o *SomeSignal3ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeSignal3ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeSignal3Future{Future: errF}
	}
	activity := SomeSignal3ActivityName
	future := &SomeSignal3Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeSignal3 is a signal.
func SomeSignal3Local(ctx workflow.Context, req *SomeSignal3Request, options ...*SomeSignal3LocalActivityOptions) (*SomeSignal3Response, error) {
	return SomeSignal3LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeSignal3 is a signal.
func SomeSignal3LocalAsync(ctx workflow.Context, req *SomeSignal3Request, options ...*SomeSignal3LocalActivityOptions) *SomeSignal3Future {
	var o *SomeSignal3LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeSignal3LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeSignal3Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeSignal3ActivityName
	}
	future := &SomeSignal3Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeSignal3ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeSignal3 activity
type SomeSignal3ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeSignal3ActivityOptions initializes a new SomeSignal3ActivityOptions value
func NewSomeSignal3ActivityOptions() *SomeSignal3ActivityOptions {
	return &SomeSignal3ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeSignal3ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeSignal3ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeSignal3ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeSignal3ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeSignal3ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeSignal3ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeSignal3ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeSignal3ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeSignal3ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeSignal3ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeSignal3ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeSignal3ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeSignal3ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeSignal3ActivityOptions) WithTaskQueue(tq string) *SomeSignal3ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeSignal3ActivityOptions) WithWaitForCancellation(wait bool) *SomeSignal3ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeSignal3LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeSignal3 activity
type SomeSignal3LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeSignal3Request) (*SomeSignal3Response, error)
}

// NewSomeSignal3LocalActivityOptions initializes a new SomeSignal3LocalActivityOptions value
func NewSomeSignal3LocalActivityOptions() *SomeSignal3LocalActivityOptions {
	return &SomeSignal3LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeSignal3LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeSignal3 implementation
func (o *SomeSignal3LocalActivityOptions) Local(fn func(context.Context, *SomeSignal3Request) (*SomeSignal3Response, error)) *SomeSignal3LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeSignal3LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeSignal3LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeSignal3LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeSignal3LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeSignal3LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeSignal3LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeSignal3LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeSignal3LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeUpdate1Activity registers a mycompany.simple.Simple.SomeUpdate1 activity
func RegisterSomeUpdate1Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeUpdate1Request) (*SomeUpdate1Response, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeUpdate1ActivityName,
	})
}

// SomeUpdate1Future describes a(n) mycompany.simple.Simple.SomeUpdate1 activity execution
type SomeUpdate1Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeUpdate1Future) Get(ctx workflow.Context) (*SomeUpdate1Response, error) {
	var resp SomeUpdate1Response
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeUpdate1Future) Select(sel workflow.Selector, fn func(*SomeUpdate1Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1(ctx workflow.Context, req *SomeUpdate1Request, options ...*SomeUpdate1ActivityOptions) (*SomeUpdate1Response, error) {
	return SomeUpdate1Async(ctx, req, options...).Get(ctx)
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1Async(ctx workflow.Context, req *SomeUpdate1Request, options ...*SomeUpdate1ActivityOptions) *SomeUpdate1Future {
	var o *SomeUpdate1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeUpdate1ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeUpdate1Future{Future: errF}
	}
	activity := SomeUpdate1ActivityName
	future := &SomeUpdate1Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1Local(ctx workflow.Context, req *SomeUpdate1Request, options ...*SomeUpdate1LocalActivityOptions) (*SomeUpdate1Response, error) {
	return SomeUpdate1LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeUpdate1 updates a SomeWorkflow2
func SomeUpdate1LocalAsync(ctx workflow.Context, req *SomeUpdate1Request, options ...*SomeUpdate1LocalActivityOptions) *SomeUpdate1Future {
	var o *SomeUpdate1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeUpdate1LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeUpdate1Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeUpdate1ActivityName
	}
	future := &SomeUpdate1Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeUpdate1ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeUpdate1 activity
type SomeUpdate1ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeUpdate1ActivityOptions initializes a new SomeUpdate1ActivityOptions value
func NewSomeUpdate1ActivityOptions() *SomeUpdate1ActivityOptions {
	return &SomeUpdate1ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeUpdate1ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3), NonRetryableErrorTypes: []string{
			"something",
		}}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, SimpleTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = SimpleTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeUpdate1ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeUpdate1ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeUpdate1ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeUpdate1ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeUpdate1ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeUpdate1ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeUpdate1ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeUpdate1ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeUpdate1ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeUpdate1ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeUpdate1ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeUpdate1ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeUpdate1ActivityOptions) WithTaskQueue(tq string) *SomeUpdate1ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeUpdate1ActivityOptions) WithWaitForCancellation(wait bool) *SomeUpdate1ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeUpdate1LocalActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeUpdate1 activity
type SomeUpdate1LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeUpdate1Request) (*SomeUpdate1Response, error)
}

// NewSomeUpdate1LocalActivityOptions initializes a new SomeUpdate1LocalActivityOptions value
func NewSomeUpdate1LocalActivityOptions() *SomeUpdate1LocalActivityOptions {
	return &SomeUpdate1LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeUpdate1LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3), NonRetryableErrorTypes: []string{
			"something",
		}}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Simple.SomeUpdate1 implementation
func (o *SomeUpdate1LocalActivityOptions) Local(fn func(context.Context, *SomeUpdate1Request) (*SomeUpdate1Response, error)) *SomeUpdate1LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeUpdate1LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeUpdate1LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeUpdate1LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeUpdate1LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeUpdate1LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeUpdate1LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeUpdate1LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeUpdate1LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestSimpleClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows SimpleWorkflows
}

var _ SimpleClient = &TestSimpleClient{}

// NewTestSimpleClient initializes a new TestSimpleClient value
func NewTestSimpleClient(env *testsuite.TestWorkflowEnvironment, workflows SimpleWorkflows, activities SimpleActivities) *TestSimpleClient {
	if workflows != nil {
		RegisterSimpleWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterSimpleActivities(env, activities)
	}
	return &TestSimpleClient{env, workflows}
}

// SomeWorkflow1 executes a(n) mycompany.simple.SomeWorkflow1 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow1(ctx context.Context, req *SomeWorkflow1Request, opts ...*SomeWorkflow1Options) (*SomeWorkflow1Response, error) {
	run, err := c.SomeWorkflow1Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow1Async executes a(n) mycompany.simple.SomeWorkflow1 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow1Async(ctx context.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1Options) (SomeWorkflow1Run, error) {
	var o *SomeWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow1Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomeWorkflow1Run{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomeWorkflow1 is a noop
func (c *TestSimpleClient) GetSomeWorkflow1(ctx context.Context, workflowID string, runID string) SomeWorkflow1Run {
	return &testSomeWorkflow1Run{env: c.env, workflows: c.workflows}
}

// SomeWorkflow2 executes a(n) mycompany.simple.SomeWorkflow2 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow2(ctx context.Context, opts ...*SomeWorkflow2Options) error {
	run, err := c.SomeWorkflow2Async(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2Async executes a(n) mycompany.simple.SomeWorkflow2 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow2Async(ctx context.Context, options ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	var o *SomeWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow2Options()
	}
	opts, err := o.Build(nil)
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomeWorkflow2Run{client: c, env: c.env, opts: &opts, workflows: c.workflows}, nil
}

// GetSomeWorkflow2 is a noop
func (c *TestSimpleClient) GetSomeWorkflow2(ctx context.Context, workflowID string, runID string) SomeWorkflow2Run {
	return &testSomeWorkflow2Run{env: c.env, workflows: c.workflows}
}

// SomeWorkflow2WithSomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal to a(n) mycompany.simple.SomeWorkflow2 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow2WithSomeSignal1(ctx context.Context, opts ...*SomeWorkflow2Options) error {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SomeSignal1SignalName, nil)
	}, 0)
	return c.SomeWorkflow2(ctx, opts...)
}

// SomeWorkflow2WithSomeSignal1Async sends a(n) mycompany.simple.Simple.SomeSignal1 signal to a(n) mycompany.simple.SomeWorkflow2 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow2WithSomeSignal1Async(ctx context.Context, opts ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.SomeSignal1(ctx, "", "")
	}, 0)
	return c.SomeWorkflow2Async(ctx, opts...)
}

// SomeWorkflow3 executes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow3(ctx context.Context, req *SomeWorkflow3Request, opts ...*SomeWorkflow3Options) error {
	run, err := c.SomeWorkflow3Async(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3Async executes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow3Async(ctx context.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	var o *SomeWorkflow3Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow3Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomeWorkflow3Run{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomeWorkflow3 is a noop
func (c *TestSimpleClient) GetSomeWorkflow3(ctx context.Context, workflowID string, runID string) SomeWorkflow3Run {
	return &testSomeWorkflow3Run{env: c.env, workflows: c.workflows}
}

// SomeWorkflow3WithSomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow3WithSomeSignal2(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) error {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SomeSignal2SignalName, signal)
	}, 0)
	return c.SomeWorkflow3(ctx, req, opts...)
}

// SomeWorkflow3WithSomeSignal2Async sends a(n) mycompany.simple.Simple.SomeSignal2 signal to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow3WithSomeSignal2Async(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.SomeSignal2(ctx, "", "", signal)
	}, 0)
	return c.SomeWorkflow3Async(ctx, req, opts...)
}

// SomeWorkflow4 executes a(n) mycompany.simple.Simple.SomeWorkflow4 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow4(ctx context.Context, req *v1.PaginatedRequest, opts ...*SomeWorkflow4Options) (*v1.PaginatedResponse, error) {
	run, err := c.SomeWorkflow4Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow4Async executes a(n) mycompany.simple.Simple.SomeWorkflow4 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow4Async(ctx context.Context, req *v1.PaginatedRequest, options ...*SomeWorkflow4Options) (SomeWorkflow4Run, error) {
	var o *SomeWorkflow4Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeWorkflow4Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomeWorkflow4Run{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomeWorkflow4 is a noop
func (c *TestSimpleClient) GetSomeWorkflow4(ctx context.Context, workflowID string, runID string) SomeWorkflow4Run {
	return &testSomeWorkflow4Run{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestSimpleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestSimpleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// SomeQuery1 executes a mycompany.simple.Simple.SomeQuery1 query
func (c *TestSimpleClient) SomeQuery1(ctx context.Context, workflowID string, runID string) (*SomeQuery1Response, error) {
	val, err := c.env.QueryWorkflow(SomeQuery1QueryName)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result SomeQuery1Response
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SomeQuery2 executes a mycompany.simple.Simple.SomeQuery2 query
func (c *TestSimpleClient) SomeQuery2(ctx context.Context, workflowID string, runID string, req *SomeQuery2Request) (*SomeQuery2Response, error) {
	val, err := c.env.QueryWorkflow(SomeQuery2QueryName, req)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result SomeQuery2Response
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SomeSignal1 executes a mycompany.simple.Simple.SomeSignal1 signal
func (c *TestSimpleClient) SomeSignal1(ctx context.Context, workflowID string, runID string) error {
	c.env.SignalWorkflow(SomeSignal1SignalName, nil)
	return nil
}

// SomeSignal2 executes a mycompany.simple.Simple.SomeSignal2 signal
func (c *TestSimpleClient) SomeSignal2(ctx context.Context, workflowID string, runID string, req *SomeSignal2Request) error {
	c.env.SignalWorkflow(SomeSignal2SignalName, req)
	return nil
}

// SomeSignal3 executes a mycompany.simple.Simple.SomeSignal3 signal
func (c *TestSimpleClient) SomeSignal3(ctx context.Context, workflowID string, runID string, req *SomeSignal3Request) error {
	c.env.SignalWorkflow(SomeSignal3SignalName, req)
	return nil
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update in the test environment
func (c *TestSimpleClient) SomeUpdate1(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	options := NewSomeUpdate1Options()
	if len(opts) > 0 && opts[0].Options != nil {
		options = opts[0]
	}
	options.Options.WaitForStage = client.WorkflowUpdateStageCompleted
	handle, err := c.SomeUpdate1Async(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeUpdate1Async executes a(n) mycompany.simple.Simple.SomeUpdate1 update in the test environment
func (c *TestSimpleClient) SomeUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	var o *SomeUpdate1Options
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewSomeUpdate1Options()
	}
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(SomeUpdate1UpdateName, workflowID, uc, req)
	return &testSomeUpdate1Handle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

// GetSomeUpdate1 retrieves a handle to an existing mycompany.simple.Simple.SomeUpdate1 update
func (c *TestSimpleClient) GetSomeUpdate1(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeUpdate1Handle, error) {
	return nil, errors.New("unimplemented")
}

var _ SomeUpdate1Handle = &testSomeUpdate1Handle{}

// testSomeUpdate1Handle provides an internal implementation of a(n) SomeUpdate1Handle
type testSomeUpdate1Handle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowOptions
	req        *SomeUpdate1Request
	runID      string
	workflowID string
}

// Get retrieves a test mycompany.simple.Simple.SomeUpdate1 update result
func (h *testSomeUpdate1Handle) Get(ctx context.Context) (*SomeUpdate1Response, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*SomeUpdate1Response), nil
	}
}

// RunID implementation
func (h *testSomeUpdate1Handle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testSomeUpdate1Handle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testSomeUpdate1Handle) WorkflowID() string {
	return h.workflowID
}

var _ SomeWorkflow1Run = &testSomeWorkflow1Run{}

// testSomeWorkflow1Run provides convenience methods for interacting with a(n) mycompany.simple.SomeWorkflow1 workflow in the test environment
type testSomeWorkflow1Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SomeWorkflow1Request
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow1Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.SomeWorkflow1 workflow result
func (r *testSomeWorkflow1Run) Get(context.Context) (*SomeWorkflow1Response, error) {
	r.env.ExecuteWorkflow(SomeWorkflow1WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result SomeWorkflow1Response
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.simple.SomeWorkflow1 workflow run's workflow ID
func (r *testSomeWorkflow1Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomeWorkflow1Run) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomeWorkflow1Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow1Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeQuery1 executes a mycompany.simple.Simple.SomeQuery1 query against a test mycompany.simple.SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeQuery1(ctx context.Context) (*SomeQuery1Response, error) {
	return r.client.SomeQuery1(ctx, r.ID(), r.RunID())
}

// SomeQuery2 executes a mycompany.simple.Simple.SomeQuery2 query against a test mycompany.simple.SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeQuery2(ctx context.Context, req *SomeQuery2Request) (*SomeQuery2Response, error) {
	return r.client.SomeQuery2(ctx, r.ID(), r.RunID(), req)
}

// SomeSignal1 executes a mycompany.simple.Simple.SomeSignal1 signal against a test mycompany.simple.SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), r.RunID())
}

// SomeSignal2 executes a mycompany.simple.Simple.SomeSignal2 signal against a test mycompany.simple.SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), r.RunID(), req)
}

var _ SomeWorkflow2Run = &testSomeWorkflow2Run{}

// testSomeWorkflow2Run provides convenience methods for interacting with a(n) mycompany.simple.SomeWorkflow2 workflow in the test environment
type testSomeWorkflow2Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow2Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.SomeWorkflow2 workflow result
func (r *testSomeWorkflow2Run) Get(context.Context) error {
	r.env.ExecuteWorkflow(SomeWorkflow2WorkflowName)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test mycompany.simple.SomeWorkflow2 workflow run's workflow ID
func (r *testSomeWorkflow2Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomeWorkflow2Run) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomeWorkflow2Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow2Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal1 executes a mycompany.simple.Simple.SomeSignal1 signal against a test mycompany.simple.SomeWorkflow2 workflow
func (r *testSomeWorkflow2Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), r.RunID())
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update against a test mycompany.simple.SomeWorkflow2 workflow
func (r *testSomeWorkflow2Run) SomeUpdate1(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	return r.client.SomeUpdate1(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeUpdate1Async executes a(n) mycompany.simple.Simple.SomeUpdate1 update against a test mycompany.simple.SomeWorkflow2 workflow
func (r *testSomeWorkflow2Run) SomeUpdate1Async(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	return r.client.SomeUpdate1Async(ctx, r.ID(), r.RunID(), req, opts...)
}

var _ SomeWorkflow3Run = &testSomeWorkflow3Run{}

// testSomeWorkflow3Run provides convenience methods for interacting with a(n) mycompany.simple.Simple.SomeWorkflow3 workflow in the test environment
type testSomeWorkflow3Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SomeWorkflow3Request
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow3Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.Simple.SomeWorkflow3 workflow result
func (r *testSomeWorkflow3Run) Get(context.Context) error {
	r.env.ExecuteWorkflow(SomeWorkflow3WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test mycompany.simple.Simple.SomeWorkflow3 workflow run's workflow ID
func (r *testSomeWorkflow3Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomeWorkflow3Run) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomeWorkflow3Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow3Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal2 executes a mycompany.simple.Simple.SomeSignal2 signal against a test mycompany.simple.Simple.SomeWorkflow3 workflow
func (r *testSomeWorkflow3Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), r.RunID(), req)
}

var _ SomeWorkflow4Run = &testSomeWorkflow4Run{}

// testSomeWorkflow4Run provides convenience methods for interacting with a(n) mycompany.simple.Simple.SomeWorkflow4 workflow in the test environment
type testSomeWorkflow4Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *v1.PaginatedRequest
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow4Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.Simple.SomeWorkflow4 workflow result
func (r *testSomeWorkflow4Run) Get(context.Context) (*v1.PaginatedResponse, error) {
	r.env.ExecuteWorkflow(SomeWorkflow4WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result v1.PaginatedResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.simple.Simple.SomeWorkflow4 workflow run's workflow ID
func (r *testSomeWorkflow4Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomeWorkflow4Run) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomeWorkflow4Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow4Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SimpleCliOptions describes runtime configuration for mycompany.simple.Simple cli
type SimpleCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewSimpleCliOptions initializes a new SimpleCliOptions value
func NewSimpleCliOptions() *SimpleCliOptions {
	return &SimpleCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *SimpleCliOptions) WithAfter(fn func(*v2.Context) error) *SimpleCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *SimpleCliOptions) WithBefore(fn func(*v2.Context) error) *SimpleCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *SimpleCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *SimpleCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *SimpleCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *SimpleCliOptions {
	opts.worker = fn
	return opts
}

// NewSimpleCli initializes a cli for a(n) mycompany.simple.Simple service
func NewSimpleCli(options ...*SimpleCliOptions) (*v2.App, error) {
	commands, err := newSimpleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "simple",
		Commands: commands,
	}, nil
}

// NewSimpleCliCommand initializes a cli command for a mycompany.simple.Simple service with subcommands for each query, signal, update, and workflow
func NewSimpleCliCommand(options ...*SimpleCliOptions) (*v2.Command, error) {
	subcommands, err := newSimpleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "simple",
		Subcommands: subcommands,
	}, nil
}

// newSimpleCommands initializes (sub)commands for a mycompany.simple.Simple cli or command
func newSimpleCommands(options ...*SimpleCliOptions) ([]*v2.Command, error) {
	opts := &SimpleCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "some-query-1",
			Usage:                  "SomeQuery1 queries some thing.",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				if resp, err := client.SomeQuery1(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", SomeQuery1QueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-query-2",
			Usage:                  "SomeQuery2 queries some thing.",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := UnmarshalCliFlagsToSomeQuery2Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if resp, err := client.SomeQuery2(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error executing %q query: %w", SomeQuery2QueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-signal-1",
			Usage:                  "SomeSignal1 is a signal.",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				if err := client.SomeSignal1(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeSignal1SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "some-signal-2",
			Usage:                  "SomeSignal2 is a signal.",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := UnmarshalCliFlagsToSomeSignal2Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SomeSignal2(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeSignal2SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "some-signal-3",
			Usage:                  "SomeSignal3 is a signal.",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := UnmarshalCliFlagsToSomeSignal3Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SomeSignal3(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeSignal3SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "some-update-1",
			Usage:                  "SomeUpdate1 updates a SomeWorkflow2",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and udpate id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := UnmarshalCliFlagsToSomeUpdate1Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.SomeUpdate1Async(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", SomeUpdate1UpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-workflow-1",
			Usage:                  "SomeWorkflow1 does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "my-task-queue",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "id",
					Usage:    "set the value of the operation's \"Id\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewSimpleClient(tc)
				req, err := UnmarshalCliFlagsToSomeWorkflow1Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomeWorkflow1Async(cmd.Context, req, NewSomeWorkflow1Options().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow1WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-workflow-2",
			Usage:                  "SomeWorkflow2 does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "my-task-queue",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewSimpleClient(tc)
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomeWorkflow2Async(cmd.Context, NewSomeWorkflow2Options().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow2WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// sends a mycompany.simple.Simple.SomeSignal1 signal to a mycompany.simple.Simple.SomeWorkflow2 workflow, starting it if necessary,
		{
			Name:                   "some-workflow-2-with-some-signal-1",
			Usage:                  "sends a mycompany.simple.Simple.SomeSignal1 signal to a mycompany.simple.Simple.SomeWorkflow2 workflow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				run, err := client.SomeWorkflow2WithSomeSignal1Async(cmd.Context)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", SomeWorkflow2WorkflowName, SomeSignal1SignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		{
			Name:                   "some-workflow-3",
			Usage:                  "SomeWorkflow3 does some workflow thing. Deprecated: Use SomeWorkflow2 instead.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "my-task-queue",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "id",
					Usage:    "set the value of the operation's \"Id\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewSimpleClient(tc)
				req, err := UnmarshalCliFlagsToSomeWorkflow3Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomeWorkflow3Async(cmd.Context, req, NewSomeWorkflow3Options().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow3WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// sends a mycompany.simple.Simple.SomeSignal2 signal to a mycompany.simple.Simple.SomeWorkflow3 workflow, starting it if necessary,
		{
			Name:                   "some-workflow-3-with-some-signal-2",
			Usage:                  "sends a mycompany.simple.Simple.SomeSignal2 signal to a mycompany.simple.Simple.SomeWorkflow3 workflow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "id",
					Usage:    "set the value of the operation's \"Id\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "some-signal-2-request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "SIGNAL",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := UnmarshalCliFlagsToSomeWorkflow3Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := UnmarshalCliFlagsToSomeSignal2Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.SomeWorkflow3WithSomeSignal2Async(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", SomeWorkflow3WorkflowName, SomeSignal2SignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		{
			Name:                   "some-workflow-4",
			Usage:                  "SomeWorkflow4 retrieves a paginated list of items",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "my-task-queue",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.Uint64Flag{
					Name:     "limit",
					Usage:    "set the value of the operation's \"Limit\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "cursor",
					Usage:    "set the value of the operation's \"Cursor\" parameter (base64-encoded)",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewSimpleClient(tc)
				req, err := UnmarshalCliFlagsToPaginatedRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomeWorkflow4Async(cmd.Context, req, NewSomeWorkflow4Options().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow4WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.simple.Simple worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToSomeQuery2Request unmarshals a SomeQuery2Request from command line flags
func UnmarshalCliFlagsToSomeQuery2Request(cmd *v2.Context) (*SomeQuery2Request, error) {
	var result SomeQuery2Request
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomeSignal2Request unmarshals a SomeSignal2Request from command line flags
func UnmarshalCliFlagsToSomeSignal2Request(cmd *v2.Context) (*SomeSignal2Request, error) {
	var result SomeSignal2Request
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomeSignal3Request unmarshals a SomeSignal3Request from command line flags
func UnmarshalCliFlagsToSomeSignal3Request(cmd *v2.Context) (*SomeSignal3Request, error) {
	var result SomeSignal3Request
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomeUpdate1Request unmarshals a SomeUpdate1Request from command line flags
func UnmarshalCliFlagsToSomeUpdate1Request(cmd *v2.Context) (*SomeUpdate1Request, error) {
	var result SomeUpdate1Request
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomeWorkflow1Request unmarshals a SomeWorkflow1Request from command line flags
func UnmarshalCliFlagsToSomeWorkflow1Request(cmd *v2.Context) (*SomeWorkflow1Request, error) {
	var result SomeWorkflow1Request
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if cmd.IsSet("id") {
		hasValues = true
		result.Id = cmd.String("id")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomeWorkflow3Request unmarshals a SomeWorkflow3Request from command line flags
func UnmarshalCliFlagsToSomeWorkflow3Request(cmd *v2.Context) (*SomeWorkflow3Request, error) {
	var result SomeWorkflow3Request
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("id") {
		hasValues = true
		result.Id = cmd.String("id")
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToPaginatedRequest unmarshals a PaginatedRequest from command line flags
func UnmarshalCliFlagsToPaginatedRequest(cmd *v2.Context) (*v1.PaginatedRequest, error) {
	var result v1.PaginatedRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("limit") {
		hasValues = true
		result.Limit = uint32(cmd.Uint64("limit"))
	}
	if cmd.IsSet("cursor") {
		hasValues = true
		v, err := base64.StdEncoding.DecodeString(cmd.String("cursor"))
		if err != nil {
			return nil, fmt.Errorf("error base64-decoding \"cursor\" flag: %w", err)
		}
		result.Cursor = v
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithSimpleSchemeTypes registers all Simple protobuf types with the given scheme
func WithSimpleSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeActivity2Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeActivity3Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeActivity3Response"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeSignal2Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeSignal3Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeSignal3Response"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeUpdate1Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeUpdate1Response"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeQuery1Response"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeQuery2Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeQuery2Response"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeWorkflow1Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeWorkflow1Response"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeWorkflow3Request"))
	}
}

// OtherTaskQueue is the default task-queue for a mycompany.simple.Other worker
const OtherTaskQueue = "other-task-queue"

// mycompany.simple.Other workflow names
const (
	OtherWorkflowWorkflowName = "mycompany.simple.Other.OtherWorkflow"
)

// mycompany.simple.Other workflow id expressions
var (
	OtherWorkflowIdexpression = expression.MustParseExpression("other-workflow/${!uuid_v4()}")
)

// mycompany.simple.Other activity names
const (
	OtherWorkflowActivityName = "mycompany.simple.Other.OtherWorkflow"
)

// mycompany.simple.Other query names
const (
	OtherQueryQueryName = "mycompany.simple.Other.OtherQuery"
)

// mycompany.simple.Other signal names
const (
	OtherSignalSignalName = "mycompany.simple.Other.OtherSignal"
)

// mycompany.simple.Other update names
const (
	OtherUpdateUpdateName = "mycompany.simple.Other.OtherUpdate"
)

// mycompany.simple.Other update id expressions
var (
	OtherUpdateIdexpression = expression.MustParseExpression("other-update/${!uuid_v4()}")
)

// OtherClient describes a client for a(n) mycompany.simple.Other worker
type OtherClient interface {
	// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
	OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest, opts ...*OtherWorkflowOptions) (*OtherWorkflowResponse, error)

	// OtherWorkflowAsync starts a(n) mycompany.simple.Other.OtherWorkflow workflow and returns a handle to the workflow run
	OtherWorkflowAsync(ctx context.Context, req *OtherWorkflowRequest, opts ...*OtherWorkflowOptions) (OtherWorkflowRun, error)

	// GetOtherWorkflow retrieves a handle to an existing mycompany.simple.Other.OtherWorkflow workflow execution
	GetOtherWorkflow(ctx context.Context, workflowID string, runID string) OtherWorkflowRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// mycompany.simple.Other.OtherQuery executes a(n) mycompany.simple.Other.OtherQuery query
	OtherQuery(ctx context.Context, workflowID string, runID string) (*OtherQueryResponse, error)

	// mycompany.simple.Other.OtherSignal sends a(n) mycompany.simple.Other.OtherSignal signal
	OtherSignal(ctx context.Context, workflowID string, runID string, signal *OtherSignalRequest) error

	// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until update completion
	OtherUpdate(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (*OtherUpdateResponse, error)

	// OtherUpdateAsync starts a(n) mycompany.simple.Other.OtherUpdate update and returns a handle to the workflow update
	OtherUpdateAsync(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (OtherUpdateHandle, error)

	// GetOtherUpdate retrieves a handle to an existing mycompany.simple.Other.OtherUpdate update
	GetOtherUpdate(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (OtherUpdateHandle, error)
}

// otherClient implements a temporal client for a mycompany.simple.Other service
type otherClient struct {
	client client.Client
	log    *slog.Logger
}

// NewOtherClient initializes a new mycompany.simple.Other client
func NewOtherClient(c client.Client, options ...*otherClientOptions) OtherClient {
	var cfg *otherClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewOtherClientOptions()
	}
	return &otherClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewOtherClientWithOptions initializes a new Other client with the given options
func NewOtherClientWithOptions(c client.Client, opts client.Options, options ...*otherClientOptions) (OtherClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *otherClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewOtherClientOptions()
	}
	return &otherClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// otherClientOptions describes optional runtime configuration for a OtherClient
type otherClientOptions struct {
	log *slog.Logger
}

// NewOtherClientOptions initializes a new otherClientOptions value
func NewOtherClientOptions() *otherClientOptions {
	return &otherClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *otherClientOptions) WithLogger(l *slog.Logger) *otherClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *otherClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// mycompany.simple.Other.OtherWorkflow executes a mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
func (c *otherClient) OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowOptions) (*OtherWorkflowResponse, error) {
	run, err := c.OtherWorkflowAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflowAsync starts a(n) mycompany.simple.Other.OtherWorkflow workflow and returns a handle to the workflow run
func (c *otherClient) OtherWorkflowAsync(ctx context.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowOptions) (OtherWorkflowRun, error) {
	var o *OtherWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewOtherWorkflowOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, OtherWorkflowWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &otherWorkflowRun{
		client: c,
		run:    run,
	}, nil
}

// GetOtherWorkflow fetches an existing mycompany.simple.Other.OtherWorkflow execution
func (c *otherClient) GetOtherWorkflow(ctx context.Context, workflowID string, runID string) OtherWorkflowRun {
	return &otherWorkflowRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *otherClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *otherClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// mycompany.simple.Other.OtherQuery sends a(n) mycompany.simple.Other.OtherQuery query to an existing workflow
func (c *otherClient) OtherQuery(ctx context.Context, workflowID string, runID string) (*OtherQueryResponse, error) {
	var resp OtherQueryResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, OtherQueryQueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// mycompany.simple.Other.OtherSignal sends a(n) mycompany.simple.Other.OtherSignal signal to an existing workflow
func (c *otherClient) OtherSignal(ctx context.Context, workflowID string, runID string, signal *OtherSignalRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, OtherSignalSignalName, signal)
}

// mycompany.simple.Other.OtherUpdate sends a(n) mycompany.simple.Other.OtherUpdate update to an existing workflow
func (c *otherClient) OtherUpdate(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (*OtherUpdateResponse, error) {
	// initialize update options
	o := NewOtherUpdateOptions()
	if len(opts) > 0 && opts[0].Options != nil {
		o = opts[0]
	}

	// call sync update with WorkflowUpdateStageCompleted wait policy
	handle, err := c.OtherUpdateAsync(ctx, workflowID, runID, req, o.WithWaitPolicy(client.WorkflowUpdateStageCompleted))
	if err != nil {
		return nil, err
	}

	// block on update completion
	return handle.Get(ctx)
}

// mycompany.simple.Other.OtherUpdate sends a(n) mycompany.simple.Other.OtherUpdate update to an existing workflow
func (c *otherClient) OtherUpdateAsync(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (OtherUpdateHandle, error) {
	// initialize update options
	var o *OtherUpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewOtherUpdateOptions()
	}

	// build UpdateWorkflowOptions
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	// update workflow
	handle, err := c.client.UpdateWorkflow(ctx, *options)
	if err != nil {
		return nil, err
	}
	return &otherUpdateHandle{client: c, handle: handle}, nil
}

// GetOtherUpdate retrieves a handle to an existing mycompany.simple.Other.OtherUpdate update
func (c *otherClient) GetOtherUpdate(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (OtherUpdateHandle, error) {
	return &otherUpdateHandle{
		client: c,
		handle: c.client.GetWorkflowUpdateHandle(req),
	}, nil
}

// OtherWorkflowOptions provides configuration for a mycompany.simple.Other.OtherWorkflow workflow operation
type OtherWorkflowOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewOtherWorkflowOptions initializes a new OtherWorkflowOptions value
func NewOtherWorkflowOptions() *OtherWorkflowOptions {
	return &OtherWorkflowOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *OtherWorkflowOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(OtherWorkflowIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", OtherWorkflowWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = OtherTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *OtherWorkflowOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *OtherWorkflowOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *OtherWorkflowOptions) WithExecutionTimeout(d time.Duration) *OtherWorkflowOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *OtherWorkflowOptions) WithID(id string) *OtherWorkflowOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *OtherWorkflowOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *OtherWorkflowOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *OtherWorkflowOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *OtherWorkflowOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *OtherWorkflowOptions) WithRunTimeout(d time.Duration) *OtherWorkflowOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *OtherWorkflowOptions) WithSearchAttributes(sa map[string]any) *OtherWorkflowOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *OtherWorkflowOptions) WithTaskTimeout(d time.Duration) *OtherWorkflowOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *OtherWorkflowOptions) WithTaskQueue(tq string) *OtherWorkflowOptions {
	o.taskQueue = &tq
	return o
}

// OtherWorkflowRun describes a(n) mycompany.simple.Other.OtherWorkflow workflow run
type OtherWorkflowRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*OtherWorkflowResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// otherWorkflowRun provides an internal implementation of a(n) OtherWorkflowRunRun
type otherWorkflowRun struct {
	client *otherClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *otherWorkflowRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *otherWorkflowRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *otherWorkflowRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *otherWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *otherWorkflowRun) Get(ctx context.Context) (*OtherWorkflowResponse, error) {
	var resp OtherWorkflowResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *otherWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// OtherUpdateHandle describes a(n) mycompany.simple.Other.OtherUpdate update handle
type OtherUpdateHandle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*OtherUpdateResponse, error)
}

// otherUpdateHandle provides an internal implementation of a(n) OtherUpdateHandle
type otherUpdateHandle struct {
	client *otherClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *otherUpdateHandle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *otherUpdateHandle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *otherUpdateHandle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *otherUpdateHandle) Get(ctx context.Context) (*OtherUpdateResponse, error) {
	var resp OtherUpdateResponse
	var err error
	doneCh := make(chan struct{})
	gctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			var deadlineExceeded *serviceerror.DeadlineExceeded
			if err = h.handle.Get(gctx, &resp); err != nil && ctx.Err() == nil && (errors.As(err, &deadlineExceeded) || strings.Contains(err.Error(), context.DeadlineExceeded.Error())) {
				continue
			}
			break
		}
		close(doneCh)
	}()

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-doneCh:
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}
}

// OtherUpdateOptions provides configuration for a mycompany.simple.Other.OtherUpdate update operation
type OtherUpdateOptions struct {
	Options    *client.UpdateWorkflowOptions
	id         *string
	waitPolicy client.WorkflowUpdateStage
}

// NewOtherUpdateOptions initializes a new OtherUpdateOptions value
func NewOtherUpdateOptions() *OtherUpdateOptions {
	return &OtherUpdateOptions{Options: &client.UpdateWorkflowOptions{}}
}

// Build initializes a new client.UpdateWorkflowOptions with defaults and overrides applied
func (o *OtherUpdateOptions) Build(workflowID string, runID string, req *OtherUpdateRequest) (opts *client.UpdateWorkflowOptions, err error) {
	// use user-provided UpdateWorkflowOptions if exists
	if o.Options != nil {
		opts = o.Options
	} else {
		opts = &client.UpdateWorkflowOptions{}
	}

	// set constants
	opts.Args = []any{req}
	opts.RunID = runID
	opts.UpdateName = OtherUpdateUpdateName
	opts.WorkflowID = workflowID

	// set UpdateID
	if v := o.id; v != nil {
		opts.UpdateID = *v
	} else if opts.UpdateID == "" {
		id, err := expression.EvalExpression(OtherUpdateIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for %q update: %w", OtherUpdateUpdateName, err)
		}
		opts.UpdateID = id
	}

	// set WaitPolicy
	if v := o.waitPolicy; v != client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = v
	} else if opts.WaitForStage == client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = client.WorkflowUpdateStageCompleted
	}
	return opts, nil
}

// WithUpdateID sets the UpdateID
func (o *OtherUpdateOptions) WithUpdateID(id string) *OtherUpdateOptions {
	o.id = &id
	return o
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowOptions
func (o *OtherUpdateOptions) WithUpdateWorkflowOptions(options client.UpdateWorkflowOptions) *OtherUpdateOptions {
	o.Options = &options
	return o
}

// WithWaitPolicy sets the WaitPolicy
func (o *OtherUpdateOptions) WithWaitPolicy(policy client.WorkflowUpdateStage) *OtherUpdateOptions {
	o.waitPolicy = policy
	return o
}

// Reference to generated workflow functions
var (
	// OtherWorkflowFunction implements a "mycompany.simple.Other.OtherWorkflow" workflow
	OtherWorkflowFunction func(workflow.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
)

// OtherWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// OtherWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	OtherWorkflowFunctions interface {
		// OtherWorkflow executes a "mycompany.simple.Other.OtherWorkflow" workflow inline
		OtherWorkflow(workflow.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
	}
	// otherWorkflowFunctions provides an internal OtherWorkflowFunctions implementation
	otherWorkflowFunctions struct{}
)

func NewOtherWorkflowFunctions() OtherWorkflowFunctions {
	return &otherWorkflowFunctions{}
}

// OtherWorkflow executes a "mycompany.simple.Other.OtherWorkflow" workflow inline
func (f *otherWorkflowFunctions) OtherWorkflow(ctx workflow.Context, req *OtherWorkflowRequest) (*OtherWorkflowResponse, error) {
	if OtherWorkflowFunction == nil {
		return nil, errors.New("OtherWorkflow requires workflow registration via RegisterOtherWorkflows or RegisterOtherWorkflowWorkflow")
	}
	return OtherWorkflowFunction(ctx, req)
}

// OtherWorkflows provides methods for initializing new mycompany.simple.Other workflow values
type OtherWorkflows interface {
	// OtherWorkflow initializes a new a(n) OtherWorkflowWorkflow implementation
	OtherWorkflow(ctx workflow.Context, input *OtherWorkflowWorkflowInput) (OtherWorkflowWorkflow, error)
}

// RegisterOtherWorkflows registers mycompany.simple.Other workflows with the given worker
func RegisterOtherWorkflows(r worker.WorkflowRegistry, workflows OtherWorkflows) {
	RegisterOtherWorkflowWorkflow(r, workflows.OtherWorkflow)
}

// RegisterOtherWorkflowWorkflow registers a mycompany.simple.Other.OtherWorkflow workflow with the given worker
func RegisterOtherWorkflowWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *OtherWorkflowWorkflowInput) (OtherWorkflowWorkflow, error)) {
	OtherWorkflowFunction = buildOtherWorkflow(wf)
	r.RegisterWorkflowWithOptions(OtherWorkflowFunction, workflow.RegisterOptions{Name: OtherWorkflowWorkflowName})
}

// buildOtherWorkflow converts a OtherWorkflow workflow struct into a valid workflow function
func buildOtherWorkflow(ctor func(workflow.Context, *OtherWorkflowWorkflowInput) (OtherWorkflowWorkflow, error)) func(workflow.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error) {
	return func(ctx workflow.Context, req *OtherWorkflowRequest) (*OtherWorkflowResponse, error) {
		input := &OtherWorkflowWorkflowInput{
			Req: req,
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, OtherTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// OtherWorkflowWorkflowInput describes the input to a(n) mycompany.simple.Other.OtherWorkflow workflow constructor
type OtherWorkflowWorkflowInput struct {
	Req *OtherWorkflowRequest
}

// OtherWorkflowWorkflow describes a(n) mycompany.simple.Other.OtherWorkflow workflow implementation
//
// workflow details: (id: "other-workflow/${!uuid_v4()}")
type OtherWorkflowWorkflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Other.OtherWorkflow workflow
	Execute(ctx workflow.Context) (*OtherWorkflowResponse, error)
}

// OtherWorkflowChild executes a child mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
func OtherWorkflowChild(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowChildOptions) (*OtherWorkflowResponse, error) {
	childRun, err := OtherWorkflowChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// OtherWorkflowChildAsync starts a child mycompany.simple.Other.OtherWorkflow workflow and returns a handle to the child workflow run
func OtherWorkflowChildAsync(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowChildOptions) (*OtherWorkflowChildRun, error) {
	var o *OtherWorkflowChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewOtherWorkflowChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &OtherWorkflowChildRun{Future: workflow.ExecuteChildWorkflow(ctx, OtherWorkflowWorkflowName, req)}, nil
}

// OtherWorkflowChildOptions provides configuration for a child mycompany.simple.Other.OtherWorkflow workflow operation
type OtherWorkflowChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewOtherWorkflowChildOptions initializes a new OtherWorkflowChildOptions value
func NewOtherWorkflowChildOptions() *OtherWorkflowChildOptions {
	return &OtherWorkflowChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *OtherWorkflowChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", 1, 1)
		lao := workflow.GetLocalActivityOptions(ctx)
		lao.ScheduleToCloseTimeout = time.Second * 10
		if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
			id, err := expression.EvalExpression(OtherWorkflowIdexpression, req)
			if err != nil {
				return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", OtherWorkflowWorkflowName, err)
			}
			return id, nil
		}).Get(ctx, &opts.WorkflowID); err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", OtherWorkflowWorkflowName, err)
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, OtherTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = OtherTaskQueue
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *OtherWorkflowChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *OtherWorkflowChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *OtherWorkflowChildOptions) WithExecutionTimeout(d time.Duration) *OtherWorkflowChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *OtherWorkflowChildOptions) WithID(id string) *OtherWorkflowChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *OtherWorkflowChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *OtherWorkflowChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *OtherWorkflowChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *OtherWorkflowChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *OtherWorkflowChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *OtherWorkflowChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *OtherWorkflowChildOptions) WithRunTimeout(d time.Duration) *OtherWorkflowChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *OtherWorkflowChildOptions) WithSearchAttributes(sa map[string]any) *OtherWorkflowChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *OtherWorkflowChildOptions) WithTaskTimeout(d time.Duration) *OtherWorkflowChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *OtherWorkflowChildOptions) WithTaskQueue(tq string) *OtherWorkflowChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *OtherWorkflowChildOptions) WithWaitForCancellation(wait bool) *OtherWorkflowChildOptions {
	o.waitForCancellation = &wait
	return o
}

// OtherWorkflowChildRun describes a child OtherWorkflow workflow run
type OtherWorkflowChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *OtherWorkflowChildRun) Get(ctx workflow.Context) (*OtherWorkflowResponse, error) {
	var resp OtherWorkflowResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *OtherWorkflowChildRun) Select(sel workflow.Selector, fn func(*OtherWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *OtherWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(*OtherWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *OtherWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// OtherSignalSignal describes a(n) mycompany.simple.Other.OtherSignal signal
type OtherSignalSignal struct {
	Channel workflow.ReceiveChannel
}

// NewOtherSignalSignal initializes a new mycompany.simple.Other.OtherSignal signal wrapper
func NewOtherSignalSignal(ctx workflow.Context) *OtherSignalSignal {
	return &OtherSignalSignal{Channel: workflow.GetSignalChannel(ctx, OtherSignalSignalName)}
}

// Receive blocks until a(n) mycompany.simple.Other.OtherSignal signal is received
func (s *OtherSignalSignal) Receive(ctx workflow.Context) (*OtherSignalRequest, bool) {
	var resp OtherSignalRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Other.OtherSignal signal without blocking
func (s *OtherSignalSignal) ReceiveAsync() *OtherSignalRequest {
	var resp OtherSignalRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) mycompany.simple.Other.OtherSignal signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *OtherSignalSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *OtherSignalRequest, ok bool, more bool) {
	resp = &OtherSignalRequest{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) mycompany.simple.Other.OtherSignal signal without blocking
func (s *OtherSignalSignal) Select(sel workflow.Selector, fn func(*OtherSignalRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// OtherSignalExternal sends a(n) mycompany.simple.Other.OtherSignal signal to an existing workflow
func OtherSignalExternal(ctx workflow.Context, workflowID string, runID string, req *OtherSignalRequest) error {
	return OtherSignalExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// OtherSignalExternalAsync sends a(n) mycompany.simple.Other.OtherSignal signal to an existing workflow
func OtherSignalExternalAsync(ctx workflow.Context, workflowID string, runID string, req *OtherSignalRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, OtherSignalSignalName, req)
}

// OtherActivities describes available worker activities
type OtherActivities interface {
	// mycompany.simple.Other.OtherWorkflow implements a(n) mycompany.simple.Other.OtherWorkflow activity definition
	OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
}

// RegisterOtherActivities registers activities with a worker
func RegisterOtherActivities(r worker.ActivityRegistry, activities OtherActivities) {
	RegisterOtherWorkflowActivity(r, activities.OtherWorkflow)
}

// RegisterOtherWorkflowActivity registers a mycompany.simple.Other.OtherWorkflow activity
func RegisterOtherWorkflowActivity(r worker.ActivityRegistry, fn func(context.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: OtherWorkflowActivityName,
	})
}

// OtherWorkflowFuture describes a(n) mycompany.simple.Other.OtherWorkflow activity execution
type OtherWorkflowFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *OtherWorkflowFuture) Get(ctx workflow.Context) (*OtherWorkflowResponse, error) {
	var resp OtherWorkflowResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *OtherWorkflowFuture) Select(sel workflow.Selector, fn func(*OtherWorkflowFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow activity
func OtherWorkflow(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowActivityOptions) (*OtherWorkflowResponse, error) {
	return OtherWorkflowAsync(ctx, req, options...).Get(ctx)
}

// OtherWorkflowAsync executes a(n) mycompany.simple.Other.OtherWorkflow activity (asynchronously)
func OtherWorkflowAsync(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowActivityOptions) *OtherWorkflowFuture {
	var o *OtherWorkflowActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewOtherWorkflowActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &OtherWorkflowFuture{Future: errF}
	}
	activity := OtherWorkflowActivityName
	future := &OtherWorkflowFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// OtherWorkflowLocal executes a(n) mycompany.simple.Other.OtherWorkflow activity (locally)
func OtherWorkflowLocal(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowLocalActivityOptions) (*OtherWorkflowResponse, error) {
	return OtherWorkflowLocalAsync(ctx, req, options...).Get(ctx)
}

// OtherWorkflowLocalAsync executes a(n) mycompany.simple.Other.OtherWorkflow activity (asynchronously, locally)
func OtherWorkflowLocalAsync(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowLocalActivityOptions) *OtherWorkflowFuture {
	var o *OtherWorkflowLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewOtherWorkflowLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &OtherWorkflowFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = OtherWorkflowActivityName
	}
	future := &OtherWorkflowFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// OtherWorkflowActivityOptions provides configuration for a(n) mycompany.simple.Other.OtherWorkflow activity
type OtherWorkflowActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewOtherWorkflowActivityOptions initializes a new OtherWorkflowActivityOptions value
func NewOtherWorkflowActivityOptions() *OtherWorkflowActivityOptions {
	return &OtherWorkflowActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *OtherWorkflowActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, OtherTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = OtherTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *OtherWorkflowActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *OtherWorkflowActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *OtherWorkflowActivityOptions) WithHeartbeatTimeout(d time.Duration) *OtherWorkflowActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *OtherWorkflowActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *OtherWorkflowActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *OtherWorkflowActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *OtherWorkflowActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *OtherWorkflowActivityOptions) WithScheduleToStartTimeout(d time.Duration) *OtherWorkflowActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *OtherWorkflowActivityOptions) WithStartToCloseTimeout(d time.Duration) *OtherWorkflowActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *OtherWorkflowActivityOptions) WithTaskQueue(tq string) *OtherWorkflowActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *OtherWorkflowActivityOptions) WithWaitForCancellation(wait bool) *OtherWorkflowActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// OtherWorkflowLocalActivityOptions provides configuration for a(n) mycompany.simple.Other.OtherWorkflow activity
type OtherWorkflowLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
}

// NewOtherWorkflowLocalActivityOptions initializes a new OtherWorkflowLocalActivityOptions value
func NewOtherWorkflowLocalActivityOptions() *OtherWorkflowLocalActivityOptions {
	return &OtherWorkflowLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *OtherWorkflowLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Other.OtherWorkflow implementation
func (o *OtherWorkflowLocalActivityOptions) Local(fn func(context.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)) *OtherWorkflowLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *OtherWorkflowLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *OtherWorkflowLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *OtherWorkflowLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *OtherWorkflowLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *OtherWorkflowLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *OtherWorkflowLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *OtherWorkflowLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *OtherWorkflowLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestOtherClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows OtherWorkflows
}

var _ OtherClient = &TestOtherClient{}

// NewTestOtherClient initializes a new TestOtherClient value
func NewTestOtherClient(env *testsuite.TestWorkflowEnvironment, workflows OtherWorkflows, activities OtherActivities) *TestOtherClient {
	if workflows != nil {
		RegisterOtherWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterOtherActivities(env, activities)
	}
	return &TestOtherClient{env, workflows}
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow in the test environment
func (c *TestOtherClient) OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest, opts ...*OtherWorkflowOptions) (*OtherWorkflowResponse, error) {
	run, err := c.OtherWorkflowAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflowAsync executes a(n) mycompany.simple.Other.OtherWorkflow workflow in the test environment
func (c *TestOtherClient) OtherWorkflowAsync(ctx context.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowOptions) (OtherWorkflowRun, error) {
	var o *OtherWorkflowOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewOtherWorkflowOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testOtherWorkflowRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetOtherWorkflow is a noop
func (c *TestOtherClient) GetOtherWorkflow(ctx context.Context, workflowID string, runID string) OtherWorkflowRun {
	return &testOtherWorkflowRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestOtherClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestOtherClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// OtherQuery executes a mycompany.simple.Other.OtherQuery query
func (c *TestOtherClient) OtherQuery(ctx context.Context, workflowID string, runID string) (*OtherQueryResponse, error) {
	val, err := c.env.QueryWorkflow(OtherQueryQueryName)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result OtherQueryResponse
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// OtherSignal executes a mycompany.simple.Other.OtherSignal signal
func (c *TestOtherClient) OtherSignal(ctx context.Context, workflowID string, runID string, req *OtherSignalRequest) error {
	c.env.SignalWorkflow(OtherSignalSignalName, req)
	return nil
}

// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update in the test environment
func (c *TestOtherClient) OtherUpdate(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (*OtherUpdateResponse, error) {
	options := NewOtherUpdateOptions()
	if len(opts) > 0 && opts[0].Options != nil {
		options = opts[0]
	}
	options.Options.WaitForStage = client.WorkflowUpdateStageCompleted
	handle, err := c.OtherUpdateAsync(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// OtherUpdateAsync executes a(n) mycompany.simple.Other.OtherUpdate update in the test environment
func (c *TestOtherClient) OtherUpdateAsync(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (OtherUpdateHandle, error) {
	var o *OtherUpdateOptions
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewOtherUpdateOptions()
	}
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(OtherUpdateUpdateName, workflowID, uc, req)
	return &testOtherUpdateHandle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

// GetOtherUpdate retrieves a handle to an existing mycompany.simple.Other.OtherUpdate update
func (c *TestOtherClient) GetOtherUpdate(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (OtherUpdateHandle, error) {
	return nil, errors.New("unimplemented")
}

var _ OtherUpdateHandle = &testOtherUpdateHandle{}

// testOtherUpdateHandle provides an internal implementation of a(n) OtherUpdateHandle
type testOtherUpdateHandle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowOptions
	req        *OtherUpdateRequest
	runID      string
	workflowID string
}

// Get retrieves a test mycompany.simple.Other.OtherUpdate update result
func (h *testOtherUpdateHandle) Get(ctx context.Context) (*OtherUpdateResponse, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*OtherUpdateResponse), nil
	}
}

// RunID implementation
func (h *testOtherUpdateHandle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testOtherUpdateHandle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testOtherUpdateHandle) WorkflowID() string {
	return h.workflowID
}

var _ OtherWorkflowRun = &testOtherWorkflowRun{}

// testOtherWorkflowRun provides convenience methods for interacting with a(n) mycompany.simple.Other.OtherWorkflow workflow in the test environment
type testOtherWorkflowRun struct {
	client    *TestOtherClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *OtherWorkflowRequest
	workflows OtherWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testOtherWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.Other.OtherWorkflow workflow result
func (r *testOtherWorkflowRun) Get(context.Context) (*OtherWorkflowResponse, error) {
	r.env.ExecuteWorkflow(OtherWorkflowWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result OtherWorkflowResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.simple.Other.OtherWorkflow workflow run's workflow ID
func (r *testOtherWorkflowRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testOtherWorkflowRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testOtherWorkflowRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testOtherWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// OtherCliOptions describes runtime configuration for mycompany.simple.Other cli
type OtherCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewOtherCliOptions initializes a new OtherCliOptions value
func NewOtherCliOptions() *OtherCliOptions {
	return &OtherCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *OtherCliOptions) WithAfter(fn func(*v2.Context) error) *OtherCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *OtherCliOptions) WithBefore(fn func(*v2.Context) error) *OtherCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *OtherCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *OtherCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *OtherCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *OtherCliOptions {
	opts.worker = fn
	return opts
}

// NewOtherCli initializes a cli for a(n) mycompany.simple.Other service
func NewOtherCli(options ...*OtherCliOptions) (*v2.App, error) {
	commands, err := newOtherCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "other",
		Commands: commands,
	}, nil
}

// NewOtherCliCommand initializes a cli command for a mycompany.simple.Other service with subcommands for each query, signal, update, and workflow
func NewOtherCliCommand(options ...*OtherCliOptions) (*v2.Command, error) {
	subcommands, err := newOtherCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "other",
		Subcommands: subcommands,
	}, nil
}

// newOtherCommands initializes (sub)commands for a mycompany.simple.Other cli or command
func newOtherCommands(options ...*OtherCliOptions) ([]*v2.Command, error) {
	opts := &OtherCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "other-query",
			Usage:                  "executes a mycompany.simple.Other.OtherQuery query and blocks until error or response received",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewOtherClient(c)
				if resp, err := client.OtherQuery(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", OtherQueryQueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "other-update",
			Usage:                  "executes a(n) mycompany.simple.Other.OtherUpdate update",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and udpate id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "mode",
					Usage:    "set the value of the operation's \"Mode\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewOtherClient(c)
				req, err := UnmarshalCliFlagsToOtherUpdateRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.OtherUpdateAsync(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", OtherUpdateUpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "other-workflow",
			Usage:                  "executes a(n) mycompany.simple.Other.OtherWorkflow workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "other-task-queue",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "some-val",
					Usage:    "set the value of the operation's \"SomeVal\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "baz",
					Usage:    "set the value of the operation's \"Baz\" parameter (json-encoded: {baz: <string>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "qux",
					Usage:    "set the value of the operation's \"Qux\" parameter (json-encoded: {qux: <string>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "foo",
					Usage:    "set the value of the operation's \"Foo\" parameter (json-encoded: {foo: <string>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "bar",
					Usage:    "set the value of the operation's \"Bar\" parameter (json-encoded: {bar: <string>})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "example-bytes",
					Usage:    "set the value of the operation's \"ExampleBytes\" parameter (base64-encoded)",
					Category: "INPUT",
				},
				&v2.Float64Flag{
					Name:     "example-double",
					Usage:    "set the value of the operation's \"ExampleDouble\" parameter",
					Category: "INPUT",
				},
				&v2.Float64Flag{
					Name:     "example-float",
					Usage:    "set the value of the operation's \"ExampleFloat\" parameter",
					Category: "INPUT",
				},
				&v2.Int64Flag{
					Name:     "example-int-32",
					Usage:    "set the value of the operation's \"ExampleInt32\" parameter",
					Category: "INPUT",
				},
				&v2.Int64Flag{
					Name:     "example-int-64",
					Usage:    "set the value of the operation's \"ExampleInt64\" parameter",
					Category: "INPUT",
				},
				&v2.Uint64Flag{
					Name:     "example-uint-32",
					Usage:    "set the value of the operation's \"ExampleUint32\" parameter",
					Category: "INPUT",
				},
				&v2.Uint64Flag{
					Name:     "example-uint-64",
					Usage:    "set the value of the operation's \"ExampleUint64\" parameter",
					Category: "INPUT",
				},
				&v2.Int64Flag{
					Name:     "example-sint-32",
					Usage:    "set the value of the operation's \"ExampleSint32\" parameter",
					Category: "INPUT",
				},
				&v2.Int64Flag{
					Name:     "example-sint-64",
					Usage:    "set the value of the operation's \"ExampleSint64\" parameter",
					Category: "INPUT",
				},
				&v2.Uint64Flag{
					Name:     "example-fixed-32",
					Usage:    "set the value of the operation's \"ExampleFixed32\" parameter",
					Category: "INPUT",
				},
				&v2.Uint64Flag{
					Name:     "example-fixed-64",
					Usage:    "set the value of the operation's \"ExampleFixed64\" parameter",
					Category: "INPUT",
				},
				&v2.Int64Flag{
					Name:     "example-sfixed-32",
					Usage:    "set the value of the operation's \"ExampleSfixed32\" parameter",
					Category: "INPUT",
				},
				&v2.Int64Flag{
					Name:     "example-sfixed-64",
					Usage:    "set the value of the operation's \"ExampleSfixed64\" parameter",
					Category: "INPUT",
				},
				&v2.BoolFlag{
					Name:     "example-bool",
					Usage:    "set the value of the operation's \"ExampleBool\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "quux",
					Usage:    "set the value of the operation's \"Quux\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "example-duration",
					Usage:    "set the value of the operation's \"ExampleDuration\" parameter (e.g. \"3.000000001s\")",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "example-empty",
					Usage:    "set the value of the operation's \"ExampleEmpty\" parameter (json-encoded: {})",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "example-timestamp",
					Usage:    "set the value of the operation's \"ExampleTimestamp\" parameter (e.g. \"2017-01-15T01:30:15.01Z\")",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "example-enum",
					Usage:    "set the value of the operation's \"ExampleEnum\" parameter (OTHER_UNSPECIFIED, OTHER_FOO, OTHER_BAR)",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "common-enum",
					Usage:    "set the value of the operation's \"CommonEnum\" parameter (EXAMPLE_UNSPECIFIED, EXAMPLE_FOO)",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewOtherClient(tc)
				req, err := UnmarshalCliFlagsToOtherWorkflowRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.OtherWorkflowAsync(cmd.Context, req, NewOtherWorkflowOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", OtherWorkflowWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.simple.Other worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToOtherUpdateRequest unmarshals a OtherUpdateRequest from command line flags
func UnmarshalCliFlagsToOtherUpdateRequest(cmd *v2.Context) (*OtherUpdateRequest, error) {
	var result OtherUpdateRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("mode") {
		hasValues = true
		result.Mode = cmd.String("mode")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToOtherWorkflowRequest unmarshals a OtherWorkflowRequest from command line flags
func UnmarshalCliFlagsToOtherWorkflowRequest(cmd *v2.Context) (*OtherWorkflowRequest, error) {
	var result OtherWorkflowRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("some-val") {
		hasValues = true
		result.SomeVal = cmd.String("some-val")
	}
	if cmd.IsSet("baz") {
		hasValues = true
		var v OtherWorkflowRequest_Baz
		if err := protojson.Unmarshal([]byte(cmd.String("baz")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"baz\" flag: %w", err)
		}
		result.Baz = &v
	}
	if cmd.IsSet("qux") {
		hasValues = true
		var v Qux
		if err := protojson.Unmarshal([]byte(cmd.String("qux")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"qux\" flag: %w", err)
		}
		result.Qux = &v
	}
	if cmd.IsSet("foo") {
		hasValues = true
		var v Foo
		if err := protojson.Unmarshal([]byte(cmd.String("foo")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"foo\" flag: %w", err)
		}
		result.ExampleOneof = &OtherWorkflowRequest_Foo{Foo: &v}
	}
	if cmd.IsSet("bar") {
		hasValues = true
		var v OtherWorkflowRequest_Bar
		if err := protojson.Unmarshal([]byte(cmd.String("bar")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"bar\" flag: %w", err)
		}
		result.ExampleOneof = &OtherWorkflowRequest_Bar_{Bar: &v}
	}
	if cmd.IsSet("example-bytes") {
		hasValues = true
		v, err := base64.StdEncoding.DecodeString(cmd.String("example-bytes"))
		if err != nil {
			return nil, fmt.Errorf("error base64-decoding \"example-bytes\" flag: %w", err)
		}
		result.ExampleOneof = &OtherWorkflowRequest_ExampleBytes{ExampleBytes: v}
	}
	if cmd.IsSet("example-double") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleDouble{ExampleDouble: cmd.Float64("example-double")}
	}
	if cmd.IsSet("example-float") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleFloat{ExampleFloat: float32(cmd.Float64("example-float"))}
	}
	if cmd.IsSet("example-int-32") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleInt32{ExampleInt32: int32(cmd.Int64("example-int-32"))}
	}
	if cmd.IsSet("example-int-64") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleInt64{ExampleInt64: cmd.Int64("example-int-64")}
	}
	if cmd.IsSet("example-uint-32") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleUint32{ExampleUint32: uint32(cmd.Uint64("example-uint-32"))}
	}
	if cmd.IsSet("example-uint-64") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleUint64{ExampleUint64: cmd.Uint64("example-uint-64")}
	}
	if cmd.IsSet("example-sint-32") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleSint32{ExampleSint32: int32(cmd.Int64("example-sint-32"))}
	}
	if cmd.IsSet("example-sint-64") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleSint64{ExampleSint64: cmd.Int64("example-sint-64")}
	}
	if cmd.IsSet("example-fixed-32") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleFixed32{ExampleFixed32: uint32(cmd.Uint64("example-fixed-32"))}
	}
	if cmd.IsSet("example-fixed-64") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleFixed64{ExampleFixed64: cmd.Uint64("example-fixed-64")}
	}
	if cmd.IsSet("example-sfixed-32") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleSfixed32{ExampleSfixed32: int32(cmd.Int64("example-sfixed-32"))}
	}
	if cmd.IsSet("example-sfixed-64") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleSfixed64{ExampleSfixed64: cmd.Int64("example-sfixed-64")}
	}
	if cmd.IsSet("example-bool") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_ExampleBool{ExampleBool: cmd.Bool("example-bool")}
	}
	if cmd.IsSet("quux") {
		hasValues = true
		result.ExampleOneof = &OtherWorkflowRequest_Quux{Quux: cmd.String("quux")}
	}
	if cmd.IsSet("example-duration") {
		hasValues = true
		v, err := time.ParseDuration(cmd.String("example-duration"))
		if err != nil {
			return nil, fmt.Errorf("error unmarshalling \"example-duration\" duration flag: %w", err)
		}
		result.ExampleOneof = &OtherWorkflowRequest_ExampleDuration{ExampleDuration: durationpb.New(v)}
	}
	if cmd.IsSet("example-empty") {
		hasValues = true
	}
	if cmd.IsSet("example-timestamp") {
		hasValues = true
		v, err := time.Parse(time.RFC3339Nano, cmd.String("example-timestamp"))
		if err != nil {
			return nil, fmt.Errorf("error unmarshalling \"example-timestamp\" timestamp flag: %w", err)
		}
		result.ExampleOneof = &OtherWorkflowRequest_ExampleTimestamp{ExampleTimestamp: timestamppb.New(v)}
	}
	if cmd.IsSet("example-enum") {
		hasValues = true
		v, ok := OtherEnum_value[cmd.String("example-enum")]
		if !ok {
			return nil, fmt.Errorf("unsupported enum value for \"example-enum\" flag: %q", cmd.String("example-enum"))
		}
		result.ExampleOneof = &OtherWorkflowRequest_ExampleEnum{ExampleEnum: OtherEnum(v)}
	}
	if cmd.IsSet("common-enum") {
		hasValues = true
		v, ok := v1.Example_value[cmd.String("common-enum")]
		if !ok {
			return nil, fmt.Errorf("unsupported enum value for \"common-enum\" flag: %q", cmd.String("common-enum"))
		}
		result.ExampleOneof = &OtherWorkflowRequest_CommonEnum{CommonEnum: v1.Example(v)}
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithOtherSchemeTypes registers all Other protobuf types with the given scheme
func WithOtherSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherWorkflowRequest"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherWorkflowRequest").Messages().ByName("Bar"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherWorkflowRequest").Messages().ByName("Baz"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherWorkflowResponse"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherQueryResponse"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherSignalRequest"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherUpdateRequest"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("OtherUpdateResponse"))
	}
}

// mycompany.simple.Ignored workflow names
const (
	WhatWorkflowName = "mycompany.simple.Ignored.What"
)

// mycompany.simple.Ignored workflow id expressions
var (
	WhatIdexpression = expression.MustParseExpression("what/${!ksuid()}")
)

// IgnoredClient describes a client for a(n) mycompany.simple.Ignored worker
type IgnoredClient interface {
	// What executes a(n) mycompany.simple.Ignored.What workflow and blocks until error or response received
	What(ctx context.Context, req *WhatRequest, opts ...*WhatOptions) error

	// WhatAsync starts a(n) mycompany.simple.Ignored.What workflow and returns a handle to the workflow run
	WhatAsync(ctx context.Context, req *WhatRequest, opts ...*WhatOptions) (WhatRun, error)

	// GetWhat retrieves a handle to an existing mycompany.simple.Ignored.What workflow execution
	GetWhat(ctx context.Context, workflowID string, runID string) WhatRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// ignoredClient implements a temporal client for a mycompany.simple.Ignored service
type ignoredClient struct {
	client client.Client
	log    *slog.Logger
}

// NewIgnoredClient initializes a new mycompany.simple.Ignored client
func NewIgnoredClient(c client.Client, options ...*ignoredClientOptions) IgnoredClient {
	var cfg *ignoredClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewIgnoredClientOptions()
	}
	return &ignoredClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewIgnoredClientWithOptions initializes a new Ignored client with the given options
func NewIgnoredClientWithOptions(c client.Client, opts client.Options, options ...*ignoredClientOptions) (IgnoredClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *ignoredClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewIgnoredClientOptions()
	}
	return &ignoredClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// ignoredClientOptions describes optional runtime configuration for a IgnoredClient
type ignoredClientOptions struct {
	log *slog.Logger
}

// NewIgnoredClientOptions initializes a new ignoredClientOptions value
func NewIgnoredClientOptions() *ignoredClientOptions {
	return &ignoredClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *ignoredClientOptions) WithLogger(l *slog.Logger) *ignoredClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *ignoredClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// mycompany.simple.Ignored.What executes a mycompany.simple.Ignored.What workflow and blocks until error or response received
func (c *ignoredClient) What(ctx context.Context, req *WhatRequest, options ...*WhatOptions) error {
	run, err := c.WhatAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// WhatAsync starts a(n) mycompany.simple.Ignored.What workflow and returns a handle to the workflow run
func (c *ignoredClient) WhatAsync(ctx context.Context, req *WhatRequest, options ...*WhatOptions) (WhatRun, error) {
	var o *WhatOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewWhatOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, WhatWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &whatRun{
		client: c,
		run:    run,
	}, nil
}

// GetWhat fetches an existing mycompany.simple.Ignored.What execution
func (c *ignoredClient) GetWhat(ctx context.Context, workflowID string, runID string) WhatRun {
	return &whatRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *ignoredClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *ignoredClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// WhatOptions provides configuration for a mycompany.simple.Ignored.What workflow operation
type WhatOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewWhatOptions initializes a new WhatOptions value
func NewWhatOptions() *WhatOptions {
	return &WhatOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *WhatOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(WhatIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", WhatWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *WhatOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *WhatOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *WhatOptions) WithExecutionTimeout(d time.Duration) *WhatOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *WhatOptions) WithID(id string) *WhatOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *WhatOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *WhatOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *WhatOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *WhatOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *WhatOptions) WithRunTimeout(d time.Duration) *WhatOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *WhatOptions) WithSearchAttributes(sa map[string]any) *WhatOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *WhatOptions) WithTaskTimeout(d time.Duration) *WhatOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *WhatOptions) WithTaskQueue(tq string) *WhatOptions {
	o.taskQueue = &tq
	return o
}

// WhatRun describes a(n) mycompany.simple.Ignored.What workflow run
type WhatRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// whatRun provides an internal implementation of a(n) WhatRunRun
type whatRun struct {
	client *ignoredClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *whatRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *whatRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *whatRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *whatRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *whatRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *whatRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// WhatFunction implements a "mycompany.simple.Ignored.What" workflow
	WhatFunction func(workflow.Context, *WhatRequest) error
)

// IgnoredWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// IgnoredWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	IgnoredWorkflowFunctions interface {
		// What executes a "mycompany.simple.Ignored.What" workflow inline
		What(workflow.Context, *WhatRequest) error
	}
	// ignoredWorkflowFunctions provides an internal IgnoredWorkflowFunctions implementation
	ignoredWorkflowFunctions struct{}
)

func NewIgnoredWorkflowFunctions() IgnoredWorkflowFunctions {
	return &ignoredWorkflowFunctions{}
}

// What executes a "mycompany.simple.Ignored.What" workflow inline
func (f *ignoredWorkflowFunctions) What(ctx workflow.Context, req *WhatRequest) error {
	if WhatFunction == nil {
		return errors.New("What requires workflow registration via RegisterIgnoredWorkflows or RegisterWhatWorkflow")
	}
	return WhatFunction(ctx, req)
}

// IgnoredWorkflows provides methods for initializing new mycompany.simple.Ignored workflow values
type IgnoredWorkflows interface {
	// What initializes a new a(n) WhatWorkflow implementation
	What(ctx workflow.Context, input *WhatWorkflowInput) (WhatWorkflow, error)
}

// RegisterIgnoredWorkflows registers mycompany.simple.Ignored workflows with the given worker
func RegisterIgnoredWorkflows(r worker.WorkflowRegistry, workflows IgnoredWorkflows) {
	RegisterWhatWorkflow(r, workflows.What)
}

// RegisterWhatWorkflow registers a mycompany.simple.Ignored.What workflow with the given worker
func RegisterWhatWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *WhatWorkflowInput) (WhatWorkflow, error)) {
	WhatFunction = buildWhat(wf)
	r.RegisterWorkflowWithOptions(WhatFunction, workflow.RegisterOptions{Name: WhatWorkflowName})
}

// buildWhat converts a What workflow struct into a valid workflow function
func buildWhat(ctor func(workflow.Context, *WhatWorkflowInput) (WhatWorkflow, error)) func(workflow.Context, *WhatRequest) error {
	return func(ctx workflow.Context, req *WhatRequest) error {
		input := &WhatWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// WhatWorkflowInput describes the input to a(n) mycompany.simple.Ignored.What workflow constructor
type WhatWorkflowInput struct {
	Req *WhatRequest
}

// WhatWorkflow describes a(n) mycompany.simple.Ignored.What workflow implementation
//
// workflow details: (id: "what/${!ksuid()}")
type WhatWorkflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Ignored.What workflow
	Execute(ctx workflow.Context) error
}

// WhatChild executes a child mycompany.simple.Ignored.What workflow and blocks until error or response received
func WhatChild(ctx workflow.Context, req *WhatRequest, options ...*WhatChildOptions) error {
	childRun, err := WhatChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// WhatChildAsync starts a child mycompany.simple.Ignored.What workflow and returns a handle to the child workflow run
func WhatChildAsync(ctx workflow.Context, req *WhatRequest, options ...*WhatChildOptions) (*WhatChildRun, error) {
	var o *WhatChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewWhatChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &WhatChildRun{Future: workflow.ExecuteChildWorkflow(ctx, WhatWorkflowName, req)}, nil
}

// WhatChildOptions provides configuration for a child mycompany.simple.Ignored.What workflow operation
type WhatChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewWhatChildOptions initializes a new WhatChildOptions value
func NewWhatChildOptions() *WhatChildOptions {
	return &WhatChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *WhatChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(WhatIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", WhatWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", WhatWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(WhatIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", WhatWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
		} else {
			opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *WhatChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *WhatChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *WhatChildOptions) WithExecutionTimeout(d time.Duration) *WhatChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *WhatChildOptions) WithID(id string) *WhatChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *WhatChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *WhatChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *WhatChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *WhatChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *WhatChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *WhatChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *WhatChildOptions) WithRunTimeout(d time.Duration) *WhatChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *WhatChildOptions) WithSearchAttributes(sa map[string]any) *WhatChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *WhatChildOptions) WithTaskTimeout(d time.Duration) *WhatChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *WhatChildOptions) WithTaskQueue(tq string) *WhatChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *WhatChildOptions) WithWaitForCancellation(wait bool) *WhatChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WhatChildRun describes a child What workflow run
type WhatChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *WhatChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *WhatChildRun) Select(sel workflow.Selector, fn func(*WhatChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *WhatChildRun) SelectStart(sel workflow.Selector, fn func(*WhatChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *WhatChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// IgnoredActivities describes available worker activities
type IgnoredActivities interface{}

// RegisterIgnoredActivities registers activities with a worker
func RegisterIgnoredActivities(r worker.ActivityRegistry, activities IgnoredActivities) {}

// TestClient provides a testsuite-compatible Client
type TestIgnoredClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows IgnoredWorkflows
}

var _ IgnoredClient = &TestIgnoredClient{}

// NewTestIgnoredClient initializes a new TestIgnoredClient value
func NewTestIgnoredClient(env *testsuite.TestWorkflowEnvironment, workflows IgnoredWorkflows, activities IgnoredActivities) *TestIgnoredClient {
	if workflows != nil {
		RegisterIgnoredWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterIgnoredActivities(env, activities)
	}
	return &TestIgnoredClient{env, workflows}
}

// What executes a(n) mycompany.simple.Ignored.What workflow in the test environment
func (c *TestIgnoredClient) What(ctx context.Context, req *WhatRequest, opts ...*WhatOptions) error {
	run, err := c.WhatAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// WhatAsync executes a(n) mycompany.simple.Ignored.What workflow in the test environment
func (c *TestIgnoredClient) WhatAsync(ctx context.Context, req *WhatRequest, options ...*WhatOptions) (WhatRun, error) {
	var o *WhatOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewWhatOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testWhatRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetWhat is a noop
func (c *TestIgnoredClient) GetWhat(ctx context.Context, workflowID string, runID string) WhatRun {
	return &testWhatRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestIgnoredClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestIgnoredClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ WhatRun = &testWhatRun{}

// testWhatRun provides convenience methods for interacting with a(n) mycompany.simple.Ignored.What workflow in the test environment
type testWhatRun struct {
	client    *TestIgnoredClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *WhatRequest
	workflows IgnoredWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testWhatRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.Ignored.What workflow result
func (r *testWhatRun) Get(context.Context) error {
	r.env.ExecuteWorkflow(WhatWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test mycompany.simple.Ignored.What workflow run's workflow ID
func (r *testWhatRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testWhatRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testWhatRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testWhatRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// WithIgnoredSchemeTypes registers all Ignored protobuf types with the given scheme
func WithIgnoredSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("WhatRequest"))
	}
}

// mycompany.simple.OnlyActivities activity names
const (
	LonelyActivity1ActivityName = "mycompany.simple.OnlyActivities.LonelyActivity1"
)

// OnlyActivitiesClient describes a client for a(n) mycompany.simple.OnlyActivities worker
type OnlyActivitiesClient interface {
	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// onlyActivitiesClient implements a temporal client for a mycompany.simple.OnlyActivities service
type onlyActivitiesClient struct {
	client client.Client
	log    *slog.Logger
}

// NewOnlyActivitiesClient initializes a new mycompany.simple.OnlyActivities client
func NewOnlyActivitiesClient(c client.Client, options ...*onlyActivitiesClientOptions) OnlyActivitiesClient {
	var cfg *onlyActivitiesClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewOnlyActivitiesClientOptions()
	}
	return &onlyActivitiesClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewOnlyActivitiesClientWithOptions initializes a new OnlyActivities client with the given options
func NewOnlyActivitiesClientWithOptions(c client.Client, opts client.Options, options ...*onlyActivitiesClientOptions) (OnlyActivitiesClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *onlyActivitiesClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewOnlyActivitiesClientOptions()
	}
	return &onlyActivitiesClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// onlyActivitiesClientOptions describes optional runtime configuration for a OnlyActivitiesClient
type onlyActivitiesClientOptions struct {
	log *slog.Logger
}

// NewOnlyActivitiesClientOptions initializes a new onlyActivitiesClientOptions value
func NewOnlyActivitiesClientOptions() *onlyActivitiesClientOptions {
	return &onlyActivitiesClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *onlyActivitiesClientOptions) WithLogger(l *slog.Logger) *onlyActivitiesClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *onlyActivitiesClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *onlyActivitiesClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *onlyActivitiesClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// Reference to generated workflow functions
var ()

// OnlyActivitiesWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// OnlyActivitiesWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	OnlyActivitiesWorkflowFunctions interface{}
	// onlyActivitiesWorkflowFunctions provides an internal OnlyActivitiesWorkflowFunctions implementation
	onlyActivitiesWorkflowFunctions struct{}
)

func NewOnlyActivitiesWorkflowFunctions() OnlyActivitiesWorkflowFunctions {
	return &onlyActivitiesWorkflowFunctions{}
}

// OnlyActivitiesWorkflows provides methods for initializing new mycompany.simple.OnlyActivities workflow values
type OnlyActivitiesWorkflows interface{}

// RegisterOnlyActivitiesWorkflows registers mycompany.simple.OnlyActivities workflows with the given worker
func RegisterOnlyActivitiesWorkflows(r worker.WorkflowRegistry, workflows OnlyActivitiesWorkflows) {}

// OnlyActivitiesActivities describes available worker activities
type OnlyActivitiesActivities interface {
	// mycompany.simple.OnlyActivities.LonelyActivity1 implements a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity definition
	LonelyActivity1(ctx context.Context, req *LonelyActivity1Request) (*LonelyActivity1Response, error)
}

// RegisterOnlyActivitiesActivities registers activities with a worker
func RegisterOnlyActivitiesActivities(r worker.ActivityRegistry, activities OnlyActivitiesActivities) {
	RegisterLonelyActivity1Activity(r, activities.LonelyActivity1)
}

// RegisterLonelyActivity1Activity registers a mycompany.simple.OnlyActivities.LonelyActivity1 activity
func RegisterLonelyActivity1Activity(r worker.ActivityRegistry, fn func(context.Context, *LonelyActivity1Request) (*LonelyActivity1Response, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: LonelyActivity1ActivityName,
	})
}

// LonelyActivity1Future describes a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity execution
type LonelyActivity1Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *LonelyActivity1Future) Get(ctx workflow.Context) (*LonelyActivity1Response, error) {
	var resp LonelyActivity1Response
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *LonelyActivity1Future) Select(sel workflow.Selector, fn func(*LonelyActivity1Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// LonelyActivity1 executes a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity
func LonelyActivity1(ctx workflow.Context, req *LonelyActivity1Request, options ...*LonelyActivity1ActivityOptions) (*LonelyActivity1Response, error) {
	return LonelyActivity1Async(ctx, req, options...).Get(ctx)
}

// LonelyActivity1Async executes a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity (asynchronously)
func LonelyActivity1Async(ctx workflow.Context, req *LonelyActivity1Request, options ...*LonelyActivity1ActivityOptions) *LonelyActivity1Future {
	var o *LonelyActivity1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewLonelyActivity1ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &LonelyActivity1Future{Future: errF}
	}
	activity := LonelyActivity1ActivityName
	future := &LonelyActivity1Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// LonelyActivity1Local executes a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity (locally)
func LonelyActivity1Local(ctx workflow.Context, req *LonelyActivity1Request, options ...*LonelyActivity1LocalActivityOptions) (*LonelyActivity1Response, error) {
	return LonelyActivity1LocalAsync(ctx, req, options...).Get(ctx)
}

// LonelyActivity1LocalAsync executes a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity (asynchronously, locally)
func LonelyActivity1LocalAsync(ctx workflow.Context, req *LonelyActivity1Request, options ...*LonelyActivity1LocalActivityOptions) *LonelyActivity1Future {
	var o *LonelyActivity1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewLonelyActivity1LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &LonelyActivity1Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = LonelyActivity1ActivityName
	}
	future := &LonelyActivity1Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// LonelyActivity1ActivityOptions provides configuration for a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity
type LonelyActivity1ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewLonelyActivity1ActivityOptions initializes a new LonelyActivity1ActivityOptions value
func NewLonelyActivity1ActivityOptions() *LonelyActivity1ActivityOptions {
	return &LonelyActivity1ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *LonelyActivity1ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
		} else {
			opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *LonelyActivity1ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *LonelyActivity1ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *LonelyActivity1ActivityOptions) WithHeartbeatTimeout(d time.Duration) *LonelyActivity1ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *LonelyActivity1ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *LonelyActivity1ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *LonelyActivity1ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *LonelyActivity1ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *LonelyActivity1ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *LonelyActivity1ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *LonelyActivity1ActivityOptions) WithStartToCloseTimeout(d time.Duration) *LonelyActivity1ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *LonelyActivity1ActivityOptions) WithTaskQueue(tq string) *LonelyActivity1ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *LonelyActivity1ActivityOptions) WithWaitForCancellation(wait bool) *LonelyActivity1ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// LonelyActivity1LocalActivityOptions provides configuration for a(n) mycompany.simple.OnlyActivities.LonelyActivity1 activity
type LonelyActivity1LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *LonelyActivity1Request) (*LonelyActivity1Response, error)
}

// NewLonelyActivity1LocalActivityOptions initializes a new LonelyActivity1LocalActivityOptions value
func NewLonelyActivity1LocalActivityOptions() *LonelyActivity1LocalActivityOptions {
	return &LonelyActivity1LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *LonelyActivity1LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.OnlyActivities.LonelyActivity1 implementation
func (o *LonelyActivity1LocalActivityOptions) Local(fn func(context.Context, *LonelyActivity1Request) (*LonelyActivity1Response, error)) *LonelyActivity1LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *LonelyActivity1LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *LonelyActivity1LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *LonelyActivity1LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *LonelyActivity1LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *LonelyActivity1LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *LonelyActivity1LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *LonelyActivity1LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *LonelyActivity1LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestOnlyActivitiesClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows OnlyActivitiesWorkflows
}

var _ OnlyActivitiesClient = &TestOnlyActivitiesClient{}

// NewTestOnlyActivitiesClient initializes a new TestOnlyActivitiesClient value
func NewTestOnlyActivitiesClient(env *testsuite.TestWorkflowEnvironment, workflows OnlyActivitiesWorkflows, activities OnlyActivitiesActivities) *TestOnlyActivitiesClient {
	if workflows != nil {
		RegisterOnlyActivitiesWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterOnlyActivitiesActivities(env, activities)
	}
	return &TestOnlyActivitiesClient{env, workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestOnlyActivitiesClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestOnlyActivitiesClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// OnlyActivitiesCliOptions describes runtime configuration for mycompany.simple.OnlyActivities cli
type OnlyActivitiesCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewOnlyActivitiesCliOptions initializes a new OnlyActivitiesCliOptions value
func NewOnlyActivitiesCliOptions() *OnlyActivitiesCliOptions {
	return &OnlyActivitiesCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *OnlyActivitiesCliOptions) WithAfter(fn func(*v2.Context) error) *OnlyActivitiesCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *OnlyActivitiesCliOptions) WithBefore(fn func(*v2.Context) error) *OnlyActivitiesCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *OnlyActivitiesCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *OnlyActivitiesCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *OnlyActivitiesCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *OnlyActivitiesCliOptions {
	opts.worker = fn
	return opts
}

// NewOnlyActivitiesCli initializes a cli for a(n) mycompany.simple.OnlyActivities service
func NewOnlyActivitiesCli(options ...*OnlyActivitiesCliOptions) (*v2.App, error) {
	commands, err := newOnlyActivitiesCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "only-activities",
		Commands: commands,
	}, nil
}

// NewOnlyActivitiesCliCommand initializes a cli command for a mycompany.simple.OnlyActivities service with subcommands for each query, signal, update, and workflow
func NewOnlyActivitiesCliCommand(options ...*OnlyActivitiesCliOptions) (*v2.Command, error) {
	subcommands, err := newOnlyActivitiesCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "only-activities",
		Subcommands: subcommands,
	}, nil
}

// newOnlyActivitiesCommands initializes (sub)commands for a mycompany.simple.OnlyActivities cli or command
func newOnlyActivitiesCommands(options ...*OnlyActivitiesCliOptions) ([]*v2.Command, error) {
	opts := &OnlyActivitiesCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.simple.OnlyActivities worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// WithOnlyActivitiesSchemeTypes registers all OnlyActivities protobuf types with the given scheme
func WithOnlyActivitiesSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("LonelyActivity1Request"))
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("LonelyActivity1Response"))
	}
}

// mycompany.simple.Deprecated workflow names
const (
	SomeDeprecatedWorkflow1WorkflowName = "mycompany.simple.Deprecated.SomeDeprecatedWorkflow1"
	SomeDeprecatedWorkflow2WorkflowName = "mycompany.simple.Deprecated.SomeDeprecatedWorkflow2"
)

// mycompany.simple.Deprecated activity names
const (
	SomeDeprecatedActivity1ActivityName = "mycompany.simple.Deprecated.SomeDeprecatedActivity1"
	SomeDeprecatedActivity2ActivityName = "mycompany.simple.Deprecated.SomeDeprecatedActivity2"
)

// mycompany.simple.Deprecated query names
const (
	SomeDeprecatedQuery1QueryName = "mycompany.simple.Deprecated.SomeDeprecatedQuery1"
	SomeDeprecatedQuery2QueryName = "mycompany.simple.Deprecated.SomeDeprecatedQuery2"
)

// mycompany.simple.Deprecated signal names
const (
	SomeDeprecatedSignal1SignalName = "mycompany.simple.Deprecated.SomeDeprecatedSignal1"
	SomeDeprecatedSignal2SignalName = "mycompany.simple.Deprecated.SomeDeprecatedSignal2"
)

// mycompany.simple.Deprecated update names
const (
	SomeDeprecatedUpdate1UpdateName = "mycompany.simple.Deprecated.SomeDeprecatedUpdate1"
	SomeDeprecatedUpdate2UpdateName = "mycompany.simple.Deprecated.SomeDeprecatedUpdate2"
)

// DeprecatedClient describes a client for a(n) mycompany.simple.Deprecated worker
type DeprecatedClient interface {
	// SomeDeprecatedWorkflow1 does something
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow1(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedWorkflow1Async starts a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow and returns a handle to the workflow run
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow1Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (SomeDeprecatedWorkflow1Run, error)

	// GetSomeDeprecatedWorkflow1 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow execution
	//
	// Deprecated: Do not use.
	GetSomeDeprecatedWorkflow1(ctx context.Context, workflowID string, runID string) SomeDeprecatedWorkflow1Run

	// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1 sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow, starting it if necessary, and blocks until workflow completion
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow, starting it if necessary, and returns a handle to the workflow execution
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (SomeDeprecatedWorkflow1Run, error)

	// SomeDeprecatedWorkflow2 does something else
	//
	// Deprecated: a custom workflow deprecation message.
	SomeDeprecatedWorkflow2(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedWorkflow2Async starts a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow and returns a handle to the workflow run
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow2Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (SomeDeprecatedWorkflow2Run, error)

	// GetSomeDeprecatedWorkflow2 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow execution
	//
	// Deprecated: Do not use.
	GetSomeDeprecatedWorkflow2(ctx context.Context, workflowID string, runID string) SomeDeprecatedWorkflow2Run

	// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2 sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow, starting it if necessary, and blocks until workflow completion
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow, starting it if necessary, and returns a handle to the workflow execution
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (SomeDeprecatedWorkflow2Run, error)

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// SomeDeprecatedQuery1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedQuery1(ctx context.Context, workflowID string, runID string, query *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedQuery2 does something else
	//
	// Deprecated: a custom query deprecation message.
	SomeDeprecatedQuery2(ctx context.Context, workflowID string, runID string, query *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedSignal1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedSignal1(ctx context.Context, workflowID string, runID string, signal *SomeDeprecatedMessage) error

	// SomeDeprecatedSignal2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedSignal2(ctx context.Context, workflowID string, runID string, signal *SomeDeprecatedMessage) error

	// SomeDeprecatedUpdate1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate1Async starts a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update and returns a handle to the workflow update
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (SomeDeprecatedUpdate1Handle, error)

	// GetSomeDeprecatedUpdate1 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update
	//
	// Deprecated: Do not use.
	GetSomeDeprecatedUpdate1(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeDeprecatedUpdate1Handle, error)

	// SomeDeprecatedUpdate2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedUpdate2(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate2Async starts a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update and returns a handle to the workflow update
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate2Async(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (SomeDeprecatedUpdate2Handle, error)

	// GetSomeDeprecatedUpdate2 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update
	//
	// Deprecated: Do not use.
	GetSomeDeprecatedUpdate2(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeDeprecatedUpdate2Handle, error)
}

// deprecatedClient implements a temporal client for a mycompany.simple.Deprecated service
type deprecatedClient struct {
	client client.Client
	log    *slog.Logger
}

// NewDeprecatedClient initializes a new mycompany.simple.Deprecated client
func NewDeprecatedClient(c client.Client, options ...*deprecatedClientOptions) DeprecatedClient {
	var cfg *deprecatedClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewDeprecatedClientOptions()
	}
	return &deprecatedClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewDeprecatedClientWithOptions initializes a new Deprecated client with the given options
func NewDeprecatedClientWithOptions(c client.Client, opts client.Options, options ...*deprecatedClientOptions) (DeprecatedClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *deprecatedClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewDeprecatedClientOptions()
	}
	return &deprecatedClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// deprecatedClientOptions describes optional runtime configuration for a DeprecatedClient
type deprecatedClientOptions struct {
	log *slog.Logger
}

// NewDeprecatedClientOptions initializes a new deprecatedClientOptions value
func NewDeprecatedClientOptions() *deprecatedClientOptions {
	return &deprecatedClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *deprecatedClientOptions) WithLogger(l *slog.Logger) *deprecatedClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *deprecatedClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedWorkflow1(ctx context.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1Options) (*SomeDeprecatedMessage, error) {
	run, err := c.SomeDeprecatedWorkflow1Async(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedWorkflow1Async(ctx context.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1Options) (SomeDeprecatedWorkflow1Run, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow1Async", "workflow", SomeDeprecatedWorkflow1WorkflowName)

	var o *SomeDeprecatedWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow1Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomeDeprecatedWorkflow1WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someDeprecatedWorkflow1Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeDeprecatedWorkflow1 fetches an existing mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 execution
func (c *deprecatedClient) GetSomeDeprecatedWorkflow1(ctx context.Context, workflowID string, runID string) SomeDeprecatedWorkflow1Run {
	return &someDeprecatedWorkflow1Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1 starts a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow and sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal in a transaction
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1Options) (*SomeDeprecatedMessage, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1", "workflow", SomeDeprecatedWorkflow1WorkflowName)
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1", "signal", SomeDeprecatedSignal1SignalName)

	run, err := c.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(ctx, req, signal, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async starts a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow and sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal in a transaction
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1Options) (SomeDeprecatedWorkflow1Run, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async", "workflow", SomeDeprecatedWorkflow1WorkflowName)
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async", "signal", SomeDeprecatedSignal1SignalName)

	var o *SomeDeprecatedWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow1Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SomeDeprecatedSignal1SignalName, signal, opts, SomeDeprecatedWorkflow1WorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &someDeprecatedWorkflow1Run{
		client: c,
		run:    run,
	}, nil
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func (c *deprecatedClient) SomeDeprecatedWorkflow2(ctx context.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2Options) (*SomeDeprecatedMessage, error) {
	run, err := c.SomeDeprecatedWorkflow2Async(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func (c *deprecatedClient) SomeDeprecatedWorkflow2Async(ctx context.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2Options) (SomeDeprecatedWorkflow2Run, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow2Async", "workflow", SomeDeprecatedWorkflow2WorkflowName)

	var o *SomeDeprecatedWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow2Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomeDeprecatedWorkflow2WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someDeprecatedWorkflow2Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeDeprecatedWorkflow2 fetches an existing mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 execution
func (c *deprecatedClient) GetSomeDeprecatedWorkflow2(ctx context.Context, workflowID string, runID string) SomeDeprecatedWorkflow2Run {
	return &someDeprecatedWorkflow2Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2 starts a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow and sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal in a transaction
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2Options) (*SomeDeprecatedMessage, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2", "workflow", SomeDeprecatedWorkflow2WorkflowName)
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2", "signal", SomeDeprecatedSignal2SignalName)

	run, err := c.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(ctx, req, signal, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async starts a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow and sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal in a transaction
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2Options) (SomeDeprecatedWorkflow2Run, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async", "workflow", SomeDeprecatedWorkflow2WorkflowName)
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async", "signal", SomeDeprecatedSignal2SignalName)

	var o *SomeDeprecatedWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow2Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SomeDeprecatedSignal2SignalName, signal, opts, SomeDeprecatedWorkflow2WorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &someDeprecatedWorkflow2Run{
		client: c,
		run:    run,
	}, nil
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *deprecatedClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *deprecatedClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// SomeDeprecatedQuery1 does something else
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedQuery1(ctx context.Context, workflowID string, runID string, query *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedQuery1", "query", SomeDeprecatedQuery1QueryName)

	var resp SomeDeprecatedMessage
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SomeDeprecatedQuery1QueryName, query); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeDeprecatedQuery2 does something else
//
// Deprecated: a custom query deprecation message.
func (c *deprecatedClient) SomeDeprecatedQuery2(ctx context.Context, workflowID string, runID string, query *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedQuery2", "query", SomeDeprecatedQuery2QueryName)

	var resp SomeDeprecatedMessage
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SomeDeprecatedQuery2QueryName, query); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedSignal1(ctx context.Context, workflowID string, runID string, signal *SomeDeprecatedMessage) error {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedSignal1", "signal", SomeDeprecatedSignal1SignalName)

	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeDeprecatedSignal1SignalName, signal)
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func (c *deprecatedClient) SomeDeprecatedSignal2(ctx context.Context, workflowID string, runID string, signal *SomeDeprecatedMessage) error {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedSignal2", "signal", SomeDeprecatedSignal2SignalName)

	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeDeprecatedSignal2SignalName, signal)
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedUpdate1(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (*SomeDeprecatedMessage, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedUpdate1", "update", SomeDeprecatedUpdate1UpdateName)

	// initialize update options
	o := NewSomeDeprecatedUpdate1Options()
	if len(opts) > 0 && opts[0].Options != nil {
		o = opts[0]
	}

	// call sync update with WorkflowUpdateStageCompleted wait policy
	handle, err := c.SomeDeprecatedUpdate1Async(ctx, workflowID, runID, req, o.WithWaitPolicy(client.WorkflowUpdateStageCompleted))
	if err != nil {
		return nil, err
	}

	// block on update completion
	return handle.Get(ctx)
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func (c *deprecatedClient) SomeDeprecatedUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (SomeDeprecatedUpdate1Handle, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedUpdate1Async", "update", SomeDeprecatedUpdate1UpdateName)

	// initialize update options
	var o *SomeDeprecatedUpdate1Options
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewSomeDeprecatedUpdate1Options()
	}

	// build UpdateWorkflowOptions
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	// update workflow
	handle, err := c.client.UpdateWorkflow(ctx, *options)
	if err != nil {
		return nil, err
	}
	return &someDeprecatedUpdate1Handle{client: c, handle: handle}, nil
}

// GetSomeDeprecatedUpdate1 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update
func (c *deprecatedClient) GetSomeDeprecatedUpdate1(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeDeprecatedUpdate1Handle, error) {
	return &someDeprecatedUpdate1Handle{
		client: c,
		handle: c.client.GetWorkflowUpdateHandle(req),
	}, nil
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func (c *deprecatedClient) SomeDeprecatedUpdate2(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (*SomeDeprecatedMessage, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedUpdate2", "update", SomeDeprecatedUpdate2UpdateName)

	// initialize update options
	o := NewSomeDeprecatedUpdate2Options()
	if len(opts) > 0 && opts[0].Options != nil {
		o = opts[0]
	}

	// call sync update with WorkflowUpdateStageCompleted wait policy
	handle, err := c.SomeDeprecatedUpdate2Async(ctx, workflowID, runID, req, o.WithWaitPolicy(client.WorkflowUpdateStageCompleted))
	if err != nil {
		return nil, err
	}

	// block on update completion
	return handle.Get(ctx)
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func (c *deprecatedClient) SomeDeprecatedUpdate2Async(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (SomeDeprecatedUpdate2Handle, error) {
	c.log.WarnContext(ctx, "use of deprecated client method detected", "method", "SomeDeprecatedUpdate2Async", "update", SomeDeprecatedUpdate2UpdateName)

	// initialize update options
	var o *SomeDeprecatedUpdate2Options
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewSomeDeprecatedUpdate2Options()
	}

	// build UpdateWorkflowOptions
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	// update workflow
	handle, err := c.client.UpdateWorkflow(ctx, *options)
	if err != nil {
		return nil, err
	}
	return &someDeprecatedUpdate2Handle{client: c, handle: handle}, nil
}

// GetSomeDeprecatedUpdate2 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update
func (c *deprecatedClient) GetSomeDeprecatedUpdate2(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeDeprecatedUpdate2Handle, error) {
	return &someDeprecatedUpdate2Handle{
		client: c,
		handle: c.client.GetWorkflowUpdateHandle(req),
	}, nil
}

// SomeDeprecatedWorkflow1Options provides configuration for a mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow operation
type SomeDeprecatedWorkflow1Options struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewSomeDeprecatedWorkflow1Options initializes a new SomeDeprecatedWorkflow1Options value
func NewSomeDeprecatedWorkflow1Options() *SomeDeprecatedWorkflow1Options {
	return &SomeDeprecatedWorkflow1Options{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomeDeprecatedWorkflow1Options) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomeDeprecatedWorkflow1Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeDeprecatedWorkflow1Options {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeDeprecatedWorkflow1Options) WithExecutionTimeout(d time.Duration) *SomeDeprecatedWorkflow1Options {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomeDeprecatedWorkflow1Options) WithID(id string) *SomeDeprecatedWorkflow1Options {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeDeprecatedWorkflow1Options) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeDeprecatedWorkflow1Options {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedWorkflow1Options) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedWorkflow1Options {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeDeprecatedWorkflow1Options) WithRunTimeout(d time.Duration) *SomeDeprecatedWorkflow1Options {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeDeprecatedWorkflow1Options) WithSearchAttributes(sa map[string]any) *SomeDeprecatedWorkflow1Options {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeDeprecatedWorkflow1Options) WithTaskTimeout(d time.Duration) *SomeDeprecatedWorkflow1Options {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeDeprecatedWorkflow1Options) WithTaskQueue(tq string) *SomeDeprecatedWorkflow1Options {
	o.taskQueue = &tq
	return o
}

// SomeDeprecatedWorkflow1Run describes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow run
type SomeDeprecatedWorkflow1Run interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeDeprecatedMessage, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// SomeDeprecatedQuery1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedQuery1(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedSignal1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedSignal1(ctx context.Context, req *SomeDeprecatedMessage) error

	// SomeDeprecatedUpdate1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (SomeDeprecatedUpdate1Handle, error)
}

// someDeprecatedWorkflow1Run provides an internal implementation of a(n) SomeDeprecatedWorkflow1RunRun
type someDeprecatedWorkflow1Run struct {
	client *deprecatedClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someDeprecatedWorkflow1Run) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *someDeprecatedWorkflow1Run) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *someDeprecatedWorkflow1Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someDeprecatedWorkflow1Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someDeprecatedWorkflow1Run) Get(ctx context.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someDeprecatedWorkflow1Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeDeprecatedQuery1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedQuery1(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedQuery1(ctx, r.ID(), "", req)
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedSignal1(ctx context.Context, req *SomeDeprecatedMessage) error {
	return r.client.SomeDeprecatedSignal1(ctx, r.ID(), "", req)
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedUpdate1(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedUpdate1(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeDeprecatedUpdate1 does something else
//
// Deprecated: Do not use.
func (r *someDeprecatedWorkflow1Run) SomeDeprecatedUpdate1Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (SomeDeprecatedUpdate1Handle, error) {
	return r.client.SomeDeprecatedUpdate1Async(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeDeprecatedWorkflow2Options provides configuration for a mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow operation
type SomeDeprecatedWorkflow2Options struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewSomeDeprecatedWorkflow2Options initializes a new SomeDeprecatedWorkflow2Options value
func NewSomeDeprecatedWorkflow2Options() *SomeDeprecatedWorkflow2Options {
	return &SomeDeprecatedWorkflow2Options{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomeDeprecatedWorkflow2Options) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomeDeprecatedWorkflow2Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeDeprecatedWorkflow2Options {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeDeprecatedWorkflow2Options) WithExecutionTimeout(d time.Duration) *SomeDeprecatedWorkflow2Options {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomeDeprecatedWorkflow2Options) WithID(id string) *SomeDeprecatedWorkflow2Options {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeDeprecatedWorkflow2Options) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeDeprecatedWorkflow2Options {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedWorkflow2Options) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedWorkflow2Options {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeDeprecatedWorkflow2Options) WithRunTimeout(d time.Duration) *SomeDeprecatedWorkflow2Options {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeDeprecatedWorkflow2Options) WithSearchAttributes(sa map[string]any) *SomeDeprecatedWorkflow2Options {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeDeprecatedWorkflow2Options) WithTaskTimeout(d time.Duration) *SomeDeprecatedWorkflow2Options {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeDeprecatedWorkflow2Options) WithTaskQueue(tq string) *SomeDeprecatedWorkflow2Options {
	o.taskQueue = &tq
	return o
}

// SomeDeprecatedWorkflow2Run describes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow run
type SomeDeprecatedWorkflow2Run interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeDeprecatedMessage, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// SomeDeprecatedQuery2 does something else
	//
	// Deprecated: a custom query deprecation message.
	SomeDeprecatedQuery2(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedSignal2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedSignal2(ctx context.Context, req *SomeDeprecatedMessage) error

	// SomeDeprecatedUpdate2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedUpdate2(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedUpdate2Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (SomeDeprecatedUpdate2Handle, error)
}

// someDeprecatedWorkflow2Run provides an internal implementation of a(n) SomeDeprecatedWorkflow2RunRun
type someDeprecatedWorkflow2Run struct {
	client *deprecatedClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someDeprecatedWorkflow2Run) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *someDeprecatedWorkflow2Run) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *someDeprecatedWorkflow2Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someDeprecatedWorkflow2Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someDeprecatedWorkflow2Run) Get(ctx context.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someDeprecatedWorkflow2Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeDeprecatedQuery2 does something else
//
// Deprecated: a custom query deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedQuery2(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedQuery2(ctx, r.ID(), "", req)
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedSignal2(ctx context.Context, req *SomeDeprecatedMessage) error {
	return r.client.SomeDeprecatedSignal2(ctx, r.ID(), "", req)
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedUpdate2(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedUpdate2(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeDeprecatedUpdate2 does something else
//
// Deprecated: a custom signal deprecation message.
func (r *someDeprecatedWorkflow2Run) SomeDeprecatedUpdate2Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (SomeDeprecatedUpdate2Handle, error) {
	return r.client.SomeDeprecatedUpdate2Async(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeDeprecatedUpdate1Handle describes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update handle
type SomeDeprecatedUpdate1Handle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeDeprecatedMessage, error)
}

// someDeprecatedUpdate1Handle provides an internal implementation of a(n) SomeDeprecatedUpdate1Handle
type someDeprecatedUpdate1Handle struct {
	client *deprecatedClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *someDeprecatedUpdate1Handle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *someDeprecatedUpdate1Handle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *someDeprecatedUpdate1Handle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *someDeprecatedUpdate1Handle) Get(ctx context.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	var err error
	doneCh := make(chan struct{})
	gctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			var deadlineExceeded *serviceerror.DeadlineExceeded
			if err = h.handle.Get(gctx, &resp); err != nil && ctx.Err() == nil && (errors.As(err, &deadlineExceeded) || strings.Contains(err.Error(), context.DeadlineExceeded.Error())) {
				continue
			}
			break
		}
		close(doneCh)
	}()

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-doneCh:
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}
}

// SomeDeprecatedUpdate1Options provides configuration for a mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update operation
type SomeDeprecatedUpdate1Options struct {
	Options    *client.UpdateWorkflowOptions
	id         *string
	waitPolicy client.WorkflowUpdateStage
}

// NewSomeDeprecatedUpdate1Options initializes a new SomeDeprecatedUpdate1Options value
func NewSomeDeprecatedUpdate1Options() *SomeDeprecatedUpdate1Options {
	return &SomeDeprecatedUpdate1Options{Options: &client.UpdateWorkflowOptions{}}
}

// Build initializes a new client.UpdateWorkflowOptions with defaults and overrides applied
func (o *SomeDeprecatedUpdate1Options) Build(workflowID string, runID string, req *SomeDeprecatedMessage) (opts *client.UpdateWorkflowOptions, err error) {
	// use user-provided UpdateWorkflowOptions if exists
	if o.Options != nil {
		opts = o.Options
	} else {
		opts = &client.UpdateWorkflowOptions{}
	}

	// set constants
	opts.Args = []any{req}
	opts.RunID = runID
	opts.UpdateName = SomeDeprecatedUpdate1UpdateName
	opts.WorkflowID = workflowID

	// set UpdateID
	if v := o.id; v != nil {
		opts.UpdateID = *v
	}

	// set WaitPolicy
	if v := o.waitPolicy; v != client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = v
	} else if opts.WaitForStage == client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = client.WorkflowUpdateStageCompleted
	}
	return opts, nil
}

// WithUpdateID sets the UpdateID
func (o *SomeDeprecatedUpdate1Options) WithUpdateID(id string) *SomeDeprecatedUpdate1Options {
	o.id = &id
	return o
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowOptions
func (o *SomeDeprecatedUpdate1Options) WithUpdateWorkflowOptions(options client.UpdateWorkflowOptions) *SomeDeprecatedUpdate1Options {
	o.Options = &options
	return o
}

// WithWaitPolicy sets the WaitPolicy
func (o *SomeDeprecatedUpdate1Options) WithWaitPolicy(policy client.WorkflowUpdateStage) *SomeDeprecatedUpdate1Options {
	o.waitPolicy = policy
	return o
}

// SomeDeprecatedUpdate2Handle describes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update handle
type SomeDeprecatedUpdate2Handle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeDeprecatedMessage, error)
}

// someDeprecatedUpdate2Handle provides an internal implementation of a(n) SomeDeprecatedUpdate2Handle
type someDeprecatedUpdate2Handle struct {
	client *deprecatedClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *someDeprecatedUpdate2Handle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *someDeprecatedUpdate2Handle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *someDeprecatedUpdate2Handle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *someDeprecatedUpdate2Handle) Get(ctx context.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	var err error
	doneCh := make(chan struct{})
	gctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			var deadlineExceeded *serviceerror.DeadlineExceeded
			if err = h.handle.Get(gctx, &resp); err != nil && ctx.Err() == nil && (errors.As(err, &deadlineExceeded) || strings.Contains(err.Error(), context.DeadlineExceeded.Error())) {
				continue
			}
			break
		}
		close(doneCh)
	}()

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-doneCh:
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}
}

// SomeDeprecatedUpdate2Options provides configuration for a mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update operation
type SomeDeprecatedUpdate2Options struct {
	Options    *client.UpdateWorkflowOptions
	id         *string
	waitPolicy client.WorkflowUpdateStage
}

// NewSomeDeprecatedUpdate2Options initializes a new SomeDeprecatedUpdate2Options value
func NewSomeDeprecatedUpdate2Options() *SomeDeprecatedUpdate2Options {
	return &SomeDeprecatedUpdate2Options{Options: &client.UpdateWorkflowOptions{}}
}

// Build initializes a new client.UpdateWorkflowOptions with defaults and overrides applied
func (o *SomeDeprecatedUpdate2Options) Build(workflowID string, runID string, req *SomeDeprecatedMessage) (opts *client.UpdateWorkflowOptions, err error) {
	// use user-provided UpdateWorkflowOptions if exists
	if o.Options != nil {
		opts = o.Options
	} else {
		opts = &client.UpdateWorkflowOptions{}
	}

	// set constants
	opts.Args = []any{req}
	opts.RunID = runID
	opts.UpdateName = SomeDeprecatedUpdate2UpdateName
	opts.WorkflowID = workflowID

	// set UpdateID
	if v := o.id; v != nil {
		opts.UpdateID = *v
	}

	// set WaitPolicy
	if v := o.waitPolicy; v != client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = v
	} else if opts.WaitForStage == client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = client.WorkflowUpdateStageCompleted
	}
	return opts, nil
}

// WithUpdateID sets the UpdateID
func (o *SomeDeprecatedUpdate2Options) WithUpdateID(id string) *SomeDeprecatedUpdate2Options {
	o.id = &id
	return o
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowOptions
func (o *SomeDeprecatedUpdate2Options) WithUpdateWorkflowOptions(options client.UpdateWorkflowOptions) *SomeDeprecatedUpdate2Options {
	o.Options = &options
	return o
}

// WithWaitPolicy sets the WaitPolicy
func (o *SomeDeprecatedUpdate2Options) WithWaitPolicy(policy client.WorkflowUpdateStage) *SomeDeprecatedUpdate2Options {
	o.waitPolicy = policy
	return o
}

// Reference to generated workflow functions
var (
	// SomeDeprecatedWorkflow1 does something
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow1Function func(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
	// SomeDeprecatedWorkflow2 does something else
	//
	// Deprecated: a custom workflow deprecation message.
	SomeDeprecatedWorkflow2Function func(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
)

// DeprecatedWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// DeprecatedWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	DeprecatedWorkflowFunctions interface {
		// SomeDeprecatedWorkflow1 does something
		//
		// Deprecated: Do not use.
		SomeDeprecatedWorkflow1(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
		// SomeDeprecatedWorkflow2 does something else
		//
		// Deprecated: a custom workflow deprecation message.
		SomeDeprecatedWorkflow2(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
	}
	// deprecatedWorkflowFunctions provides an internal DeprecatedWorkflowFunctions implementation
	deprecatedWorkflowFunctions struct{}
)

func NewDeprecatedWorkflowFunctions() DeprecatedWorkflowFunctions {
	return &deprecatedWorkflowFunctions{}
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func (f *deprecatedWorkflowFunctions) SomeDeprecatedWorkflow1(ctx workflow.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	if SomeDeprecatedWorkflow1Function == nil {
		return nil, errors.New("SomeDeprecatedWorkflow1 requires workflow registration via RegisterDeprecatedWorkflows or RegisterSomeDeprecatedWorkflow1Workflow")
	}
	return SomeDeprecatedWorkflow1Function(ctx, req)
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func (f *deprecatedWorkflowFunctions) SomeDeprecatedWorkflow2(ctx workflow.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	if SomeDeprecatedWorkflow2Function == nil {
		return nil, errors.New("SomeDeprecatedWorkflow2 requires workflow registration via RegisterDeprecatedWorkflows or RegisterSomeDeprecatedWorkflow2Workflow")
	}
	return SomeDeprecatedWorkflow2Function(ctx, req)
}

// DeprecatedWorkflows provides methods for initializing new mycompany.simple.Deprecated workflow values
type DeprecatedWorkflows interface {
	// SomeDeprecatedWorkflow1 does something
	//
	// Deprecated: Do not use.
	SomeDeprecatedWorkflow1(ctx workflow.Context, input *SomeDeprecatedWorkflow1WorkflowInput) (SomeDeprecatedWorkflow1Workflow, error)

	// SomeDeprecatedWorkflow2 does something else
	//
	// Deprecated: a custom workflow deprecation message.
	SomeDeprecatedWorkflow2(ctx workflow.Context, input *SomeDeprecatedWorkflow2WorkflowInput) (SomeDeprecatedWorkflow2Workflow, error)
}

// RegisterDeprecatedWorkflows registers mycompany.simple.Deprecated workflows with the given worker
func RegisterDeprecatedWorkflows(r worker.WorkflowRegistry, workflows DeprecatedWorkflows) {
	RegisterSomeDeprecatedWorkflow1Workflow(r, workflows.SomeDeprecatedWorkflow1)
	RegisterSomeDeprecatedWorkflow2Workflow(r, workflows.SomeDeprecatedWorkflow2)
}

// RegisterSomeDeprecatedWorkflow1Workflow registers a mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow with the given worker
func RegisterSomeDeprecatedWorkflow1Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeDeprecatedWorkflow1WorkflowInput) (SomeDeprecatedWorkflow1Workflow, error)) {
	SomeDeprecatedWorkflow1Function = buildSomeDeprecatedWorkflow1(wf)
	r.RegisterWorkflowWithOptions(SomeDeprecatedWorkflow1Function, workflow.RegisterOptions{Name: SomeDeprecatedWorkflow1WorkflowName})
}

// buildSomeDeprecatedWorkflow1 converts a SomeDeprecatedWorkflow1 workflow struct into a valid workflow function
func buildSomeDeprecatedWorkflow1(ctor func(workflow.Context, *SomeDeprecatedWorkflow1WorkflowInput) (SomeDeprecatedWorkflow1Workflow, error)) func(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	return func(ctx workflow.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
		input := &SomeDeprecatedWorkflow1WorkflowInput{
			Req: req,
			SomeDeprecatedSignal1: &SomeDeprecatedSignal1Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeDeprecatedSignal1SignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		if err := workflow.SetQueryHandler(ctx, SomeDeprecatedQuery1QueryName, wf.SomeDeprecatedQuery1); err != nil {
			return nil, err
		}
		{
			opts := workflow.UpdateHandlerOptions{}
			if err := workflow.SetUpdateHandlerWithOptions(ctx, SomeDeprecatedUpdate1UpdateName, wf.SomeDeprecatedUpdate1, opts); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomeDeprecatedWorkflow1WorkflowInput describes the input to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow constructor
type SomeDeprecatedWorkflow1WorkflowInput struct {
	Req                   *SomeDeprecatedMessage
	SomeDeprecatedSignal1 *SomeDeprecatedSignal1Signal
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
//
// workflow details: (name: "mycompany.simple.Deprecated.SomeDeprecatedWorkflow1")
type SomeDeprecatedWorkflow1Workflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow
	//
	// Deprecated: Do not use.
	Execute(ctx workflow.Context) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedQuery1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedQuery1(*SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate1 does something else
	//
	// Deprecated: Do not use.
	SomeDeprecatedUpdate1(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow1Child(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1ChildOptions) (*SomeDeprecatedMessage, error) {
	childRun, err := SomeDeprecatedWorkflow1ChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomeDeprecatedWorkflow1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedWorkflow1ChildAsync(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1ChildOptions) (*SomeDeprecatedWorkflow1ChildRun, error) {
	var o *SomeDeprecatedWorkflow1ChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow1ChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &SomeDeprecatedWorkflow1ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeDeprecatedWorkflow1WorkflowName, req)}, nil
}

// SomeDeprecatedWorkflow1ChildOptions provides configuration for a child mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow operation
type SomeDeprecatedWorkflow1ChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewSomeDeprecatedWorkflow1ChildOptions initializes a new SomeDeprecatedWorkflow1ChildOptions value
func NewSomeDeprecatedWorkflow1ChildOptions() *SomeDeprecatedWorkflow1ChildOptions {
	return &SomeDeprecatedWorkflow1ChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomeDeprecatedWorkflow1ChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
		} else {
			opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomeDeprecatedWorkflow1ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeDeprecatedWorkflow1ChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithExecutionTimeout(d time.Duration) *SomeDeprecatedWorkflow1ChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithID(id string) *SomeDeprecatedWorkflow1ChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeDeprecatedWorkflow1ChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeDeprecatedWorkflow1ChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedWorkflow1ChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithRunTimeout(d time.Duration) *SomeDeprecatedWorkflow1ChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithSearchAttributes(sa map[string]any) *SomeDeprecatedWorkflow1ChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithTaskTimeout(d time.Duration) *SomeDeprecatedWorkflow1ChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithTaskQueue(tq string) *SomeDeprecatedWorkflow1ChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeDeprecatedWorkflow1ChildOptions) WithWaitForCancellation(wait bool) *SomeDeprecatedWorkflow1ChildOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeDeprecatedWorkflow1ChildRun describes a child SomeDeprecatedWorkflow1 workflow run
type SomeDeprecatedWorkflow1ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeDeprecatedWorkflow1ChildRun) Get(ctx workflow.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeDeprecatedWorkflow1ChildRun) Select(sel workflow.Selector, fn func(*SomeDeprecatedWorkflow1ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeDeprecatedWorkflow1ChildRun) SelectStart(sel workflow.Selector, fn func(*SomeDeprecatedWorkflow1ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeDeprecatedWorkflow1ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeDeprecatedSignal1 sends a(n) "mycompany.simple.Deprecated.SomeDeprecatedSignal1" signal request to the child workflow
func (r *SomeDeprecatedWorkflow1ChildRun) SomeDeprecatedSignal1(ctx workflow.Context, input *SomeDeprecatedMessage) error {
	return r.SomeDeprecatedSignal1Async(ctx, input).Get(ctx, nil)
}

// SomeDeprecatedSignal1Async sends a(n) "mycompany.simple.Deprecated.SomeDeprecatedSignal1" signal request to the child workflow
func (r *SomeDeprecatedWorkflow1ChildRun) SomeDeprecatedSignal1Async(ctx workflow.Context, input *SomeDeprecatedMessage) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeDeprecatedSignal1SignalName, input)
}

// RegisterSomeDeprecatedWorkflow2Workflow registers a mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow with the given worker
func RegisterSomeDeprecatedWorkflow2Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeDeprecatedWorkflow2WorkflowInput) (SomeDeprecatedWorkflow2Workflow, error)) {
	SomeDeprecatedWorkflow2Function = buildSomeDeprecatedWorkflow2(wf)
	r.RegisterWorkflowWithOptions(SomeDeprecatedWorkflow2Function, workflow.RegisterOptions{Name: SomeDeprecatedWorkflow2WorkflowName})
}

// buildSomeDeprecatedWorkflow2 converts a SomeDeprecatedWorkflow2 workflow struct into a valid workflow function
func buildSomeDeprecatedWorkflow2(ctor func(workflow.Context, *SomeDeprecatedWorkflow2WorkflowInput) (SomeDeprecatedWorkflow2Workflow, error)) func(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	return func(ctx workflow.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
		input := &SomeDeprecatedWorkflow2WorkflowInput{
			Req: req,
			SomeDeprecatedSignal2: &SomeDeprecatedSignal2Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeDeprecatedSignal2SignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		if err := workflow.SetQueryHandler(ctx, SomeDeprecatedQuery2QueryName, wf.SomeDeprecatedQuery2); err != nil {
			return nil, err
		}
		{
			opts := workflow.UpdateHandlerOptions{}
			if err := workflow.SetUpdateHandlerWithOptions(ctx, SomeDeprecatedUpdate2UpdateName, wf.SomeDeprecatedUpdate2, opts); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomeDeprecatedWorkflow2WorkflowInput describes the input to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow constructor
type SomeDeprecatedWorkflow2WorkflowInput struct {
	Req                   *SomeDeprecatedMessage
	SomeDeprecatedSignal2 *SomeDeprecatedSignal2Signal
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
//
// workflow details: (name: "mycompany.simple.Deprecated.SomeDeprecatedWorkflow2")
type SomeDeprecatedWorkflow2Workflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow
	//
	// Deprecated: Do not use.
	Execute(ctx workflow.Context) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedQuery2 does something else
	//
	// Deprecated: a custom query deprecation message.
	SomeDeprecatedQuery2(*SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedUpdate2 does something else
	//
	// Deprecated: a custom signal deprecation message.
	SomeDeprecatedUpdate2(workflow.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func SomeDeprecatedWorkflow2Child(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2ChildOptions) (*SomeDeprecatedMessage, error) {
	childRun, err := SomeDeprecatedWorkflow2ChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomeDeprecatedWorkflow2 does something else
//
// Deprecated: a custom workflow deprecation message.
func SomeDeprecatedWorkflow2ChildAsync(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2ChildOptions) (*SomeDeprecatedWorkflow2ChildRun, error) {
	var o *SomeDeprecatedWorkflow2ChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow2ChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &SomeDeprecatedWorkflow2ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeDeprecatedWorkflow2WorkflowName, req)}, nil
}

// SomeDeprecatedWorkflow2ChildOptions provides configuration for a child mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow operation
type SomeDeprecatedWorkflow2ChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewSomeDeprecatedWorkflow2ChildOptions initializes a new SomeDeprecatedWorkflow2ChildOptions value
func NewSomeDeprecatedWorkflow2ChildOptions() *SomeDeprecatedWorkflow2ChildOptions {
	return &SomeDeprecatedWorkflow2ChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomeDeprecatedWorkflow2ChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
		} else {
			opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomeDeprecatedWorkflow2ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeDeprecatedWorkflow2ChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithExecutionTimeout(d time.Duration) *SomeDeprecatedWorkflow2ChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithID(id string) *SomeDeprecatedWorkflow2ChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomeDeprecatedWorkflow2ChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomeDeprecatedWorkflow2ChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedWorkflow2ChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithRunTimeout(d time.Duration) *SomeDeprecatedWorkflow2ChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithSearchAttributes(sa map[string]any) *SomeDeprecatedWorkflow2ChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithTaskTimeout(d time.Duration) *SomeDeprecatedWorkflow2ChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithTaskQueue(tq string) *SomeDeprecatedWorkflow2ChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeDeprecatedWorkflow2ChildOptions) WithWaitForCancellation(wait bool) *SomeDeprecatedWorkflow2ChildOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeDeprecatedWorkflow2ChildRun describes a child SomeDeprecatedWorkflow2 workflow run
type SomeDeprecatedWorkflow2ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeDeprecatedWorkflow2ChildRun) Get(ctx workflow.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeDeprecatedWorkflow2ChildRun) Select(sel workflow.Selector, fn func(*SomeDeprecatedWorkflow2ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeDeprecatedWorkflow2ChildRun) SelectStart(sel workflow.Selector, fn func(*SomeDeprecatedWorkflow2ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeDeprecatedWorkflow2ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeDeprecatedSignal2 sends a(n) "mycompany.simple.Deprecated.SomeDeprecatedSignal2" signal request to the child workflow
func (r *SomeDeprecatedWorkflow2ChildRun) SomeDeprecatedSignal2(ctx workflow.Context, input *SomeDeprecatedMessage) error {
	return r.SomeDeprecatedSignal2Async(ctx, input).Get(ctx, nil)
}

// SomeDeprecatedSignal2Async sends a(n) "mycompany.simple.Deprecated.SomeDeprecatedSignal2" signal request to the child workflow
func (r *SomeDeprecatedWorkflow2ChildRun) SomeDeprecatedSignal2Async(ctx workflow.Context, input *SomeDeprecatedMessage) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeDeprecatedSignal2SignalName, input)
}

// SomeDeprecatedSignal1Signal describes a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal
type SomeDeprecatedSignal1Signal struct {
	Channel workflow.ReceiveChannel
}

// NewSomeDeprecatedSignal1Signal initializes a new mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal wrapper
func NewSomeDeprecatedSignal1Signal(ctx workflow.Context) *SomeDeprecatedSignal1Signal {
	return &SomeDeprecatedSignal1Signal{Channel: workflow.GetSignalChannel(ctx, SomeDeprecatedSignal1SignalName)}
}

// Receive blocks until a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal is received
func (s *SomeDeprecatedSignal1Signal) Receive(ctx workflow.Context) (*SomeDeprecatedMessage, bool) {
	var resp SomeDeprecatedMessage
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal without blocking
func (s *SomeDeprecatedSignal1Signal) ReceiveAsync() *SomeDeprecatedMessage {
	var resp SomeDeprecatedMessage
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *SomeDeprecatedSignal1Signal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *SomeDeprecatedMessage, ok bool, more bool) {
	resp = &SomeDeprecatedMessage{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal without blocking
func (s *SomeDeprecatedSignal1Signal) Select(sel workflow.Selector, fn func(*SomeDeprecatedMessage)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func SomeDeprecatedSignal1External(ctx workflow.Context, workflowID string, runID string, req *SomeDeprecatedMessage) error {
	return SomeDeprecatedSignal1ExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// SomeDeprecatedSignal1 does something else
//
// Deprecated: Do not use.
func SomeDeprecatedSignal1ExternalAsync(ctx workflow.Context, workflowID string, runID string, req *SomeDeprecatedMessage) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeDeprecatedSignal1SignalName, req)
}

// SomeDeprecatedSignal2Signal describes a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal
type SomeDeprecatedSignal2Signal struct {
	Channel workflow.ReceiveChannel
}

// NewSomeDeprecatedSignal2Signal initializes a new mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal wrapper
func NewSomeDeprecatedSignal2Signal(ctx workflow.Context) *SomeDeprecatedSignal2Signal {
	return &SomeDeprecatedSignal2Signal{Channel: workflow.GetSignalChannel(ctx, SomeDeprecatedSignal2SignalName)}
}

// Receive blocks until a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal is received
func (s *SomeDeprecatedSignal2Signal) Receive(ctx workflow.Context) (*SomeDeprecatedMessage, bool) {
	var resp SomeDeprecatedMessage
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal without blocking
func (s *SomeDeprecatedSignal2Signal) ReceiveAsync() *SomeDeprecatedMessage {
	var resp SomeDeprecatedMessage
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *SomeDeprecatedSignal2Signal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *SomeDeprecatedMessage, ok bool, more bool) {
	resp = &SomeDeprecatedMessage{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal without blocking
func (s *SomeDeprecatedSignal2Signal) Select(sel workflow.Selector, fn func(*SomeDeprecatedMessage)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func SomeDeprecatedSignal2External(ctx workflow.Context, workflowID string, runID string, req *SomeDeprecatedMessage) error {
	return SomeDeprecatedSignal2ExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// SomeDeprecatedSignal2 does something else
//
// Deprecated: a custom signal deprecation message.
func SomeDeprecatedSignal2ExternalAsync(ctx workflow.Context, workflowID string, runID string, req *SomeDeprecatedMessage) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeDeprecatedSignal2SignalName, req)
}

// DeprecatedActivities describes available worker activities
type DeprecatedActivities interface {
	// SomeDeprecatedActivity1 does something
	//
	// Deprecated: Do not use.
	SomeDeprecatedActivity1(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)

	// SomeDeprecatedActivity2 does something else
	//
	// Deprecated: a custom activity deprecation message.
	SomeDeprecatedActivity2(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
}

// RegisterDeprecatedActivities registers activities with a worker
func RegisterDeprecatedActivities(r worker.ActivityRegistry, activities DeprecatedActivities) {
	RegisterSomeDeprecatedActivity1Activity(r, activities.SomeDeprecatedActivity1)
	RegisterSomeDeprecatedActivity2Activity(r, activities.SomeDeprecatedActivity2)
}

// RegisterSomeDeprecatedActivity1Activity registers a mycompany.simple.Deprecated.SomeDeprecatedActivity1 activity
func RegisterSomeDeprecatedActivity1Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeDeprecatedActivity1ActivityName,
	})
}

// SomeDeprecatedActivity1Future describes a(n) mycompany.simple.Deprecated.SomeDeprecatedActivity1 activity execution
type SomeDeprecatedActivity1Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeDeprecatedActivity1Future) Get(ctx workflow.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeDeprecatedActivity1Future) Select(sel workflow.Selector, fn func(*SomeDeprecatedActivity1Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeDeprecatedActivity1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedActivity1(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity1ActivityOptions) (*SomeDeprecatedMessage, error) {
	return SomeDeprecatedActivity1Async(ctx, req, options...).Get(ctx)
}

// SomeDeprecatedActivity1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedActivity1Async(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity1ActivityOptions) *SomeDeprecatedActivity1Future {
	workflow.GetLogger(ctx).Warn("use of deprecated activity detected", "activity", SomeDeprecatedActivity1ActivityName)

	var o *SomeDeprecatedActivity1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedActivity1ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeDeprecatedActivity1Future{Future: errF}
	}
	activity := SomeDeprecatedActivity1ActivityName
	future := &SomeDeprecatedActivity1Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeDeprecatedActivity1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedActivity1Local(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity1LocalActivityOptions) (*SomeDeprecatedMessage, error) {
	return SomeDeprecatedActivity1LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeDeprecatedActivity1 does something
//
// Deprecated: Do not use.
func SomeDeprecatedActivity1LocalAsync(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity1LocalActivityOptions) *SomeDeprecatedActivity1Future {
	workflow.GetLogger(ctx).Warn("use of deprecated activity detected", "activity", SomeDeprecatedActivity1ActivityName)

	var o *SomeDeprecatedActivity1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedActivity1LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeDeprecatedActivity1Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeDeprecatedActivity1ActivityName
	}
	future := &SomeDeprecatedActivity1Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeDeprecatedActivity1ActivityOptions provides configuration for a(n) mycompany.simple.Deprecated.SomeDeprecatedActivity1 activity
type SomeDeprecatedActivity1ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeDeprecatedActivity1ActivityOptions initializes a new SomeDeprecatedActivity1ActivityOptions value
func NewSomeDeprecatedActivity1ActivityOptions() *SomeDeprecatedActivity1ActivityOptions {
	return &SomeDeprecatedActivity1ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeDeprecatedActivity1ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
		} else {
			opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeDeprecatedActivity1ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeDeprecatedActivity1ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeDeprecatedActivity1ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeDeprecatedActivity1ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedActivity1ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedActivity1ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeDeprecatedActivity1ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeDeprecatedActivity1ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeDeprecatedActivity1ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeDeprecatedActivity1ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeDeprecatedActivity1ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeDeprecatedActivity1ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeDeprecatedActivity1ActivityOptions) WithTaskQueue(tq string) *SomeDeprecatedActivity1ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeDeprecatedActivity1ActivityOptions) WithWaitForCancellation(wait bool) *SomeDeprecatedActivity1ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeDeprecatedActivity1LocalActivityOptions provides configuration for a(n) mycompany.simple.Deprecated.SomeDeprecatedActivity1 activity
type SomeDeprecatedActivity1LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
}

// NewSomeDeprecatedActivity1LocalActivityOptions initializes a new SomeDeprecatedActivity1LocalActivityOptions value
func NewSomeDeprecatedActivity1LocalActivityOptions() *SomeDeprecatedActivity1LocalActivityOptions {
	return &SomeDeprecatedActivity1LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeDeprecatedActivity1LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Deprecated.SomeDeprecatedActivity1 implementation
func (o *SomeDeprecatedActivity1LocalActivityOptions) Local(fn func(context.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)) *SomeDeprecatedActivity1LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeDeprecatedActivity1LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeDeprecatedActivity1LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedActivity1LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedActivity1LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeDeprecatedActivity1LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeDeprecatedActivity1LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeDeprecatedActivity1LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeDeprecatedActivity1LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterSomeDeprecatedActivity2Activity registers a mycompany.simple.Deprecated.SomeDeprecatedActivity2 activity
func RegisterSomeDeprecatedActivity2Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeDeprecatedActivity2ActivityName,
	})
}

// SomeDeprecatedActivity2Future describes a(n) mycompany.simple.Deprecated.SomeDeprecatedActivity2 activity execution
type SomeDeprecatedActivity2Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeDeprecatedActivity2Future) Get(ctx workflow.Context) (*SomeDeprecatedMessage, error) {
	var resp SomeDeprecatedMessage
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeDeprecatedActivity2Future) Select(sel workflow.Selector, fn func(*SomeDeprecatedActivity2Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeDeprecatedActivity2 does something else
//
// Deprecated: a custom activity deprecation message.
func SomeDeprecatedActivity2(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity2ActivityOptions) (*SomeDeprecatedMessage, error) {
	return SomeDeprecatedActivity2Async(ctx, req, options...).Get(ctx)
}

// SomeDeprecatedActivity2 does something else
//
// Deprecated: a custom activity deprecation message.
func SomeDeprecatedActivity2Async(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity2ActivityOptions) *SomeDeprecatedActivity2Future {
	workflow.GetLogger(ctx).Warn("use of deprecated activity detected", "activity", SomeDeprecatedActivity2ActivityName)

	var o *SomeDeprecatedActivity2ActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedActivity2ActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeDeprecatedActivity2Future{Future: errF}
	}
	activity := SomeDeprecatedActivity2ActivityName
	future := &SomeDeprecatedActivity2Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeDeprecatedActivity2 does something else
//
// Deprecated: a custom activity deprecation message.
func SomeDeprecatedActivity2Local(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity2LocalActivityOptions) (*SomeDeprecatedMessage, error) {
	return SomeDeprecatedActivity2LocalAsync(ctx, req, options...).Get(ctx)
}

// SomeDeprecatedActivity2 does something else
//
// Deprecated: a custom activity deprecation message.
func SomeDeprecatedActivity2LocalAsync(ctx workflow.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedActivity2LocalActivityOptions) *SomeDeprecatedActivity2Future {
	workflow.GetLogger(ctx).Warn("use of deprecated activity detected", "activity", SomeDeprecatedActivity2ActivityName)

	var o *SomeDeprecatedActivity2LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedActivity2LocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &SomeDeprecatedActivity2Future{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = SomeDeprecatedActivity2ActivityName
	}
	future := &SomeDeprecatedActivity2Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeDeprecatedActivity2ActivityOptions provides configuration for a(n) mycompany.simple.Deprecated.SomeDeprecatedActivity2 activity
type SomeDeprecatedActivity2ActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewSomeDeprecatedActivity2ActivityOptions initializes a new SomeDeprecatedActivity2ActivityOptions value
func NewSomeDeprecatedActivity2ActivityOptions() *SomeDeprecatedActivity2ActivityOptions {
	return &SomeDeprecatedActivity2ActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeDeprecatedActivity2ActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
		} else {
			opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *SomeDeprecatedActivity2ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeDeprecatedActivity2ActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *SomeDeprecatedActivity2ActivityOptions) WithHeartbeatTimeout(d time.Duration) *SomeDeprecatedActivity2ActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedActivity2ActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedActivity2ActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeDeprecatedActivity2ActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeDeprecatedActivity2ActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *SomeDeprecatedActivity2ActivityOptions) WithScheduleToStartTimeout(d time.Duration) *SomeDeprecatedActivity2ActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeDeprecatedActivity2ActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeDeprecatedActivity2ActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomeDeprecatedActivity2ActivityOptions) WithTaskQueue(tq string) *SomeDeprecatedActivity2ActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomeDeprecatedActivity2ActivityOptions) WithWaitForCancellation(wait bool) *SomeDeprecatedActivity2ActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// SomeDeprecatedActivity2LocalActivityOptions provides configuration for a(n) mycompany.simple.Deprecated.SomeDeprecatedActivity2 activity
type SomeDeprecatedActivity2LocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)
}

// NewSomeDeprecatedActivity2LocalActivityOptions initializes a new SomeDeprecatedActivity2LocalActivityOptions value
func NewSomeDeprecatedActivity2LocalActivityOptions() *SomeDeprecatedActivity2LocalActivityOptions {
	return &SomeDeprecatedActivity2LocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *SomeDeprecatedActivity2LocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom mycompany.simple.Deprecated.SomeDeprecatedActivity2 implementation
func (o *SomeDeprecatedActivity2LocalActivityOptions) Local(fn func(context.Context, *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error)) *SomeDeprecatedActivity2LocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *SomeDeprecatedActivity2LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeDeprecatedActivity2LocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomeDeprecatedActivity2LocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomeDeprecatedActivity2LocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *SomeDeprecatedActivity2LocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *SomeDeprecatedActivity2LocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *SomeDeprecatedActivity2LocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *SomeDeprecatedActivity2LocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestDeprecatedClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows DeprecatedWorkflows
}

var _ DeprecatedClient = &TestDeprecatedClient{}

// NewTestDeprecatedClient initializes a new TestDeprecatedClient value
func NewTestDeprecatedClient(env *testsuite.TestWorkflowEnvironment, workflows DeprecatedWorkflows, activities DeprecatedActivities) *TestDeprecatedClient {
	if workflows != nil {
		RegisterDeprecatedWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterDeprecatedActivities(env, activities)
	}
	return &TestDeprecatedClient{env, workflows}
}

// SomeDeprecatedWorkflow1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow1(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (*SomeDeprecatedMessage, error) {
	run, err := c.SomeDeprecatedWorkflow1Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow1Async(ctx context.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow1Options) (SomeDeprecatedWorkflow1Run, error) {
	var o *SomeDeprecatedWorkflow1Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow1Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomeDeprecatedWorkflow1Run{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomeDeprecatedWorkflow1 is a noop
func (c *TestDeprecatedClient) GetSomeDeprecatedWorkflow1(ctx context.Context, workflowID string, runID string) SomeDeprecatedWorkflow1Run {
	return &testSomeDeprecatedWorkflow1Run{env: c.env, workflows: c.workflows}
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1 sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow, starting it if necessary
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (*SomeDeprecatedMessage, error) {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SomeDeprecatedSignal1SignalName, signal)
	}, 0)
	return c.SomeDeprecatedWorkflow1(ctx, req, opts...)
}

// SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow, starting it if necessary
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow1Options) (SomeDeprecatedWorkflow1Run, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.SomeDeprecatedSignal1(ctx, "", "", signal)
	}, 0)
	return c.SomeDeprecatedWorkflow1Async(ctx, req, opts...)
}

// SomeDeprecatedWorkflow2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow2(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (*SomeDeprecatedMessage, error) {
	run, err := c.SomeDeprecatedWorkflow2Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeDeprecatedWorkflow2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow2Async(ctx context.Context, req *SomeDeprecatedMessage, options ...*SomeDeprecatedWorkflow2Options) (SomeDeprecatedWorkflow2Run, error) {
	var o *SomeDeprecatedWorkflow2Options
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomeDeprecatedWorkflow2Options()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomeDeprecatedWorkflow2Run{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomeDeprecatedWorkflow2 is a noop
func (c *TestDeprecatedClient) GetSomeDeprecatedWorkflow2(ctx context.Context, workflowID string, runID string) SomeDeprecatedWorkflow2Run {
	return &testSomeDeprecatedWorkflow2Run{env: c.env, workflows: c.workflows}
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2 sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow, starting it if necessary
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (*SomeDeprecatedMessage, error) {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SomeDeprecatedSignal2SignalName, signal)
	}, 0)
	return c.SomeDeprecatedWorkflow2(ctx, req, opts...)
}

// SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async sends a(n) mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow, starting it if necessary
func (c *TestDeprecatedClient) SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(ctx context.Context, req *SomeDeprecatedMessage, signal *SomeDeprecatedMessage, opts ...*SomeDeprecatedWorkflow2Options) (SomeDeprecatedWorkflow2Run, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.SomeDeprecatedSignal2(ctx, "", "", signal)
	}, 0)
	return c.SomeDeprecatedWorkflow2Async(ctx, req, opts...)
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestDeprecatedClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestDeprecatedClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// SomeDeprecatedQuery1 executes a mycompany.simple.Deprecated.SomeDeprecatedQuery1 query
func (c *TestDeprecatedClient) SomeDeprecatedQuery1(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	val, err := c.env.QueryWorkflow(SomeDeprecatedQuery1QueryName, req)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result SomeDeprecatedMessage
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SomeDeprecatedQuery2 executes a mycompany.simple.Deprecated.SomeDeprecatedQuery2 query
func (c *TestDeprecatedClient) SomeDeprecatedQuery2(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	val, err := c.env.QueryWorkflow(SomeDeprecatedQuery2QueryName, req)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result SomeDeprecatedMessage
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SomeDeprecatedSignal1 executes a mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal
func (c *TestDeprecatedClient) SomeDeprecatedSignal1(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage) error {
	c.env.SignalWorkflow(SomeDeprecatedSignal1SignalName, req)
	return nil
}

// SomeDeprecatedSignal2 executes a mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal
func (c *TestDeprecatedClient) SomeDeprecatedSignal2(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage) error {
	c.env.SignalWorkflow(SomeDeprecatedSignal2SignalName, req)
	return nil
}

// SomeDeprecatedUpdate1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedUpdate1(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (*SomeDeprecatedMessage, error) {
	options := NewSomeDeprecatedUpdate1Options()
	if len(opts) > 0 && opts[0].Options != nil {
		options = opts[0]
	}
	options.Options.WaitForStage = client.WorkflowUpdateStageCompleted
	handle, err := c.SomeDeprecatedUpdate1Async(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeDeprecatedUpdate1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (SomeDeprecatedUpdate1Handle, error) {
	var o *SomeDeprecatedUpdate1Options
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewSomeDeprecatedUpdate1Options()
	}
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(SomeDeprecatedUpdate1UpdateName, workflowID, uc, req)
	return &testSomeDeprecatedUpdate1Handle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

// GetSomeDeprecatedUpdate1 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update
func (c *TestDeprecatedClient) GetSomeDeprecatedUpdate1(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeDeprecatedUpdate1Handle, error) {
	return nil, errors.New("unimplemented")
}

var _ SomeDeprecatedUpdate1Handle = &testSomeDeprecatedUpdate1Handle{}

// testSomeDeprecatedUpdate1Handle provides an internal implementation of a(n) SomeDeprecatedUpdate1Handle
type testSomeDeprecatedUpdate1Handle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowOptions
	req        *SomeDeprecatedMessage
	runID      string
	workflowID string
}

// Get retrieves a test mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update result
func (h *testSomeDeprecatedUpdate1Handle) Get(ctx context.Context) (*SomeDeprecatedMessage, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*SomeDeprecatedMessage), nil
	}
}

// RunID implementation
func (h *testSomeDeprecatedUpdate1Handle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testSomeDeprecatedUpdate1Handle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testSomeDeprecatedUpdate1Handle) WorkflowID() string {
	return h.workflowID
}

// SomeDeprecatedUpdate2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedUpdate2(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (*SomeDeprecatedMessage, error) {
	options := NewSomeDeprecatedUpdate2Options()
	if len(opts) > 0 && opts[0].Options != nil {
		options = opts[0]
	}
	options.Options.WaitForStage = client.WorkflowUpdateStageCompleted
	handle, err := c.SomeDeprecatedUpdate2Async(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeDeprecatedUpdate2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update in the test environment
func (c *TestDeprecatedClient) SomeDeprecatedUpdate2Async(ctx context.Context, workflowID string, runID string, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (SomeDeprecatedUpdate2Handle, error) {
	var o *SomeDeprecatedUpdate2Options
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewSomeDeprecatedUpdate2Options()
	}
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(SomeDeprecatedUpdate2UpdateName, workflowID, uc, req)
	return &testSomeDeprecatedUpdate2Handle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

// GetSomeDeprecatedUpdate2 retrieves a handle to an existing mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update
func (c *TestDeprecatedClient) GetSomeDeprecatedUpdate2(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (SomeDeprecatedUpdate2Handle, error) {
	return nil, errors.New("unimplemented")
}

var _ SomeDeprecatedUpdate2Handle = &testSomeDeprecatedUpdate2Handle{}

// testSomeDeprecatedUpdate2Handle provides an internal implementation of a(n) SomeDeprecatedUpdate2Handle
type testSomeDeprecatedUpdate2Handle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowOptions
	req        *SomeDeprecatedMessage
	runID      string
	workflowID string
}

// Get retrieves a test mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update result
func (h *testSomeDeprecatedUpdate2Handle) Get(ctx context.Context) (*SomeDeprecatedMessage, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*SomeDeprecatedMessage), nil
	}
}

// RunID implementation
func (h *testSomeDeprecatedUpdate2Handle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testSomeDeprecatedUpdate2Handle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testSomeDeprecatedUpdate2Handle) WorkflowID() string {
	return h.workflowID
}

var _ SomeDeprecatedWorkflow1Run = &testSomeDeprecatedWorkflow1Run{}

// testSomeDeprecatedWorkflow1Run provides convenience methods for interacting with a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow in the test environment
type testSomeDeprecatedWorkflow1Run struct {
	client    *TestDeprecatedClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SomeDeprecatedMessage
	workflows DeprecatedWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeDeprecatedWorkflow1Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow result
func (r *testSomeDeprecatedWorkflow1Run) Get(context.Context) (*SomeDeprecatedMessage, error) {
	r.env.ExecuteWorkflow(SomeDeprecatedWorkflow1WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result SomeDeprecatedMessage
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow run's workflow ID
func (r *testSomeDeprecatedWorkflow1Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomeDeprecatedWorkflow1Run) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomeDeprecatedWorkflow1Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeDeprecatedWorkflow1Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeDeprecatedQuery1 executes a mycompany.simple.Deprecated.SomeDeprecatedQuery1 query against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow
func (r *testSomeDeprecatedWorkflow1Run) SomeDeprecatedQuery1(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedQuery1(ctx, r.ID(), r.RunID(), req)
}

// SomeDeprecatedSignal1 executes a mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow
func (r *testSomeDeprecatedWorkflow1Run) SomeDeprecatedSignal1(ctx context.Context, req *SomeDeprecatedMessage) error {
	return r.client.SomeDeprecatedSignal1(ctx, r.ID(), r.RunID(), req)
}

// SomeDeprecatedUpdate1 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow
func (r *testSomeDeprecatedWorkflow1Run) SomeDeprecatedUpdate1(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedUpdate1(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeDeprecatedUpdate1Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate1 update against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow
func (r *testSomeDeprecatedWorkflow1Run) SomeDeprecatedUpdate1Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate1Options) (SomeDeprecatedUpdate1Handle, error) {
	return r.client.SomeDeprecatedUpdate1Async(ctx, r.ID(), r.RunID(), req, opts...)
}

var _ SomeDeprecatedWorkflow2Run = &testSomeDeprecatedWorkflow2Run{}

// testSomeDeprecatedWorkflow2Run provides convenience methods for interacting with a(n) mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow in the test environment
type testSomeDeprecatedWorkflow2Run struct {
	client    *TestDeprecatedClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SomeDeprecatedMessage
	workflows DeprecatedWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeDeprecatedWorkflow2Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow result
func (r *testSomeDeprecatedWorkflow2Run) Get(context.Context) (*SomeDeprecatedMessage, error) {
	r.env.ExecuteWorkflow(SomeDeprecatedWorkflow2WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result SomeDeprecatedMessage
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow run's workflow ID
func (r *testSomeDeprecatedWorkflow2Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomeDeprecatedWorkflow2Run) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomeDeprecatedWorkflow2Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeDeprecatedWorkflow2Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeDeprecatedQuery2 executes a mycompany.simple.Deprecated.SomeDeprecatedQuery2 query against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow
func (r *testSomeDeprecatedWorkflow2Run) SomeDeprecatedQuery2(ctx context.Context, req *SomeDeprecatedMessage) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedQuery2(ctx, r.ID(), r.RunID(), req)
}

// SomeDeprecatedSignal2 executes a mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow
func (r *testSomeDeprecatedWorkflow2Run) SomeDeprecatedSignal2(ctx context.Context, req *SomeDeprecatedMessage) error {
	return r.client.SomeDeprecatedSignal2(ctx, r.ID(), r.RunID(), req)
}

// SomeDeprecatedUpdate2 executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow
func (r *testSomeDeprecatedWorkflow2Run) SomeDeprecatedUpdate2(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (*SomeDeprecatedMessage, error) {
	return r.client.SomeDeprecatedUpdate2(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeDeprecatedUpdate2Async executes a(n) mycompany.simple.Deprecated.SomeDeprecatedUpdate2 update against a test mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow
func (r *testSomeDeprecatedWorkflow2Run) SomeDeprecatedUpdate2Async(ctx context.Context, req *SomeDeprecatedMessage, opts ...*SomeDeprecatedUpdate2Options) (SomeDeprecatedUpdate2Handle, error) {
	return r.client.SomeDeprecatedUpdate2Async(ctx, r.ID(), r.RunID(), req, opts...)
}

// DeprecatedCliOptions describes runtime configuration for mycompany.simple.Deprecated cli
type DeprecatedCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewDeprecatedCliOptions initializes a new DeprecatedCliOptions value
func NewDeprecatedCliOptions() *DeprecatedCliOptions {
	return &DeprecatedCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *DeprecatedCliOptions) WithAfter(fn func(*v2.Context) error) *DeprecatedCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *DeprecatedCliOptions) WithBefore(fn func(*v2.Context) error) *DeprecatedCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *DeprecatedCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *DeprecatedCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *DeprecatedCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *DeprecatedCliOptions {
	opts.worker = fn
	return opts
}

// NewDeprecatedCli initializes a cli for a(n) mycompany.simple.Deprecated service
func NewDeprecatedCli(options ...*DeprecatedCliOptions) (*v2.App, error) {
	commands, err := newDeprecatedCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "deprecated",
		Commands: commands,
	}, nil
}

// NewDeprecatedCliCommand initializes a cli command for a mycompany.simple.Deprecated service with subcommands for each query, signal, update, and workflow
func NewDeprecatedCliCommand(options ...*DeprecatedCliOptions) (*v2.Command, error) {
	subcommands, err := newDeprecatedCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "deprecated",
		Subcommands: subcommands,
	}, nil
}

// newDeprecatedCommands initializes (sub)commands for a mycompany.simple.Deprecated cli or command
func newDeprecatedCommands(options ...*DeprecatedCliOptions) ([]*v2.Command, error) {
	opts := &DeprecatedCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "some-deprecated-query-1",
			Usage:                  "SomeDeprecatedQuery1 does something else",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if resp, err := client.SomeDeprecatedQuery1(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error executing %q query: %w", SomeDeprecatedQuery1QueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-deprecated-query-2",
			Usage:                  "SomeDeprecatedQuery2 does something else Deprecated: a custom query deprecation message.",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if resp, err := client.SomeDeprecatedQuery2(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error executing %q query: %w", SomeDeprecatedQuery2QueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-deprecated-signal-1",
			Usage:                  "SomeDeprecatedSignal1 does something else",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SomeDeprecatedSignal1(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeDeprecatedSignal1SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "some-deprecated-signal-2",
			Usage:                  "SomeDeprecatedSignal2 does something else Deprecated: a custom signal deprecation message.",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SomeDeprecatedSignal2(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeDeprecatedSignal2SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "some-deprecated-update-1",
			Usage:                  "SomeDeprecatedUpdate1 does something else",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and udpate id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.SomeDeprecatedUpdate1Async(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", SomeDeprecatedUpdate1UpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-deprecated-update-2",
			Usage:                  "SomeDeprecatedUpdate2 does something else Deprecated: a custom signal deprecation message.",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and udpate id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.SomeDeprecatedUpdate2Async(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", SomeDeprecatedUpdate2UpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-deprecated-workflow-1",
			Usage:                  "SomeDeprecatedWorkflow1 does something",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "task-queue",
					Usage:    "task queue name",
					Aliases:  []string{"t"},
					EnvVars:  []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Required: true,
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewDeprecatedClient(tc)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomeDeprecatedWorkflow1Async(cmd.Context, req, NewSomeDeprecatedWorkflow1Options().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeDeprecatedWorkflow1WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// sends a mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow, starting it if necessary,
		{
			Name:                   "some-deprecated-workflow-1-with-some-deprecated-signal-1",
			Usage:                  "sends a mycompany.simple.Deprecated.SomeDeprecatedSignal1 signal to a mycompany.simple.Deprecated.SomeDeprecatedWorkflow1 workflow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.SomeDeprecatedWorkflow1WithSomeDeprecatedSignal1Async(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", SomeDeprecatedWorkflow1WorkflowName, SomeDeprecatedSignal1SignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "some-deprecated-workflow-2",
			Usage:                  "SomeDeprecatedWorkflow2 does something else Deprecated: a custom workflow deprecation message.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "task-queue",
					Usage:    "task queue name",
					Aliases:  []string{"t"},
					EnvVars:  []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Required: true,
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewDeprecatedClient(tc)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomeDeprecatedWorkflow2Async(cmd.Context, req, NewSomeDeprecatedWorkflow2Options().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeDeprecatedWorkflow2WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// sends a mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow, starting it if necessary,
		{
			Name:                   "some-deprecated-workflow-2-with-some-deprecated-signal-2",
			Usage:                  "sends a mycompany.simple.Deprecated.SomeDeprecatedSignal2 signal to a mycompany.simple.Deprecated.SomeDeprecatedWorkflow2 workflow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewDeprecatedClient(c)
				req, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := UnmarshalCliFlagsToSomeDeprecatedMessage(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.SomeDeprecatedWorkflow2WithSomeDeprecatedSignal2Async(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", SomeDeprecatedWorkflow2WorkflowName, SomeDeprecatedSignal2SignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.simple.Deprecated worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToSomeDeprecatedMessage unmarshals a SomeDeprecatedMessage from command line flags
func UnmarshalCliFlagsToSomeDeprecatedMessage(cmd *v2.Context) (*SomeDeprecatedMessage, error) {
	var result SomeDeprecatedMessage
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithDeprecatedSchemeTypes registers all Deprecated protobuf types with the given scheme
func WithDeprecatedSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_simple_v1_simple_proto.Messages().ByName("SomeDeprecatedMessage"))
	}
}
