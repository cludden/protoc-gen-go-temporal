// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.17.5-next (efa7ab451a198269bf7460cb7a4f6f34b94ebd4b)
//	protoc (unknown)
//
// source: test/acronym/v1/acronym.proto
package acronymv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"sync"
	"sync/atomic"
	"time"
)

// AWSTaskQueue is the default task-queue for a test.acronym.v1.AWS worker
var AWSTaskQueue = "aws-task-queue"

// test.acronym.v1.AWS workflow names
const (
	ManageAWSWorkflowName         = "test.acronym.v1.AWS.ManageAWS"
	ManageAWSResourceWorkflowName = "test.acronym.v1.AWS.ManageAWSResource"
	SomethingV1FooBarWorkflowName = "test.acronym.v1.AWS.SomethingV1FooBar"
	SomethingV2FooBarWorkflowName = "test.acronym.v1.AWS.SomethingV2FooBar"
)

// test.acronym.v1.AWS workflow id expressions
var (
	ManageAWSIdexpression         = expression.MustParseExpression("manage-aws/${! urn }/${! uuid_v4() }")
	ManageAWSResourceIdexpression = expression.MustParseExpression("manage-aws-resource/${! urn }/${! uuid_v4() }")
	SomethingV1FooBarIdexpression = expression.MustParseExpression("something-v1-foo-bar/${! urn }/${! uuid_v4() }")
	SomethingV2FooBarIdexpression = expression.MustParseExpression("something-v2-foo-bar/${! urn }/${! uuid_v4() }")
)

// test.acronym.v1.AWS activity names
const (
	ManageAWSResourceActivityName    = "test.acronym.v1.AWS.ManageAWSResource"
	ManageAWSResourceURNActivityName = "test.acronym.v1.AWS.ManageAWSResourceURN"
)

// AWSClient describes a client for a(n) test.acronym.v1.AWS worker
type AWSClient interface {
	// ManageAWS does some workflow thing.
	ManageAWS(ctx context.Context, req *ManageAWSRequest, opts ...*ManageAWSOptions) (*ManageAWSResponse, error)

	// ManageAWSAsync starts a(n) test.acronym.v1.AWS.ManageAWS workflow and returns a handle to the workflow run
	ManageAWSAsync(ctx context.Context, req *ManageAWSRequest, opts ...*ManageAWSOptions) (ManageAWSRun, error)

	// GetManageAWS retrieves a handle to an existing test.acronym.v1.AWS.ManageAWS workflow execution
	GetManageAWS(ctx context.Context, workflowID string, runID string) ManageAWSRun

	// ManageAWSResource does some workflow thing.
	ManageAWSResource(ctx context.Context, req *ManageAWSResourceRequest, opts ...*ManageAWSResourceOptions) (*ManageAWSResourceResponse, error)

	// ManageAWSResourceAsync starts a(n) test.acronym.v1.AWS.ManageAWSResource workflow and returns a handle to the workflow run
	ManageAWSResourceAsync(ctx context.Context, req *ManageAWSResourceRequest, opts ...*ManageAWSResourceOptions) (ManageAWSResourceRun, error)

	// GetManageAWSResource retrieves a handle to an existing test.acronym.v1.AWS.ManageAWSResource workflow execution
	GetManageAWSResource(ctx context.Context, workflowID string, runID string) ManageAWSResourceRun

	// SomethingV1FooBar does some workflow thing.
	SomethingV1FooBar(ctx context.Context, req *SomethingV1FooBarRequest, opts ...*SomethingV1FooBarOptions) (*SomethingV1FooBarResponse, error)

	// SomethingV1FooBarAsync starts a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow and returns a handle to the workflow run
	SomethingV1FooBarAsync(ctx context.Context, req *SomethingV1FooBarRequest, opts ...*SomethingV1FooBarOptions) (SomethingV1FooBarRun, error)

	// GetSomethingV1FooBar retrieves a handle to an existing test.acronym.v1.AWS.SomethingV1FooBar workflow execution
	GetSomethingV1FooBar(ctx context.Context, workflowID string, runID string) SomethingV1FooBarRun

	// SomethingV2FooBar does some workflow thing.
	SomethingV2FooBar(ctx context.Context, req *SomethingV2FooBarRequest, opts ...*SomethingV2FooBarOptions) (*SomethingV2FooBarResponse, error)

	// SomethingV2FooBarAsync starts a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow and returns a handle to the workflow run
	SomethingV2FooBarAsync(ctx context.Context, req *SomethingV2FooBarRequest, opts ...*SomethingV2FooBarOptions) (SomethingV2FooBarRun, error)

	// GetSomethingV2FooBar retrieves a handle to an existing test.acronym.v1.AWS.SomethingV2FooBar workflow execution
	GetSomethingV2FooBar(ctx context.Context, workflowID string, runID string) SomethingV2FooBarRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// awsClient implements a temporal client for a test.acronym.v1.AWS service
type awsClient struct {
	client client.Client
	log    *slog.Logger
}

// NewAWSClient initializes a new test.acronym.v1.AWS client
func NewAWSClient(c client.Client, options ...*awsClientOptions) AWSClient {
	var cfg *awsClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewAWSClientOptions()
	}
	return &awsClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewAWSClientWithOptions initializes a new AWS client with the given options
func NewAWSClientWithOptions(c client.Client, opts client.Options, options ...*awsClientOptions) (AWSClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *awsClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewAWSClientOptions()
	}
	return &awsClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// awsClientOptions describes optional runtime configuration for a AWSClient
type awsClientOptions struct {
	log *slog.Logger
}

// NewAWSClientOptions initializes a new awsClientOptions value
func NewAWSClientOptions() *awsClientOptions {
	return &awsClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *awsClientOptions) WithLogger(l *slog.Logger) *awsClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *awsClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// ManageAWS does some workflow thing.
func (c *awsClient) ManageAWS(ctx context.Context, req *ManageAWSRequest, options ...*ManageAWSOptions) (*ManageAWSResponse, error) {
	run, err := c.ManageAWSAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWS does some workflow thing.
func (c *awsClient) ManageAWSAsync(ctx context.Context, req *ManageAWSRequest, options ...*ManageAWSOptions) (ManageAWSRun, error) {
	var o *ManageAWSOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ManageAWSWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &manageAWSRun{
		client: c,
		run:    run,
	}, nil
}

// GetManageAWS fetches an existing test.acronym.v1.AWS.ManageAWS execution
func (c *awsClient) GetManageAWS(ctx context.Context, workflowID string, runID string) ManageAWSRun {
	return &manageAWSRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// ManageAWSResource does some workflow thing.
func (c *awsClient) ManageAWSResource(ctx context.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceOptions) (*ManageAWSResourceResponse, error) {
	run, err := c.ManageAWSResourceAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSResource does some workflow thing.
func (c *awsClient) ManageAWSResourceAsync(ctx context.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceOptions) (ManageAWSResourceRun, error) {
	var o *ManageAWSResourceOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ManageAWSResourceWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &manageAWSResourceRun{
		client: c,
		run:    run,
	}, nil
}

// GetManageAWSResource fetches an existing test.acronym.v1.AWS.ManageAWSResource execution
func (c *awsClient) GetManageAWSResource(ctx context.Context, workflowID string, runID string) ManageAWSResourceRun {
	return &manageAWSResourceRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomethingV1FooBar does some workflow thing.
func (c *awsClient) SomethingV1FooBar(ctx context.Context, req *SomethingV1FooBarRequest, options ...*SomethingV1FooBarOptions) (*SomethingV1FooBarResponse, error) {
	run, err := c.SomethingV1FooBarAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomethingV1FooBar does some workflow thing.
func (c *awsClient) SomethingV1FooBarAsync(ctx context.Context, req *SomethingV1FooBarRequest, options ...*SomethingV1FooBarOptions) (SomethingV1FooBarRun, error) {
	var o *SomethingV1FooBarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomethingV1FooBarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomethingV1FooBarWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &somethingV1FooBarRun{
		client: c,
		run:    run,
	}, nil
}

// GetSomethingV1FooBar fetches an existing test.acronym.v1.AWS.SomethingV1FooBar execution
func (c *awsClient) GetSomethingV1FooBar(ctx context.Context, workflowID string, runID string) SomethingV1FooBarRun {
	return &somethingV1FooBarRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomethingV2FooBar does some workflow thing.
func (c *awsClient) SomethingV2FooBar(ctx context.Context, req *SomethingV2FooBarRequest, options ...*SomethingV2FooBarOptions) (*SomethingV2FooBarResponse, error) {
	run, err := c.SomethingV2FooBarAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomethingV2FooBar does some workflow thing.
func (c *awsClient) SomethingV2FooBarAsync(ctx context.Context, req *SomethingV2FooBarRequest, options ...*SomethingV2FooBarOptions) (SomethingV2FooBarRun, error) {
	var o *SomethingV2FooBarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomethingV2FooBarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, SomethingV2FooBarWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &somethingV2FooBarRun{
		client: c,
		run:    run,
	}, nil
}

// GetSomethingV2FooBar fetches an existing test.acronym.v1.AWS.SomethingV2FooBar execution
func (c *awsClient) GetSomethingV2FooBar(ctx context.Context, workflowID string, runID string) SomethingV2FooBarRun {
	return &somethingV2FooBarRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *awsClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *awsClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// ManageAWSOptions provides configuration for a test.acronym.v1.AWS.ManageAWS workflow operation
type ManageAWSOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewManageAWSOptions initializes a new ManageAWSOptions value
func NewManageAWSOptions() *ManageAWSOptions {
	return &ManageAWSOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ManageAWSOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ManageAWSIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ManageAWSOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ManageAWSOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAWSOptions) WithExecutionTimeout(d time.Duration) *ManageAWSOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ManageAWSOptions) WithID(id string) *ManageAWSOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAWSOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAWSOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAWSOptions) WithRunTimeout(d time.Duration) *ManageAWSOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAWSOptions) WithSearchAttributes(sa map[string]any) *ManageAWSOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAWSOptions) WithTaskTimeout(d time.Duration) *ManageAWSOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAWSOptions) WithTaskQueue(tq string) *ManageAWSOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *ManageAWSOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *ManageAWSOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// ManageAWSRun describes a(n) test.acronym.v1.AWS.ManageAWS workflow run
type ManageAWSRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ManageAWSResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// manageAWSRun provides an internal implementation of a(n) ManageAWSRunRun
type manageAWSRun struct {
	client *awsClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *manageAWSRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *manageAWSRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *manageAWSRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *manageAWSRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *manageAWSRun) Get(ctx context.Context) (*ManageAWSResponse, error) {
	var resp ManageAWSResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *manageAWSRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// ManageAWSResourceOptions provides configuration for a test.acronym.v1.AWS.ManageAWSResource workflow operation
type ManageAWSResourceOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewManageAWSResourceOptions initializes a new ManageAWSResourceOptions value
func NewManageAWSResourceOptions() *ManageAWSResourceOptions {
	return &ManageAWSResourceOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ManageAWSResourceOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ManageAWSResourceIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSResourceWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ManageAWSResourceOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ManageAWSResourceOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAWSResourceOptions) WithExecutionTimeout(d time.Duration) *ManageAWSResourceOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ManageAWSResourceOptions) WithID(id string) *ManageAWSResourceOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAWSResourceOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAWSResourceOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSResourceOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSResourceOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAWSResourceOptions) WithRunTimeout(d time.Duration) *ManageAWSResourceOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAWSResourceOptions) WithSearchAttributes(sa map[string]any) *ManageAWSResourceOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAWSResourceOptions) WithTaskTimeout(d time.Duration) *ManageAWSResourceOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAWSResourceOptions) WithTaskQueue(tq string) *ManageAWSResourceOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *ManageAWSResourceOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *ManageAWSResourceOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// ManageAWSResourceRun describes a(n) test.acronym.v1.AWS.ManageAWSResource workflow run
type ManageAWSResourceRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ManageAWSResourceResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// manageAWSResourceRun provides an internal implementation of a(n) ManageAWSResourceRunRun
type manageAWSResourceRun struct {
	client *awsClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *manageAWSResourceRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *manageAWSResourceRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *manageAWSResourceRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *manageAWSResourceRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *manageAWSResourceRun) Get(ctx context.Context) (*ManageAWSResourceResponse, error) {
	var resp ManageAWSResourceResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *manageAWSResourceRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomethingV1FooBarOptions provides configuration for a test.acronym.v1.AWS.SomethingV1FooBar workflow operation
type SomethingV1FooBarOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewSomethingV1FooBarOptions initializes a new SomethingV1FooBarOptions value
func NewSomethingV1FooBarOptions() *SomethingV1FooBarOptions {
	return &SomethingV1FooBarOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomethingV1FooBarOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(SomethingV1FooBarIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV1FooBarWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomethingV1FooBarOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomethingV1FooBarOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomethingV1FooBarOptions) WithExecutionTimeout(d time.Duration) *SomethingV1FooBarOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomethingV1FooBarOptions) WithID(id string) *SomethingV1FooBarOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomethingV1FooBarOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomethingV1FooBarOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomethingV1FooBarOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomethingV1FooBarOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomethingV1FooBarOptions) WithRunTimeout(d time.Duration) *SomethingV1FooBarOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomethingV1FooBarOptions) WithSearchAttributes(sa map[string]any) *SomethingV1FooBarOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomethingV1FooBarOptions) WithTaskTimeout(d time.Duration) *SomethingV1FooBarOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomethingV1FooBarOptions) WithTaskQueue(tq string) *SomethingV1FooBarOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *SomethingV1FooBarOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *SomethingV1FooBarOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// SomethingV1FooBarRun describes a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow run
type SomethingV1FooBarRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomethingV1FooBarResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// somethingV1FooBarRun provides an internal implementation of a(n) SomethingV1FooBarRunRun
type somethingV1FooBarRun struct {
	client *awsClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *somethingV1FooBarRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *somethingV1FooBarRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *somethingV1FooBarRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *somethingV1FooBarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *somethingV1FooBarRun) Get(ctx context.Context) (*SomethingV1FooBarResponse, error) {
	var resp SomethingV1FooBarResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *somethingV1FooBarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomethingV2FooBarOptions provides configuration for a test.acronym.v1.AWS.SomethingV2FooBar workflow operation
type SomethingV2FooBarOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewSomethingV2FooBarOptions initializes a new SomethingV2FooBarOptions value
func NewSomethingV2FooBarOptions() *SomethingV2FooBarOptions {
	return &SomethingV2FooBarOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *SomethingV2FooBarOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(SomethingV2FooBarIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV2FooBarWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *SomethingV2FooBarOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomethingV2FooBarOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomethingV2FooBarOptions) WithExecutionTimeout(d time.Duration) *SomethingV2FooBarOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *SomethingV2FooBarOptions) WithID(id string) *SomethingV2FooBarOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomethingV2FooBarOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomethingV2FooBarOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomethingV2FooBarOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomethingV2FooBarOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomethingV2FooBarOptions) WithRunTimeout(d time.Duration) *SomethingV2FooBarOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomethingV2FooBarOptions) WithSearchAttributes(sa map[string]any) *SomethingV2FooBarOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomethingV2FooBarOptions) WithTaskTimeout(d time.Duration) *SomethingV2FooBarOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomethingV2FooBarOptions) WithTaskQueue(tq string) *SomethingV2FooBarOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *SomethingV2FooBarOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *SomethingV2FooBarOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// SomethingV2FooBarRun describes a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow run
type SomethingV2FooBarRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomethingV2FooBarResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// somethingV2FooBarRun provides an internal implementation of a(n) SomethingV2FooBarRunRun
type somethingV2FooBarRun struct {
	client *awsClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *somethingV2FooBarRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *somethingV2FooBarRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *somethingV2FooBarRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *somethingV2FooBarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *somethingV2FooBarRun) Get(ctx context.Context) (*SomethingV2FooBarResponse, error) {
	var resp SomethingV2FooBarResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *somethingV2FooBarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// awsRegistrationMutex is a mutex for registering test.acronym.v1.AWS workflows
	awsRegistrationMutex sync.Mutex
	// ManageAWS does some workflow thing.
	ManageAWSFunction func(workflow.Context, *ManageAWSRequest) (*ManageAWSResponse, error)
	// ManageAWSResource does some workflow thing.
	ManageAWSResourceFunction func(workflow.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)
	// SomethingV1FooBar does some workflow thing.
	SomethingV1FooBarFunction func(workflow.Context, *SomethingV1FooBarRequest) (*SomethingV1FooBarResponse, error)
	// SomethingV2FooBar does some workflow thing.
	SomethingV2FooBarFunction func(workflow.Context, *SomethingV2FooBarRequest) (*SomethingV2FooBarResponse, error)
)

// AWSWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// AWSWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	AWSWorkflowFunctions interface {
		// ManageAWS does some workflow thing.
		ManageAWS(workflow.Context, *ManageAWSRequest) (*ManageAWSResponse, error)
		// ManageAWSResource does some workflow thing.
		ManageAWSResource(workflow.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)
		// SomethingV1FooBar does some workflow thing.
		SomethingV1FooBar(workflow.Context, *SomethingV1FooBarRequest) (*SomethingV1FooBarResponse, error)
		// SomethingV2FooBar does some workflow thing.
		SomethingV2FooBar(workflow.Context, *SomethingV2FooBarRequest) (*SomethingV2FooBarResponse, error)
	}
	// awsWorkflowFunctions provides an internal AWSWorkflowFunctions implementation
	awsWorkflowFunctions struct{}
)

func NewAWSWorkflowFunctions() AWSWorkflowFunctions {
	return &awsWorkflowFunctions{}
}

// ManageAWS does some workflow thing.
func (f *awsWorkflowFunctions) ManageAWS(ctx workflow.Context, req *ManageAWSRequest) (*ManageAWSResponse, error) {
	if ManageAWSFunction == nil {
		return nil, errors.New("ManageAWS requires workflow registration via RegisterAWSWorkflows or RegisterManageAWSWorkflow")
	}
	return ManageAWSFunction(ctx, req)
}

// ManageAWSResource does some workflow thing.
func (f *awsWorkflowFunctions) ManageAWSResource(ctx workflow.Context, req *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error) {
	if ManageAWSResourceFunction == nil {
		return nil, errors.New("ManageAWSResource requires workflow registration via RegisterAWSWorkflows or RegisterManageAWSResourceWorkflow")
	}
	return ManageAWSResourceFunction(ctx, req)
}

// SomethingV1FooBar does some workflow thing.
func (f *awsWorkflowFunctions) SomethingV1FooBar(ctx workflow.Context, req *SomethingV1FooBarRequest) (*SomethingV1FooBarResponse, error) {
	if SomethingV1FooBarFunction == nil {
		return nil, errors.New("SomethingV1FooBar requires workflow registration via RegisterAWSWorkflows or RegisterSomethingV1FooBarWorkflow")
	}
	return SomethingV1FooBarFunction(ctx, req)
}

// SomethingV2FooBar does some workflow thing.
func (f *awsWorkflowFunctions) SomethingV2FooBar(ctx workflow.Context, req *SomethingV2FooBarRequest) (*SomethingV2FooBarResponse, error) {
	if SomethingV2FooBarFunction == nil {
		return nil, errors.New("SomethingV2FooBar requires workflow registration via RegisterAWSWorkflows or RegisterSomethingV2FooBarWorkflow")
	}
	return SomethingV2FooBarFunction(ctx, req)
}

// AWSWorkflows provides methods for initializing new test.acronym.v1.AWS workflow values
type AWSWorkflows interface {
	// ManageAWS does some workflow thing.
	ManageAWS(ctx workflow.Context, input *ManageAWSWorkflowInput) (ManageAWSWorkflow, error)

	// ManageAWSResource does some workflow thing.
	ManageAWSResource(ctx workflow.Context, input *ManageAWSResourceWorkflowInput) (ManageAWSResourceWorkflow, error)

	// SomethingV1FooBar does some workflow thing.
	SomethingV1FooBar(ctx workflow.Context, input *SomethingV1FooBarWorkflowInput) (SomethingV1FooBarWorkflow, error)

	// SomethingV2FooBar does some workflow thing.
	SomethingV2FooBar(ctx workflow.Context, input *SomethingV2FooBarWorkflowInput) (SomethingV2FooBarWorkflow, error)
}

// RegisterAWSWorkflows registers test.acronym.v1.AWS workflows with the given worker
func RegisterAWSWorkflows(r worker.WorkflowRegistry, workflows AWSWorkflows) {
	RegisterManageAWSWorkflow(r, workflows.ManageAWS)
	RegisterManageAWSResourceWorkflow(r, workflows.ManageAWSResource)
	RegisterSomethingV1FooBarWorkflow(r, workflows.SomethingV1FooBar)
	RegisterSomethingV2FooBarWorkflow(r, workflows.SomethingV2FooBar)
}

// RegisterManageAWSWorkflow registers a test.acronym.v1.AWS.ManageAWS workflow with the given worker
func RegisterManageAWSWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ManageAWSWorkflowInput) (ManageAWSWorkflow, error)) {
	awsRegistrationMutex.Lock()
	defer awsRegistrationMutex.Unlock()
	ManageAWSFunction = buildManageAWS(wf)
	r.RegisterWorkflowWithOptions(ManageAWSFunction, workflow.RegisterOptions{Name: ManageAWSWorkflowName})
}

// buildManageAWS converts a ManageAWS workflow struct into a valid workflow function
func buildManageAWS(ctor func(workflow.Context, *ManageAWSWorkflowInput) (ManageAWSWorkflow, error)) func(workflow.Context, *ManageAWSRequest) (*ManageAWSResponse, error) {
	return func(ctx workflow.Context, req *ManageAWSRequest) (*ManageAWSResponse, error) {
		input := &ManageAWSWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ManageAWSWorkflowInput describes the input to a(n) test.acronym.v1.AWS.ManageAWS workflow constructor
type ManageAWSWorkflowInput struct {
	Req *ManageAWSRequest
}

// ManageAWS does some workflow thing.
//
// workflow details: (name: "test.acronym.v1.AWS.ManageAWS", id: "manage-aws/${! urn }/${! uuid_v4() }")
type ManageAWSWorkflow interface {
	// Execute defines the entrypoint to a(n) test.acronym.v1.AWS.ManageAWS workflow
	Execute(ctx workflow.Context) (*ManageAWSResponse, error)
}

// ManageAWS does some workflow thing.
func ManageAWSChild(ctx workflow.Context, req *ManageAWSRequest, options ...*ManageAWSChildOptions) (*ManageAWSResponse, error) {
	childRun, err := ManageAWSChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ManageAWS does some workflow thing.
func ManageAWSChildAsync(ctx workflow.Context, req *ManageAWSRequest, options ...*ManageAWSChildOptions) (*ManageAWSChildRun, error) {
	var o *ManageAWSChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &ManageAWSChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ManageAWSWorkflowName, req)}, nil
}

// ManageAWSChildOptions provides configuration for a child test.acronym.v1.AWS.ManageAWS workflow operation
type ManageAWSChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewManageAWSChildOptions initializes a new ManageAWSChildOptions value
func NewManageAWSChildOptions() *ManageAWSChildOptions {
	return &ManageAWSChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ManageAWSChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ManageAWSIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ManageAWSIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ManageAWSChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ManageAWSChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *ManageAWSChildOptions) WithDataConverter(dc converter.DataConverter) *ManageAWSChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAWSChildOptions) WithExecutionTimeout(d time.Duration) *ManageAWSChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ManageAWSChildOptions) WithID(id string) *ManageAWSChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAWSChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAWSChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAWSChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ManageAWSChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAWSChildOptions) WithRunTimeout(d time.Duration) *ManageAWSChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAWSChildOptions) WithSearchAttributes(sa map[string]any) *ManageAWSChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAWSChildOptions) WithTaskTimeout(d time.Duration) *ManageAWSChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAWSChildOptions) WithTaskQueue(tq string) *ManageAWSChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ManageAWSChildOptions) WithWaitForCancellation(wait bool) *ManageAWSChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *ManageAWSChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *ManageAWSChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// ManageAWSChildRun describes a child ManageAWS workflow run
type ManageAWSChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ManageAWSChildRun) Get(ctx workflow.Context) (*ManageAWSResponse, error) {
	var resp ManageAWSResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ManageAWSChildRun) Select(sel workflow.Selector, fn func(*ManageAWSChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ManageAWSChildRun) SelectStart(sel workflow.Selector, fn func(*ManageAWSChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ManageAWSChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterManageAWSResourceWorkflow registers a test.acronym.v1.AWS.ManageAWSResource workflow with the given worker
func RegisterManageAWSResourceWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ManageAWSResourceWorkflowInput) (ManageAWSResourceWorkflow, error)) {
	awsRegistrationMutex.Lock()
	defer awsRegistrationMutex.Unlock()
	ManageAWSResourceFunction = buildManageAWSResource(wf)
	r.RegisterWorkflowWithOptions(ManageAWSResourceFunction, workflow.RegisterOptions{Name: ManageAWSResourceWorkflowName})
}

// buildManageAWSResource converts a ManageAWSResource workflow struct into a valid workflow function
func buildManageAWSResource(ctor func(workflow.Context, *ManageAWSResourceWorkflowInput) (ManageAWSResourceWorkflow, error)) func(workflow.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error) {
	return func(ctx workflow.Context, req *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error) {
		input := &ManageAWSResourceWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ManageAWSResourceWorkflowInput describes the input to a(n) test.acronym.v1.AWS.ManageAWSResource workflow constructor
type ManageAWSResourceWorkflowInput struct {
	Req *ManageAWSResourceRequest
}

// ManageAWSResource does some workflow thing.
//
// workflow details: (name: "test.acronym.v1.AWS.ManageAWSResource", id: "manage-aws-resource/${! urn }/${! uuid_v4() }")
type ManageAWSResourceWorkflow interface {
	// Execute defines the entrypoint to a(n) test.acronym.v1.AWS.ManageAWSResource workflow
	Execute(ctx workflow.Context) (*ManageAWSResourceResponse, error)
}

// ManageAWSResource does some workflow thing.
func ManageAWSResourceChild(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceChildOptions) (*ManageAWSResourceResponse, error) {
	childRun, err := ManageAWSResourceChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ManageAWSResource does some workflow thing.
func ManageAWSResourceChildAsync(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceChildOptions) (*ManageAWSResourceChildRun, error) {
	var o *ManageAWSResourceChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &ManageAWSResourceChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ManageAWSResourceWorkflowName, req)}, nil
}

// ManageAWSResourceChildOptions provides configuration for a child test.acronym.v1.AWS.ManageAWSResource workflow operation
type ManageAWSResourceChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewManageAWSResourceChildOptions initializes a new ManageAWSResourceChildOptions value
func NewManageAWSResourceChildOptions() *ManageAWSResourceChildOptions {
	return &ManageAWSResourceChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ManageAWSResourceChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ManageAWSResourceIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSResourceWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSResourceWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ManageAWSResourceIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAWSResourceWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ManageAWSResourceChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ManageAWSResourceChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *ManageAWSResourceChildOptions) WithDataConverter(dc converter.DataConverter) *ManageAWSResourceChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAWSResourceChildOptions) WithExecutionTimeout(d time.Duration) *ManageAWSResourceChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ManageAWSResourceChildOptions) WithID(id string) *ManageAWSResourceChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAWSResourceChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAWSResourceChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAWSResourceChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ManageAWSResourceChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSResourceChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSResourceChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAWSResourceChildOptions) WithRunTimeout(d time.Duration) *ManageAWSResourceChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAWSResourceChildOptions) WithSearchAttributes(sa map[string]any) *ManageAWSResourceChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAWSResourceChildOptions) WithTaskTimeout(d time.Duration) *ManageAWSResourceChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAWSResourceChildOptions) WithTaskQueue(tq string) *ManageAWSResourceChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ManageAWSResourceChildOptions) WithWaitForCancellation(wait bool) *ManageAWSResourceChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *ManageAWSResourceChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *ManageAWSResourceChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// ManageAWSResourceChildRun describes a child ManageAWSResource workflow run
type ManageAWSResourceChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ManageAWSResourceChildRun) Get(ctx workflow.Context) (*ManageAWSResourceResponse, error) {
	var resp ManageAWSResourceResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ManageAWSResourceChildRun) Select(sel workflow.Selector, fn func(*ManageAWSResourceChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ManageAWSResourceChildRun) SelectStart(sel workflow.Selector, fn func(*ManageAWSResourceChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ManageAWSResourceChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterSomethingV1FooBarWorkflow registers a test.acronym.v1.AWS.SomethingV1FooBar workflow with the given worker
func RegisterSomethingV1FooBarWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomethingV1FooBarWorkflowInput) (SomethingV1FooBarWorkflow, error)) {
	awsRegistrationMutex.Lock()
	defer awsRegistrationMutex.Unlock()
	SomethingV1FooBarFunction = buildSomethingV1FooBar(wf)
	r.RegisterWorkflowWithOptions(SomethingV1FooBarFunction, workflow.RegisterOptions{Name: SomethingV1FooBarWorkflowName})
}

// buildSomethingV1FooBar converts a SomethingV1FooBar workflow struct into a valid workflow function
func buildSomethingV1FooBar(ctor func(workflow.Context, *SomethingV1FooBarWorkflowInput) (SomethingV1FooBarWorkflow, error)) func(workflow.Context, *SomethingV1FooBarRequest) (*SomethingV1FooBarResponse, error) {
	return func(ctx workflow.Context, req *SomethingV1FooBarRequest) (*SomethingV1FooBarResponse, error) {
		input := &SomethingV1FooBarWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomethingV1FooBarWorkflowInput describes the input to a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow constructor
type SomethingV1FooBarWorkflowInput struct {
	Req *SomethingV1FooBarRequest
}

// SomethingV1FooBar does some workflow thing.
//
// workflow details: (name: "test.acronym.v1.AWS.SomethingV1FooBar", id: "something-v1-foo-bar/${! urn }/${! uuid_v4() }")
type SomethingV1FooBarWorkflow interface {
	// Execute defines the entrypoint to a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow
	Execute(ctx workflow.Context) (*SomethingV1FooBarResponse, error)
}

// SomethingV1FooBar does some workflow thing.
func SomethingV1FooBarChild(ctx workflow.Context, req *SomethingV1FooBarRequest, options ...*SomethingV1FooBarChildOptions) (*SomethingV1FooBarResponse, error) {
	childRun, err := SomethingV1FooBarChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomethingV1FooBar does some workflow thing.
func SomethingV1FooBarChildAsync(ctx workflow.Context, req *SomethingV1FooBarRequest, options ...*SomethingV1FooBarChildOptions) (*SomethingV1FooBarChildRun, error) {
	var o *SomethingV1FooBarChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomethingV1FooBarChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &SomethingV1FooBarChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomethingV1FooBarWorkflowName, req)}, nil
}

// SomethingV1FooBarChildOptions provides configuration for a child test.acronym.v1.AWS.SomethingV1FooBar workflow operation
type SomethingV1FooBarChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewSomethingV1FooBarChildOptions initializes a new SomethingV1FooBarChildOptions value
func NewSomethingV1FooBarChildOptions() *SomethingV1FooBarChildOptions {
	return &SomethingV1FooBarChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomethingV1FooBarChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(SomethingV1FooBarIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV1FooBarWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV1FooBarWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(SomethingV1FooBarIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV1FooBarWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomethingV1FooBarChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomethingV1FooBarChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *SomethingV1FooBarChildOptions) WithDataConverter(dc converter.DataConverter) *SomethingV1FooBarChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomethingV1FooBarChildOptions) WithExecutionTimeout(d time.Duration) *SomethingV1FooBarChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomethingV1FooBarChildOptions) WithID(id string) *SomethingV1FooBarChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomethingV1FooBarChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomethingV1FooBarChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomethingV1FooBarChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomethingV1FooBarChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomethingV1FooBarChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomethingV1FooBarChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomethingV1FooBarChildOptions) WithRunTimeout(d time.Duration) *SomethingV1FooBarChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomethingV1FooBarChildOptions) WithSearchAttributes(sa map[string]any) *SomethingV1FooBarChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomethingV1FooBarChildOptions) WithTaskTimeout(d time.Duration) *SomethingV1FooBarChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomethingV1FooBarChildOptions) WithTaskQueue(tq string) *SomethingV1FooBarChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomethingV1FooBarChildOptions) WithWaitForCancellation(wait bool) *SomethingV1FooBarChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *SomethingV1FooBarChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *SomethingV1FooBarChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// SomethingV1FooBarChildRun describes a child SomethingV1FooBar workflow run
type SomethingV1FooBarChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomethingV1FooBarChildRun) Get(ctx workflow.Context) (*SomethingV1FooBarResponse, error) {
	var resp SomethingV1FooBarResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomethingV1FooBarChildRun) Select(sel workflow.Selector, fn func(*SomethingV1FooBarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomethingV1FooBarChildRun) SelectStart(sel workflow.Selector, fn func(*SomethingV1FooBarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomethingV1FooBarChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterSomethingV2FooBarWorkflow registers a test.acronym.v1.AWS.SomethingV2FooBar workflow with the given worker
func RegisterSomethingV2FooBarWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomethingV2FooBarWorkflowInput) (SomethingV2FooBarWorkflow, error)) {
	awsRegistrationMutex.Lock()
	defer awsRegistrationMutex.Unlock()
	SomethingV2FooBarFunction = buildSomethingV2FooBar(wf)
	r.RegisterWorkflowWithOptions(SomethingV2FooBarFunction, workflow.RegisterOptions{Name: SomethingV2FooBarWorkflowName})
}

// buildSomethingV2FooBar converts a SomethingV2FooBar workflow struct into a valid workflow function
func buildSomethingV2FooBar(ctor func(workflow.Context, *SomethingV2FooBarWorkflowInput) (SomethingV2FooBarWorkflow, error)) func(workflow.Context, *SomethingV2FooBarRequest) (*SomethingV2FooBarResponse, error) {
	return func(ctx workflow.Context, req *SomethingV2FooBarRequest) (*SomethingV2FooBarResponse, error) {
		input := &SomethingV2FooBarWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomethingV2FooBarWorkflowInput describes the input to a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow constructor
type SomethingV2FooBarWorkflowInput struct {
	Req *SomethingV2FooBarRequest
}

// SomethingV2FooBar does some workflow thing.
//
// workflow details: (name: "test.acronym.v1.AWS.SomethingV2FooBar", id: "something-v2-foo-bar/${! urn }/${! uuid_v4() }")
type SomethingV2FooBarWorkflow interface {
	// Execute defines the entrypoint to a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow
	Execute(ctx workflow.Context) (*SomethingV2FooBarResponse, error)
}

// SomethingV2FooBar does some workflow thing.
func SomethingV2FooBarChild(ctx workflow.Context, req *SomethingV2FooBarRequest, options ...*SomethingV2FooBarChildOptions) (*SomethingV2FooBarResponse, error) {
	childRun, err := SomethingV2FooBarChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomethingV2FooBar does some workflow thing.
func SomethingV2FooBarChildAsync(ctx workflow.Context, req *SomethingV2FooBarRequest, options ...*SomethingV2FooBarChildOptions) (*SomethingV2FooBarChildRun, error) {
	var o *SomethingV2FooBarChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomethingV2FooBarChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &SomethingV2FooBarChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomethingV2FooBarWorkflowName, req)}, nil
}

// SomethingV2FooBarChildOptions provides configuration for a child test.acronym.v1.AWS.SomethingV2FooBar workflow operation
type SomethingV2FooBarChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewSomethingV2FooBarChildOptions initializes a new SomethingV2FooBarChildOptions value
func NewSomethingV2FooBarChildOptions() *SomethingV2FooBarChildOptions {
	return &SomethingV2FooBarChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *SomethingV2FooBarChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(SomethingV2FooBarIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV2FooBarWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV2FooBarWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(SomethingV2FooBarIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", SomethingV2FooBarWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *SomethingV2FooBarChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomethingV2FooBarChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *SomethingV2FooBarChildOptions) WithDataConverter(dc converter.DataConverter) *SomethingV2FooBarChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *SomethingV2FooBarChildOptions) WithExecutionTimeout(d time.Duration) *SomethingV2FooBarChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *SomethingV2FooBarChildOptions) WithID(id string) *SomethingV2FooBarChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *SomethingV2FooBarChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *SomethingV2FooBarChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *SomethingV2FooBarChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomethingV2FooBarChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *SomethingV2FooBarChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *SomethingV2FooBarChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *SomethingV2FooBarChildOptions) WithRunTimeout(d time.Duration) *SomethingV2FooBarChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *SomethingV2FooBarChildOptions) WithSearchAttributes(sa map[string]any) *SomethingV2FooBarChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *SomethingV2FooBarChildOptions) WithTaskTimeout(d time.Duration) *SomethingV2FooBarChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *SomethingV2FooBarChildOptions) WithTaskQueue(tq string) *SomethingV2FooBarChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *SomethingV2FooBarChildOptions) WithWaitForCancellation(wait bool) *SomethingV2FooBarChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *SomethingV2FooBarChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *SomethingV2FooBarChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// SomethingV2FooBarChildRun describes a child SomethingV2FooBar workflow run
type SomethingV2FooBarChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomethingV2FooBarChildRun) Get(ctx workflow.Context) (*SomethingV2FooBarResponse, error) {
	var resp SomethingV2FooBarResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomethingV2FooBarChildRun) Select(sel workflow.Selector, fn func(*SomethingV2FooBarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomethingV2FooBarChildRun) SelectStart(sel workflow.Selector, fn func(*SomethingV2FooBarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomethingV2FooBarChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// AWSActivities describes available worker activities
type AWSActivities interface {
	// ManageAWSResource does some workflow thing.
	ManageAWSResource(ctx context.Context, req *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)

	// ManageAWSResourceURN does some workflow thing.
	ManageAWSResourceURN(ctx context.Context, req *ManageAWSResourceURNRequest) (*ManageAWSResourceURNResponse, error)
}

// RegisterAWSActivities registers activities with a worker
func RegisterAWSActivities(r worker.ActivityRegistry, activities AWSActivities) {
	RegisterManageAWSResourceActivity(r, activities.ManageAWSResource)
	RegisterManageAWSResourceURNActivity(r, activities.ManageAWSResourceURN)
}

// RegisterManageAWSResourceActivity registers a test.acronym.v1.AWS.ManageAWSResource activity
func RegisterManageAWSResourceActivity(r worker.ActivityRegistry, fn func(context.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: ManageAWSResourceActivityName,
	})
}

// ManageAWSResourceFuture describes a(n) test.acronym.v1.AWS.ManageAWSResource activity execution
type ManageAWSResourceFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *ManageAWSResourceFuture) Get(ctx workflow.Context) (*ManageAWSResourceResponse, error) {
	var resp ManageAWSResourceResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *ManageAWSResourceFuture) Select(sel workflow.Selector, fn func(*ManageAWSResourceFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// ManageAWSResource does some workflow thing.
func ManageAWSResource(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceActivityOptions) (*ManageAWSResourceResponse, error) {
	return ManageAWSResourceAsync(ctx, req, options...).Get(ctx)
}

// ManageAWSResource does some workflow thing.
func ManageAWSResourceAsync(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceActivityOptions) *ManageAWSResourceFuture {
	var o *ManageAWSResourceActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &ManageAWSResourceFuture{Future: errF}
	}
	activity := ManageAWSResourceActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &ManageAWSResourceFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// ManageAWSResource does some workflow thing.
func ManageAWSResourceLocal(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceLocalActivityOptions) (*ManageAWSResourceResponse, error) {
	return ManageAWSResourceLocalAsync(ctx, req, options...).Get(ctx)
}

// ManageAWSResource does some workflow thing.
func ManageAWSResourceLocalAsync(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceLocalActivityOptions) *ManageAWSResourceFuture {
	var o *ManageAWSResourceLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &ManageAWSResourceFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = ManageAWSResourceActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &ManageAWSResourceFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// ManageAWSResourceActivityOptions provides configuration for a(n) test.acronym.v1.AWS.ManageAWSResource activity
type ManageAWSResourceActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewManageAWSResourceActivityOptions initializes a new ManageAWSResourceActivityOptions value
func NewManageAWSResourceActivityOptions() *ManageAWSResourceActivityOptions {
	return &ManageAWSResourceActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *ManageAWSResourceActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 60000000000 // 1 minute
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *ManageAWSResourceActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *ManageAWSResourceActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *ManageAWSResourceActivityOptions) WithDataConverter(dc converter.DataConverter) *ManageAWSResourceActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *ManageAWSResourceActivityOptions) WithHeartbeatTimeout(d time.Duration) *ManageAWSResourceActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSResourceActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSResourceActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *ManageAWSResourceActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *ManageAWSResourceActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *ManageAWSResourceActivityOptions) WithScheduleToStartTimeout(d time.Duration) *ManageAWSResourceActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *ManageAWSResourceActivityOptions) WithStartToCloseTimeout(d time.Duration) *ManageAWSResourceActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAWSResourceActivityOptions) WithTaskQueue(tq string) *ManageAWSResourceActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ManageAWSResourceActivityOptions) WithWaitForCancellation(wait bool) *ManageAWSResourceActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// ManageAWSResourceLocalActivityOptions provides configuration for a(n) test.acronym.v1.AWS.ManageAWSResource activity
type ManageAWSResourceLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)
}

// NewManageAWSResourceLocalActivityOptions initializes a new ManageAWSResourceLocalActivityOptions value
func NewManageAWSResourceLocalActivityOptions() *ManageAWSResourceLocalActivityOptions {
	return &ManageAWSResourceLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *ManageAWSResourceLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 60000000000 // 1 minute
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.acronym.v1.AWS.ManageAWSResource implementation
func (o *ManageAWSResourceLocalActivityOptions) Local(fn func(context.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)) *ManageAWSResourceLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *ManageAWSResourceLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *ManageAWSResourceLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *ManageAWSResourceLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *ManageAWSResourceLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSResourceLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSResourceLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *ManageAWSResourceLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *ManageAWSResourceLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *ManageAWSResourceLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *ManageAWSResourceLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// RegisterManageAWSResourceURNActivity registers a test.acronym.v1.AWS.ManageAWSResourceURN activity
func RegisterManageAWSResourceURNActivity(r worker.ActivityRegistry, fn func(context.Context, *ManageAWSResourceURNRequest) (*ManageAWSResourceURNResponse, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: ManageAWSResourceURNActivityName,
	})
}

// ManageAWSResourceURNFuture describes a(n) test.acronym.v1.AWS.ManageAWSResourceURN activity execution
type ManageAWSResourceURNFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *ManageAWSResourceURNFuture) Get(ctx workflow.Context) (*ManageAWSResourceURNResponse, error) {
	var resp ManageAWSResourceURNResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *ManageAWSResourceURNFuture) Select(sel workflow.Selector, fn func(*ManageAWSResourceURNFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// ManageAWSResourceURN does some workflow thing.
func ManageAWSResourceURN(ctx workflow.Context, req *ManageAWSResourceURNRequest, options ...*ManageAWSResourceURNActivityOptions) (*ManageAWSResourceURNResponse, error) {
	return ManageAWSResourceURNAsync(ctx, req, options...).Get(ctx)
}

// ManageAWSResourceURN does some workflow thing.
func ManageAWSResourceURNAsync(ctx workflow.Context, req *ManageAWSResourceURNRequest, options ...*ManageAWSResourceURNActivityOptions) *ManageAWSResourceURNFuture {
	var o *ManageAWSResourceURNActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceURNActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &ManageAWSResourceURNFuture{Future: errF}
	}
	activity := ManageAWSResourceURNActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &ManageAWSResourceURNFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// ManageAWSResourceURN does some workflow thing.
func ManageAWSResourceURNLocal(ctx workflow.Context, req *ManageAWSResourceURNRequest, options ...*ManageAWSResourceURNLocalActivityOptions) (*ManageAWSResourceURNResponse, error) {
	return ManageAWSResourceURNLocalAsync(ctx, req, options...).Get(ctx)
}

// ManageAWSResourceURN does some workflow thing.
func ManageAWSResourceURNLocalAsync(ctx workflow.Context, req *ManageAWSResourceURNRequest, options ...*ManageAWSResourceURNLocalActivityOptions) *ManageAWSResourceURNFuture {
	var o *ManageAWSResourceURNLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceURNLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &ManageAWSResourceURNFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = ManageAWSResourceURNActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &ManageAWSResourceURNFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// ManageAWSResourceURNActivityOptions provides configuration for a(n) test.acronym.v1.AWS.ManageAWSResourceURN activity
type ManageAWSResourceURNActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewManageAWSResourceURNActivityOptions initializes a new ManageAWSResourceURNActivityOptions value
func NewManageAWSResourceURNActivityOptions() *ManageAWSResourceURNActivityOptions {
	return &ManageAWSResourceURNActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *ManageAWSResourceURNActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 60000000000 // 1 minute
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AWSTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *ManageAWSResourceURNActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *ManageAWSResourceURNActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *ManageAWSResourceURNActivityOptions) WithDataConverter(dc converter.DataConverter) *ManageAWSResourceURNActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *ManageAWSResourceURNActivityOptions) WithHeartbeatTimeout(d time.Duration) *ManageAWSResourceURNActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSResourceURNActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSResourceURNActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *ManageAWSResourceURNActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *ManageAWSResourceURNActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *ManageAWSResourceURNActivityOptions) WithScheduleToStartTimeout(d time.Duration) *ManageAWSResourceURNActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *ManageAWSResourceURNActivityOptions) WithStartToCloseTimeout(d time.Duration) *ManageAWSResourceURNActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAWSResourceURNActivityOptions) WithTaskQueue(tq string) *ManageAWSResourceURNActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ManageAWSResourceURNActivityOptions) WithWaitForCancellation(wait bool) *ManageAWSResourceURNActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// ManageAWSResourceURNLocalActivityOptions provides configuration for a(n) test.acronym.v1.AWS.ManageAWSResourceURN activity
type ManageAWSResourceURNLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *ManageAWSResourceURNRequest) (*ManageAWSResourceURNResponse, error)
}

// NewManageAWSResourceURNLocalActivityOptions initializes a new ManageAWSResourceURNLocalActivityOptions value
func NewManageAWSResourceURNLocalActivityOptions() *ManageAWSResourceURNLocalActivityOptions {
	return &ManageAWSResourceURNLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *ManageAWSResourceURNLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 60000000000 // 1 minute
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.acronym.v1.AWS.ManageAWSResourceURN implementation
func (o *ManageAWSResourceURNLocalActivityOptions) Local(fn func(context.Context, *ManageAWSResourceURNRequest) (*ManageAWSResourceURNResponse, error)) *ManageAWSResourceURNLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *ManageAWSResourceURNLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *ManageAWSResourceURNLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *ManageAWSResourceURNLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *ManageAWSResourceURNLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAWSResourceURNLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAWSResourceURNLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *ManageAWSResourceURNLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *ManageAWSResourceURNLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *ManageAWSResourceURNLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *ManageAWSResourceURNLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestAWSClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows AWSWorkflows
}

var _ AWSClient = &TestAWSClient{}

// NewTestAWSClient initializes a new TestAWSClient value
func NewTestAWSClient(env *testsuite.TestWorkflowEnvironment, workflows AWSWorkflows, activities AWSActivities) *TestAWSClient {
	if workflows != nil {
		RegisterAWSWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterAWSActivities(env, activities)
	}
	return &TestAWSClient{env, workflows}
}

// ManageAWS executes a(n) test.acronym.v1.AWS.ManageAWS workflow in the test environment
func (c *TestAWSClient) ManageAWS(ctx context.Context, req *ManageAWSRequest, opts ...*ManageAWSOptions) (*ManageAWSResponse, error) {
	run, err := c.ManageAWSAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSAsync executes a(n) test.acronym.v1.AWS.ManageAWS workflow in the test environment
func (c *TestAWSClient) ManageAWSAsync(ctx context.Context, req *ManageAWSRequest, options ...*ManageAWSOptions) (ManageAWSRun, error) {
	var o *ManageAWSOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testManageAWSRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetManageAWS is a noop
func (c *TestAWSClient) GetManageAWS(ctx context.Context, workflowID string, runID string) ManageAWSRun {
	return &testManageAWSRun{env: c.env, workflows: c.workflows}
}

// ManageAWSResource executes a(n) test.acronym.v1.AWS.ManageAWSResource workflow in the test environment
func (c *TestAWSClient) ManageAWSResource(ctx context.Context, req *ManageAWSResourceRequest, opts ...*ManageAWSResourceOptions) (*ManageAWSResourceResponse, error) {
	run, err := c.ManageAWSResourceAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSResourceAsync executes a(n) test.acronym.v1.AWS.ManageAWSResource workflow in the test environment
func (c *TestAWSClient) ManageAWSResourceAsync(ctx context.Context, req *ManageAWSResourceRequest, options ...*ManageAWSResourceOptions) (ManageAWSResourceRun, error) {
	var o *ManageAWSResourceOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAWSResourceOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testManageAWSResourceRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetManageAWSResource is a noop
func (c *TestAWSClient) GetManageAWSResource(ctx context.Context, workflowID string, runID string) ManageAWSResourceRun {
	return &testManageAWSResourceRun{env: c.env, workflows: c.workflows}
}

// SomethingV1FooBar executes a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow in the test environment
func (c *TestAWSClient) SomethingV1FooBar(ctx context.Context, req *SomethingV1FooBarRequest, opts ...*SomethingV1FooBarOptions) (*SomethingV1FooBarResponse, error) {
	run, err := c.SomethingV1FooBarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomethingV1FooBarAsync executes a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow in the test environment
func (c *TestAWSClient) SomethingV1FooBarAsync(ctx context.Context, req *SomethingV1FooBarRequest, options ...*SomethingV1FooBarOptions) (SomethingV1FooBarRun, error) {
	var o *SomethingV1FooBarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomethingV1FooBarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomethingV1FooBarRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomethingV1FooBar is a noop
func (c *TestAWSClient) GetSomethingV1FooBar(ctx context.Context, workflowID string, runID string) SomethingV1FooBarRun {
	return &testSomethingV1FooBarRun{env: c.env, workflows: c.workflows}
}

// SomethingV2FooBar executes a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow in the test environment
func (c *TestAWSClient) SomethingV2FooBar(ctx context.Context, req *SomethingV2FooBarRequest, opts ...*SomethingV2FooBarOptions) (*SomethingV2FooBarResponse, error) {
	run, err := c.SomethingV2FooBarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomethingV2FooBarAsync executes a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow in the test environment
func (c *TestAWSClient) SomethingV2FooBarAsync(ctx context.Context, req *SomethingV2FooBarRequest, options ...*SomethingV2FooBarOptions) (SomethingV2FooBarRun, error) {
	var o *SomethingV2FooBarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewSomethingV2FooBarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testSomethingV2FooBarRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetSomethingV2FooBar is a noop
func (c *TestAWSClient) GetSomethingV2FooBar(ctx context.Context, workflowID string, runID string) SomethingV2FooBarRun {
	return &testSomethingV2FooBarRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestAWSClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestAWSClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ ManageAWSRun = &testManageAWSRun{}

// testManageAWSRun provides convenience methods for interacting with a(n) test.acronym.v1.AWS.ManageAWS workflow in the test environment
type testManageAWSRun struct {
	client    *TestAWSClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *ManageAWSRequest
	workflows AWSWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testManageAWSRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.acronym.v1.AWS.ManageAWS workflow result
func (r *testManageAWSRun) Get(context.Context) (*ManageAWSResponse, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(ManageAWSWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ManageAWSResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.acronym.v1.AWS.ManageAWS workflow run's workflow ID
func (r *testManageAWSRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testManageAWSRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testManageAWSRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testManageAWSRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ ManageAWSResourceRun = &testManageAWSResourceRun{}

// testManageAWSResourceRun provides convenience methods for interacting with a(n) test.acronym.v1.AWS.ManageAWSResource workflow in the test environment
type testManageAWSResourceRun struct {
	client    *TestAWSClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *ManageAWSResourceRequest
	workflows AWSWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testManageAWSResourceRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.acronym.v1.AWS.ManageAWSResource workflow result
func (r *testManageAWSResourceRun) Get(context.Context) (*ManageAWSResourceResponse, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(ManageAWSResourceWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ManageAWSResourceResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.acronym.v1.AWS.ManageAWSResource workflow run's workflow ID
func (r *testManageAWSResourceRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testManageAWSResourceRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testManageAWSResourceRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testManageAWSResourceRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ SomethingV1FooBarRun = &testSomethingV1FooBarRun{}

// testSomethingV1FooBarRun provides convenience methods for interacting with a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow in the test environment
type testSomethingV1FooBarRun struct {
	client    *TestAWSClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *SomethingV1FooBarRequest
	workflows AWSWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomethingV1FooBarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.acronym.v1.AWS.SomethingV1FooBar workflow result
func (r *testSomethingV1FooBarRun) Get(context.Context) (*SomethingV1FooBarResponse, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(SomethingV1FooBarWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result SomethingV1FooBarResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.acronym.v1.AWS.SomethingV1FooBar workflow run's workflow ID
func (r *testSomethingV1FooBarRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomethingV1FooBarRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomethingV1FooBarRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomethingV1FooBarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ SomethingV2FooBarRun = &testSomethingV2FooBarRun{}

// testSomethingV2FooBarRun provides convenience methods for interacting with a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow in the test environment
type testSomethingV2FooBarRun struct {
	client    *TestAWSClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *SomethingV2FooBarRequest
	workflows AWSWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomethingV2FooBarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.acronym.v1.AWS.SomethingV2FooBar workflow result
func (r *testSomethingV2FooBarRun) Get(context.Context) (*SomethingV2FooBarResponse, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(SomethingV2FooBarWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result SomethingV2FooBarResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.acronym.v1.AWS.SomethingV2FooBar workflow run's workflow ID
func (r *testSomethingV2FooBarRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSomethingV2FooBarRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSomethingV2FooBarRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomethingV2FooBarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// AWSCliOptions describes runtime configuration for test.acronym.v1.AWS cli
type AWSCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewAWSCliOptions initializes a new AWSCliOptions value
func NewAWSCliOptions() *AWSCliOptions {
	return &AWSCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *AWSCliOptions) WithAfter(fn func(*v2.Context) error) *AWSCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *AWSCliOptions) WithBefore(fn func(*v2.Context) error) *AWSCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *AWSCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *AWSCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *AWSCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *AWSCliOptions {
	opts.worker = fn
	return opts
}

// NewAWSCli initializes a cli for a(n) test.acronym.v1.AWS service
func NewAWSCli(options ...*AWSCliOptions) (*v2.App, error) {
	commands, err := newAWSCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:                      "aws",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// NewAWSCliCommand initializes a cli command for a test.acronym.v1.AWS service with subcommands for each query, signal, update, and workflow
func NewAWSCliCommand(options ...*AWSCliOptions) (*v2.Command, error) {
	subcommands, err := newAWSCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "aws",
		Subcommands: subcommands,
	}, nil
}

// newAWSCommands initializes (sub)commands for a test.acronym.v1.AWS cli or command
func newAWSCommands(options ...*AWSCliOptions) ([]*v2.Command, error) {
	opts := &AWSCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "manage-aws",
			Usage:                  "ManageAWS does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "aws-task-queue",
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "urn",
					Usage:    "set the value of the operation's \"Urn\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewAWSClient(tc)
				req, err := UnmarshalCliFlagsToManageAWSRequest(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ManageAWSAsync(cmd.Context, req, NewManageAWSOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ManageAWSWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "something-v1-foo-bar",
			Usage:                  "SomethingV1FooBar does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "aws-task-queue",
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "urn",
					Usage:    "set the value of the operation's \"Urn\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "k8-snamespace",
					Usage:    "set the value of the operation's \"K8SNamespace\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewAWSClient(tc)
				req, err := UnmarshalCliFlagsToSomethingV1FooBarRequest(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomethingV1FooBarAsync(cmd.Context, req, NewSomethingV1FooBarOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomethingV1FooBarWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "something-foo-bar",
			Usage:                  "do something with foo bar",
			Aliases:                []string{"sfb", "sfbv2"},
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "aws-task-queue",
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "urn",
					Usage:    "set the value of the operation's \"Urn\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "k8s-namespace",
					Usage:    "kubernetes namespace name",
					Aliases:  []string{"n"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewAWSClient(tc)
				req, err := UnmarshalCliFlagsToSomethingV2FooBarRequest(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SomethingV2FooBarAsync(cmd.Context, req, NewSomethingV2FooBarOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomethingV2FooBarWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.acronym.v1.AWS worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToManageAWSRequest unmarshals a ManageAWSRequest from command line flags
func UnmarshalCliFlagsToManageAWSRequest(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*ManageAWSRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result ManageAWSRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("urn"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Urn = value
	}
	return &result, nil
}

// UnmarshalCliFlagsToManageAWSResourceRequest unmarshals a ManageAWSResourceRequest from command line flags
func UnmarshalCliFlagsToManageAWSResourceRequest(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*ManageAWSResourceRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result ManageAWSResourceRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("urn"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Urn = value
	}
	if flag := opts.FlagName("k8-snamespace"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.K8SNamespace = value
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomethingV1FooBarRequest unmarshals a SomethingV1FooBarRequest from command line flags
func UnmarshalCliFlagsToSomethingV1FooBarRequest(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*SomethingV1FooBarRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result SomethingV1FooBarRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("urn"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Urn = value
	}
	if flag := opts.FlagName("k8-snamespace"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.K8SNamespace = value
	}
	return &result, nil
}

// UnmarshalCliFlagsToSomethingV2FooBarRequest unmarshals a SomethingV2FooBarRequest from command line flags
func UnmarshalCliFlagsToSomethingV2FooBarRequest(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*SomethingV2FooBarRequest, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result SomethingV2FooBarRequest
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("urn"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Urn = value
	}
	if flag := opts.FlagName("k8s-namespace"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.K8SNamespace = value
	}
	return &result, nil
}

// WithAWSSchemeTypes registers all AWS protobuf types with the given scheme
func WithAWSSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("ManageAWSResourceRequest"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("ManageAWSResourceResponse"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("ManageAWSResourceURNRequest"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("ManageAWSResourceURNResponse"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("ManageAWSRequest"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("ManageAWSResponse"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("SomethingV1FooBarRequest"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("SomethingV1FooBarResponse"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("SomethingV2FooBarRequest"))
		s.RegisterType(File_test_acronym_v1_acronym_proto.Messages().ByName("SomethingV2FooBarResponse"))
	}
}
