// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/acronym/v1/acronym.proto
package acronymv1xns

import (
	"context"
	"errors"
	"fmt"
	temporalv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/v1"
	xnsv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/xns/v1"
	v1 "github.com/cludden/protoc-gen-go-temporal/gen/test/acronym/v1"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	xns "github.com/cludden/protoc-gen-go-temporal/pkg/xns"
	uuid "github.com/google/uuid"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"time"
)

// AWSOptions is used to configure test.acronym.v1.AWS xns activity registration
type AWSOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewAWSOptions initializes a new AWSOptions value
func NewAWSOptions() *AWSOptions {
	return &AWSOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *AWSOptions) WithErrorConverter(errorConverter func(error) error) *AWSOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *AWSOptions) WithFilter(filter func(string) string) *AWSOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *AWSOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *AWSOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// awsOptions is a reference to the AWSOptions initialized at registration
var awsOptions *AWSOptions

// RegisterAWSActivities registers test.acronym.v1.AWS cross-namespace activities
func RegisterAWSActivities(r worker.ActivityRegistry, c v1.AWSClient, options ...*AWSOptions) {
	if awsOptions == nil && len(options) > 0 && options[0] != nil {
		awsOptions = options[0]
	}
	a := &awsActivities{c}
	if name := awsOptions.filterActivity("test.acronym.v1.AWS.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity(v1.ManageAWSWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.ManageAWS, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity("test.acronym.v1.AWS.GetManageAWS"); name != "" {
		r.RegisterActivityWithOptions(a.GetManageAWS, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity(v1.ManageAWSResourceWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.ManageAWSResource, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity("test.acronym.v1.AWS.GetManageAWSResource"); name != "" {
		r.RegisterActivityWithOptions(a.GetManageAWSResource, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity(v1.SomethingV1FooBarWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomethingV1FooBar, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity("test.acronym.v1.AWS.GetSomethingV1FooBar"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomethingV1FooBar, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity(v1.SomethingV2FooBarWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SomethingV2FooBar, activity.RegisterOptions{Name: name})
	}
	if name := awsOptions.filterActivity("test.acronym.v1.AWS.GetSomethingV2FooBar"); name != "" {
		r.RegisterActivityWithOptions(a.GetSomethingV2FooBar, activity.RegisterOptions{Name: name})
	}
}

// ManageAWSWorkflowOptions are used to configure a(n) test.acronym.v1.AWS.ManageAWS workflow execution
type ManageAWSWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewManageAWSWorkflowOptions initializes a new ManageAWSWorkflowOptions value
func NewManageAWSWorkflowOptions() *ManageAWSWorkflowOptions {
	return &ManageAWSWorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *ManageAWSWorkflowOptions) Build(ctx workflow.Context, input *v1.ManageAWSRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.ManageAWSIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"test.acronym.v1.AWS.ManageAWS\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *ManageAWSWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *ManageAWSWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *ManageAWSWorkflowOptions) WithDetached(d bool) *ManageAWSWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *ManageAWSWorkflowOptions) WithHeartbeatInterval(d time.Duration) *ManageAWSWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *ManageAWSWorkflowOptions) WithHeartbeatTimeout(d time.Duration) *ManageAWSWorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *ManageAWSWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ManageAWSWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *ManageAWSWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *ManageAWSWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// ManageAWSRun provides a handle to a test.acronym.v1.AWS.ManageAWS workflow execution
type ManageAWSRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.ManageAWSResponse, error)

	// ID returns the workflow id
	ID() string
}

// manageAWSRun provides a(n) ManageAWSRun implementation
type manageAWSRun struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *manageAWSRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelAWSWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *manageAWSRun) Future() workflow.Future {
	if r.future == nil {
		rr := GetManageAWSAsync(r.ctx, r.id, "").(*manageAWSRun)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *manageAWSRun) Get(ctx workflow.Context) (*v1.ManageAWSResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetManageAWSAsync(ctx, r.id, "", NewGetManageAWSOptions().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*manageAWSRun)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.ManageAWSResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *manageAWSRun) ID() string {
	return r.id
}

// ManageAWS does some workflow thing.
func ManageAWS(ctx workflow.Context, req *v1.ManageAWSRequest, opts ...*ManageAWSWorkflowOptions) (*v1.ManageAWSResponse, error) {
	run, err := ManageAWSAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWS does some workflow thing.
func ManageAWSAsync(ctx workflow.Context, input *v1.ManageAWSRequest, opts ...*ManageAWSWorkflowOptions) (ManageAWSRun, error) {
	activityName := awsOptions.filterActivity(v1.ManageAWSWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.ManageAWSWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *ManageAWSWorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewManageAWSWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, awsOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &manageAWSRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetManageAWS returns a(n) test.acronym.v1.AWS.ManageAWS workflow execution
func GetManageAWS(ctx workflow.Context, workflowID string, runID string, options ...*GetManageAWSOptions) (out *v1.ManageAWSResponse, err error) {
	out, err = GetManageAWSAsync(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetManageAWSAsync returns a handle to a(n) test.acronym.v1.AWS.ManageAWS workflow execution
func GetManageAWSAsync(ctx workflow.Context, workflowID string, runID string, options ...*GetManageAWSOptions) ManageAWSRun {
	activityName := awsOptions.filterActivity("test.acronym.v1.AWS.GetManageAWS")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &manageAWSRun{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetManageAWSOptions
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetManageAWSOptions()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(awsOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &manageAWSRun{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &manageAWSRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetManageAWSOptions are used to configure a(n) test.acronym.v1.AWS.ManageAWS workflow execution getter activity
type GetManageAWSOptions struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetManageAWSOptions initializes a new GetManageAWSOptions value
func NewGetManageAWSOptions() *GetManageAWSOptions {
	return &GetManageAWSOptions{}
}

// Build initializes the activity context and input
func (opt *GetManageAWSOptions) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetManageAWSOptions) WithActivityOptions(ao workflow.ActivityOptions) *GetManageAWSOptions {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetManageAWSOptions) WithHeartbeatInterval(d time.Duration) *GetManageAWSOptions {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetManageAWSOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetManageAWSOptions {
	o.parentClosePolicy = policy
	return o
}

// ManageAWSResourceWorkflowOptions are used to configure a(n) test.acronym.v1.AWS.ManageAWSResource workflow execution
type ManageAWSResourceWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewManageAWSResourceWorkflowOptions initializes a new ManageAWSResourceWorkflowOptions value
func NewManageAWSResourceWorkflowOptions() *ManageAWSResourceWorkflowOptions {
	return &ManageAWSResourceWorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *ManageAWSResourceWorkflowOptions) Build(ctx workflow.Context, input *v1.ManageAWSResourceRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.ManageAWSResourceIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"test.acronym.v1.AWS.ManageAWSResource\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *ManageAWSResourceWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *ManageAWSResourceWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *ManageAWSResourceWorkflowOptions) WithDetached(d bool) *ManageAWSResourceWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *ManageAWSResourceWorkflowOptions) WithHeartbeatInterval(d time.Duration) *ManageAWSResourceWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *ManageAWSResourceWorkflowOptions) WithHeartbeatTimeout(d time.Duration) *ManageAWSResourceWorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *ManageAWSResourceWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ManageAWSResourceWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *ManageAWSResourceWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *ManageAWSResourceWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// ManageAWSResourceRun provides a handle to a test.acronym.v1.AWS.ManageAWSResource workflow execution
type ManageAWSResourceRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.ManageAWSResourceResponse, error)

	// ID returns the workflow id
	ID() string
}

// manageAWSResourceRun provides a(n) ManageAWSResourceRun implementation
type manageAWSResourceRun struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *manageAWSResourceRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelAWSWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *manageAWSResourceRun) Future() workflow.Future {
	if r.future == nil {
		rr := GetManageAWSResourceAsync(r.ctx, r.id, "").(*manageAWSResourceRun)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *manageAWSResourceRun) Get(ctx workflow.Context) (*v1.ManageAWSResourceResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetManageAWSResourceAsync(ctx, r.id, "", NewGetManageAWSResourceOptions().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*manageAWSResourceRun)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.ManageAWSResourceResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *manageAWSResourceRun) ID() string {
	return r.id
}

// ManageAWSResource does some workflow thing.
func ManageAWSResource(ctx workflow.Context, req *v1.ManageAWSResourceRequest, opts ...*ManageAWSResourceWorkflowOptions) (*v1.ManageAWSResourceResponse, error) {
	run, err := ManageAWSResourceAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSResource does some workflow thing.
func ManageAWSResourceAsync(ctx workflow.Context, input *v1.ManageAWSResourceRequest, opts ...*ManageAWSResourceWorkflowOptions) (ManageAWSResourceRun, error) {
	activityName := awsOptions.filterActivity(v1.ManageAWSResourceWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.ManageAWSResourceWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *ManageAWSResourceWorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewManageAWSResourceWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, awsOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &manageAWSResourceRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetManageAWSResource returns a(n) test.acronym.v1.AWS.ManageAWSResource workflow execution
func GetManageAWSResource(ctx workflow.Context, workflowID string, runID string, options ...*GetManageAWSResourceOptions) (out *v1.ManageAWSResourceResponse, err error) {
	out, err = GetManageAWSResourceAsync(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetManageAWSResourceAsync returns a handle to a(n) test.acronym.v1.AWS.ManageAWSResource workflow execution
func GetManageAWSResourceAsync(ctx workflow.Context, workflowID string, runID string, options ...*GetManageAWSResourceOptions) ManageAWSResourceRun {
	activityName := awsOptions.filterActivity("test.acronym.v1.AWS.GetManageAWSResource")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &manageAWSResourceRun{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetManageAWSResourceOptions
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetManageAWSResourceOptions()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(awsOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &manageAWSResourceRun{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &manageAWSResourceRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetManageAWSResourceOptions are used to configure a(n) test.acronym.v1.AWS.ManageAWSResource workflow execution getter activity
type GetManageAWSResourceOptions struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetManageAWSResourceOptions initializes a new GetManageAWSResourceOptions value
func NewGetManageAWSResourceOptions() *GetManageAWSResourceOptions {
	return &GetManageAWSResourceOptions{}
}

// Build initializes the activity context and input
func (opt *GetManageAWSResourceOptions) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetManageAWSResourceOptions) WithActivityOptions(ao workflow.ActivityOptions) *GetManageAWSResourceOptions {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetManageAWSResourceOptions) WithHeartbeatInterval(d time.Duration) *GetManageAWSResourceOptions {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetManageAWSResourceOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetManageAWSResourceOptions {
	o.parentClosePolicy = policy
	return o
}

// SomethingV1FooBarWorkflowOptions are used to configure a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow execution
type SomethingV1FooBarWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomethingV1FooBarWorkflowOptions initializes a new SomethingV1FooBarWorkflowOptions value
func NewSomethingV1FooBarWorkflowOptions() *SomethingV1FooBarWorkflowOptions {
	return &SomethingV1FooBarWorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomethingV1FooBarWorkflowOptions) Build(ctx workflow.Context, input *v1.SomethingV1FooBarRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomethingV1FooBarIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"test.acronym.v1.AWS.SomethingV1FooBar\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomethingV1FooBarWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomethingV1FooBarWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomethingV1FooBarWorkflowOptions) WithDetached(d bool) *SomethingV1FooBarWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomethingV1FooBarWorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomethingV1FooBarWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomethingV1FooBarWorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomethingV1FooBarWorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomethingV1FooBarWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomethingV1FooBarWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomethingV1FooBarWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomethingV1FooBarWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomethingV1FooBarRun provides a handle to a test.acronym.v1.AWS.SomethingV1FooBar workflow execution
type SomethingV1FooBarRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomethingV1FooBarResponse, error)

	// ID returns the workflow id
	ID() string
}

// somethingV1FooBarRun provides a(n) SomethingV1FooBarRun implementation
type somethingV1FooBarRun struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *somethingV1FooBarRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelAWSWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *somethingV1FooBarRun) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomethingV1FooBarAsync(r.ctx, r.id, "").(*somethingV1FooBarRun)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *somethingV1FooBarRun) Get(ctx workflow.Context) (*v1.SomethingV1FooBarResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomethingV1FooBarAsync(ctx, r.id, "", NewGetSomethingV1FooBarOptions().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*somethingV1FooBarRun)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.SomethingV1FooBarResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *somethingV1FooBarRun) ID() string {
	return r.id
}

// SomethingV1FooBar does some workflow thing.
func SomethingV1FooBar(ctx workflow.Context, req *v1.SomethingV1FooBarRequest, opts ...*SomethingV1FooBarWorkflowOptions) (*v1.SomethingV1FooBarResponse, error) {
	run, err := SomethingV1FooBarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomethingV1FooBar does some workflow thing.
func SomethingV1FooBarAsync(ctx workflow.Context, input *v1.SomethingV1FooBarRequest, opts ...*SomethingV1FooBarWorkflowOptions) (SomethingV1FooBarRun, error) {
	activityName := awsOptions.filterActivity(v1.SomethingV1FooBarWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomethingV1FooBarWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomethingV1FooBarWorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomethingV1FooBarWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, awsOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &somethingV1FooBarRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomethingV1FooBar returns a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow execution
func GetSomethingV1FooBar(ctx workflow.Context, workflowID string, runID string, options ...*GetSomethingV1FooBarOptions) (out *v1.SomethingV1FooBarResponse, err error) {
	out, err = GetSomethingV1FooBarAsync(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetSomethingV1FooBarAsync returns a handle to a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow execution
func GetSomethingV1FooBarAsync(ctx workflow.Context, workflowID string, runID string, options ...*GetSomethingV1FooBarOptions) SomethingV1FooBarRun {
	activityName := awsOptions.filterActivity("test.acronym.v1.AWS.GetSomethingV1FooBar")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &somethingV1FooBarRun{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomethingV1FooBarOptions
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomethingV1FooBarOptions()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(awsOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &somethingV1FooBarRun{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &somethingV1FooBarRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomethingV1FooBarOptions are used to configure a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow execution getter activity
type GetSomethingV1FooBarOptions struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomethingV1FooBarOptions initializes a new GetSomethingV1FooBarOptions value
func NewGetSomethingV1FooBarOptions() *GetSomethingV1FooBarOptions {
	return &GetSomethingV1FooBarOptions{}
}

// Build initializes the activity context and input
func (opt *GetSomethingV1FooBarOptions) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomethingV1FooBarOptions) WithActivityOptions(ao workflow.ActivityOptions) *GetSomethingV1FooBarOptions {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomethingV1FooBarOptions) WithHeartbeatInterval(d time.Duration) *GetSomethingV1FooBarOptions {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomethingV1FooBarOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomethingV1FooBarOptions {
	o.parentClosePolicy = policy
	return o
}

// SomethingV2FooBarWorkflowOptions are used to configure a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow execution
type SomethingV2FooBarWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	HeartbeatTimeout     time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSomethingV2FooBarWorkflowOptions initializes a new SomethingV2FooBarWorkflowOptions value
func NewSomethingV2FooBarWorkflowOptions() *SomethingV2FooBarWorkflowOptions {
	return &SomethingV2FooBarWorkflowOptions{}
}

// Build initializes the activity context and input
func (opts *SomethingV2FooBarWorkflowOptions) Build(ctx workflow.Context, input *v1.SomethingV2FooBarRequest) (workflow.Context, *xnsv1.WorkflowRequest, error) {
	// initialize start workflow options
	swo := client.StartWorkflowOptions{}
	if opts.StartWorkflowOptions != nil {
		swo = *opts.StartWorkflowOptions
	}

	// initialize workflow id if not set
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SomethingV2FooBarIdexpression, input.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"test.acronym.v1.AWS.SomethingV2FooBar\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&swo.ID); err != nil {
			return nil, nil, err
		}
	}
	if swo.ID == "" {
		return nil, nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal workflow request protobuf message
	inputpb, err := anypb.New(input)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal start workflow options protobuf message
	swopb, err := xns.MarshalStartWorkflowOptions(swo)
	if err != nil {
		return ctx, nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal parent close policy protobuf message
	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opts.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	// initialize xns activity options
	ao := workflow.ActivityOptions{}
	if opts.ActivityOptions != nil {
		ao = *opts.ActivityOptions
	}

	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = time.Second * 60
	}

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = time.Hour * 24
	}

	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	// configure heartbeat interval
	if opts.HeartbeatInterval == 0 {
		opts.HeartbeatInterval = ao.HeartbeatTimeout / 2
	}

	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.WorkflowRequest{
		Detached:             opts.Detached,
		HeartbeatInterval:    durationpb.New(opts.HeartbeatInterval),
		ParentClosePolicy:    parentClosePolicy,
		Request:              inputpb,
		StartWorkflowOptions: swopb,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (opts *SomethingV2FooBarWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SomethingV2FooBarWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SomethingV2FooBarWorkflowOptions) WithDetached(d bool) *SomethingV2FooBarWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SomethingV2FooBarWorkflowOptions) WithHeartbeatInterval(d time.Duration) *SomethingV2FooBarWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithHeartbeatTimeout can be used to customize the activity heartbeat timeout
func (opts *SomethingV2FooBarWorkflowOptions) WithHeartbeatTimeout(d time.Duration) *SomethingV2FooBarWorkflowOptions {
	opts.HeartbeatTimeout = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SomethingV2FooBarWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SomethingV2FooBarWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SomethingV2FooBarWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SomethingV2FooBarWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SomethingV2FooBarRun provides a handle to a test.acronym.v1.AWS.SomethingV2FooBar workflow execution
type SomethingV2FooBarRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.SomethingV2FooBarResponse, error)

	// ID returns the workflow id
	ID() string
}

// somethingV2FooBarRun provides a(n) SomethingV2FooBarRun implementation
type somethingV2FooBarRun struct {
	cancel            func()
	ctx               workflow.Context
	future            workflow.Future
	id                string
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// Cancel the underlying workflow execution
func (r *somethingV2FooBarRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelAWSWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *somethingV2FooBarRun) Future() workflow.Future {
	if r.future == nil {
		rr := GetSomethingV2FooBarAsync(r.ctx, r.id, "").(*somethingV2FooBarRun)
		r.future = rr.future
		r.cancel = rr.cancel
	}
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *somethingV2FooBarRun) Get(ctx workflow.Context) (*v1.SomethingV2FooBarResponse, error) {
	ctx, cancel := workflow.WithCancel(ctx)
	if r.future == nil {
		rr := GetSomethingV2FooBarAsync(ctx, r.id, "", NewGetSomethingV2FooBarOptions().WithParentClosePolicy(r.parentClosePolicy).WithHeartbeatInterval(r.heartbeatInterval)).(*somethingV2FooBarRun)
		r.future = rr.future
		r.cancel = cancel
	}
	var resp v1.SomethingV2FooBarResponse
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *somethingV2FooBarRun) ID() string {
	return r.id
}

// SomethingV2FooBar does some workflow thing.
func SomethingV2FooBar(ctx workflow.Context, req *v1.SomethingV2FooBarRequest, opts ...*SomethingV2FooBarWorkflowOptions) (*v1.SomethingV2FooBarResponse, error) {
	run, err := SomethingV2FooBarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomethingV2FooBar does some workflow thing.
func SomethingV2FooBarAsync(ctx workflow.Context, input *v1.SomethingV2FooBarRequest, opts ...*SomethingV2FooBarWorkflowOptions) (SomethingV2FooBarRun, error) {
	activityName := awsOptions.filterActivity(v1.SomethingV2FooBarWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SomethingV2FooBarWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	var opt *SomethingV2FooBarWorkflowOptions
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	} else {
		opt = NewSomethingV2FooBarWorkflowOptions()
	}
	ctx, req, err := opt.Build(ctx, input)
	if err != nil {
		return nil, awsOptions.convertError(err)
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &somethingV2FooBarRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     req.GetStartWorkflowOptions().GetId(),
	}, nil
}

// GetSomethingV2FooBar returns a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow execution
func GetSomethingV2FooBar(ctx workflow.Context, workflowID string, runID string, options ...*GetSomethingV2FooBarOptions) (out *v1.SomethingV2FooBarResponse, err error) {
	out, err = GetSomethingV2FooBarAsync(ctx, workflowID, runID, options...).Get(ctx)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GetSomethingV2FooBarAsync returns a handle to a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow execution
func GetSomethingV2FooBarAsync(ctx workflow.Context, workflowID string, runID string, options ...*GetSomethingV2FooBarOptions) SomethingV2FooBarRun {
	activityName := awsOptions.filterActivity("test.acronym.v1.AWS.GetSomethingV2FooBar")
	if activityName == "" {
		f, set := workflow.NewFuture(ctx)
		set.SetError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil))
		return &somethingV2FooBarRun{
			future: f,
			id:     workflowID,
		}
	}
	var opt *GetSomethingV2FooBarOptions
	if len(options) > 0 && options[0] != nil {
		opt = options[0]
	} else {
		opt = NewGetSomethingV2FooBarOptions()
	}
	ctx, req, err := opt.Build(ctx, workflowID, runID)
	if err != nil {
		f, set := workflow.NewFuture(ctx)
		set.SetError(awsOptions.convertError(temporal.NewNonRetryableApplicationError(fmt.Sprintf("no activity registered for %s", activityName), "Unimplemented", nil)))
		return &somethingV2FooBarRun{
			future: f,
			id:     workflowID,
		}
	}
	ctx, cancel := workflow.WithCancel(ctx)
	return &somethingV2FooBarRun{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, req),
		id:     workflowID,
	}
}

// GetSomethingV2FooBarOptions are used to configure a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow execution getter activity
type GetSomethingV2FooBarOptions struct {
	activityOptions   *workflow.ActivityOptions
	heartbeatInterval time.Duration
	parentClosePolicy enumsv1.ParentClosePolicy
}

// NewGetSomethingV2FooBarOptions initializes a new GetSomethingV2FooBarOptions value
func NewGetSomethingV2FooBarOptions() *GetSomethingV2FooBarOptions {
	return &GetSomethingV2FooBarOptions{}
}

// Build initializes the activity context and input
func (opt *GetSomethingV2FooBarOptions) Build(ctx workflow.Context, workflowID string, runID string) (workflow.Context, *xnsv1.GetWorkflowRequest, error) {
	if opt.heartbeatInterval == 0 {
		opt.heartbeatInterval = 30000000000 // 30 seconds
	}

	// configure activity options
	var ao workflow.ActivityOptions
	if opt.activityOptions != nil {
		ao = *opt.activityOptions
	} else {
		ao = workflow.ActivityOptions{}
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = 60000000000 // 1 minute
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	return ctx, &xnsv1.GetWorkflowRequest{
		HeartbeatInterval: durationpb.New(opt.heartbeatInterval),
		ParentClosePolicy: opt.parentClosePolicy,
		RunId:             runID,
		WorkflowId:        workflowID,
	}, nil
}

// WithActivityOptions can be used to customize the activity options
func (o *GetSomethingV2FooBarOptions) WithActivityOptions(ao workflow.ActivityOptions) *GetSomethingV2FooBarOptions {
	o.activityOptions = &ao
	return o
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (o *GetSomethingV2FooBarOptions) WithHeartbeatInterval(d time.Duration) *GetSomethingV2FooBarOptions {
	o.heartbeatInterval = d
	return o
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (o *GetSomethingV2FooBarOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GetSomethingV2FooBarOptions {
	o.parentClosePolicy = policy
	return o
}

// CancelAWSWorkflow cancels an existing workflow
func CancelAWSWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelAWSWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelAWSWorkflowAsync cancels an existing workflow
func CancelAWSWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := awsOptions.filterActivity("test.acronym.v1.AWS.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for test.acronym.v1.AWS.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// awsActivities provides activities that can be used to interact with a(n) AWS service's workflow, queries, signals, and updates across namespaces
type awsActivities struct {
	client v1.AWSClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *awsActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// GetManageAWS retrieves a(n) test.acronym.v1.AWS.ManageAWS workflow via an activity
func (a *awsActivities) GetManageAWS(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.ManageAWSResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetManageAWS(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, awsOptions.convertError(err)
		}
	}
}

// ManageAWS executes a(n) test.acronym.v1.AWS.ManageAWS workflow via an activity
func (a *awsActivities) ManageAWS(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.ManageAWSResponse, err error) {
	// unmarshal workflow request
	var req v1.ManageAWSRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, awsOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/acronym/v1.ManageAWSRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.ManageAWSRun
	run, err = a.client.ManageAWSAsync(actx, &req, v1.NewManageAWSOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, awsOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, awsOptions.convertError(err)
		}
	}
}

// GetManageAWSResource retrieves a(n) test.acronym.v1.AWS.ManageAWSResource workflow via an activity
func (a *awsActivities) GetManageAWSResource(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.ManageAWSResourceResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetManageAWSResource(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, awsOptions.convertError(err)
		}
	}
}

// ManageAWSResource executes a(n) test.acronym.v1.AWS.ManageAWSResource workflow via an activity
func (a *awsActivities) ManageAWSResource(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.ManageAWSResourceResponse, err error) {
	// unmarshal workflow request
	var req v1.ManageAWSResourceRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, awsOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/acronym/v1.ManageAWSResourceRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.ManageAWSResourceRun
	run, err = a.client.ManageAWSResourceAsync(actx, &req, v1.NewManageAWSResourceOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, awsOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, awsOptions.convertError(err)
		}
	}
}

// GetSomethingV1FooBar retrieves a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow via an activity
func (a *awsActivities) GetSomethingV1FooBar(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.SomethingV1FooBarResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomethingV1FooBar(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, awsOptions.convertError(err)
		}
	}
}

// SomethingV1FooBar executes a(n) test.acronym.v1.AWS.SomethingV1FooBar workflow via an activity
func (a *awsActivities) SomethingV1FooBar(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomethingV1FooBarResponse, err error) {
	// unmarshal workflow request
	var req v1.SomethingV1FooBarRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, awsOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/acronym/v1.SomethingV1FooBarRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomethingV1FooBarRun
	run, err = a.client.SomethingV1FooBarAsync(actx, &req, v1.NewSomethingV1FooBarOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, awsOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, awsOptions.convertError(err)
		}
	}
}

// GetSomethingV2FooBar retrieves a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow via an activity
func (a *awsActivities) GetSomethingV2FooBar(ctx context.Context, input *xnsv1.GetWorkflowRequest) (out *v1.SomethingV2FooBarResponse, err error) {
	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	actx, cancel := context.WithCancel(context.Background())
	defer cancel()
	run := a.client.GetSomethingV2FooBar(actx, input.GetWorkflowId(), input.GetRunId())
	done := make(chan struct{})
	go func() {
		defer close(done)
		out, err = run.Get(actx)
	}()

	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)

		// return retryable error if the worker is stopping
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				activity.GetLogger(ctx).Info("worker is stopping")
				return nil, awsOptions.convertError(temporal.NewApplicationError("worker is stopping", "WorkerStopped"))
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-done:
			return out, awsOptions.convertError(err)
		}
	}
}

// SomethingV2FooBar executes a(n) test.acronym.v1.AWS.SomethingV2FooBar workflow via an activity
func (a *awsActivities) SomethingV2FooBar(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.SomethingV2FooBarResponse, err error) {
	// unmarshal workflow request
	var req v1.SomethingV2FooBarRequest
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, awsOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/acronym/v1.SomethingV2FooBarRequest", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	actx := ctx
	if !input.GetDetached() {
		var cancel context.CancelFunc
		actx, cancel = context.WithCancel(context.Background())
		defer cancel()
	}
	var run v1.SomethingV2FooBarRun
	run, err = a.client.SomethingV2FooBarAsync(actx, &req, v1.NewSomethingV2FooBarOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, awsOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(actx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, awsOptions.convertError(err)
					}
				}
				return nil, awsOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, awsOptions.convertError(err)
		}
	}
}
