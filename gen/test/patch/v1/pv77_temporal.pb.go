// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.14.4-next (e82835bad5227fc67a146f370ba42ab3f41c10cf)
//	go go1.22.2
//	protoc (unknown)
//
// source: test/patch/v1/pv77.proto
package patchv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	patch "github.com/cludden/protoc-gen-go-temporal/pkg/patch"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"time"
)

// Pv77FooServiceTaskQueue is the default task-queue for a test.patch.v1.Pv77FooService worker
const Pv77FooServiceTaskQueue = "pv77-v1"

// test.patch.v1.Pv77FooService workflow names
const (
	Pv77FooWorkflowName = "test.patch.v1.Pv77FooService.Pv77Foo"
)

// test.patch.v1.Pv77FooService activity names
const (
	Pv77FooActivityName = "test.patch.v1.Pv77FooActivity"
)

// Pv77FooServiceClient describes a client for a(n) test.patch.v1.Pv77FooService worker
type Pv77FooServiceClient interface {
	// Pv77Foo executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow and blocks until error or response received
	Pv77Foo(ctx context.Context, req *Pv77FooInput, opts ...*Pv77FooOptions) (*Pv77FooOutput, error)

	// Pv77FooAsync starts a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow and returns a handle to the workflow run
	Pv77FooAsync(ctx context.Context, req *Pv77FooInput, opts ...*Pv77FooOptions) (Pv77FooRun, error)

	// GetPv77Foo retrieves a handle to an existing test.patch.v1.Pv77FooService.Pv77Foo workflow execution
	GetPv77Foo(ctx context.Context, workflowID string, runID string) Pv77FooRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// pv77FooServiceClient implements a temporal client for a test.patch.v1.Pv77FooService service
type pv77FooServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewPv77FooServiceClient initializes a new test.patch.v1.Pv77FooService client
func NewPv77FooServiceClient(c client.Client, options ...*pv77FooServiceClientOptions) Pv77FooServiceClient {
	var cfg *pv77FooServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77FooServiceClientOptions()
	}
	return &pv77FooServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewPv77FooServiceClientWithOptions initializes a new Pv77FooService client with the given options
func NewPv77FooServiceClientWithOptions(c client.Client, opts client.Options, options ...*pv77FooServiceClientOptions) (Pv77FooServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *pv77FooServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77FooServiceClientOptions()
	}
	return &pv77FooServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// pv77FooServiceClientOptions describes optional runtime configuration for a Pv77FooServiceClient
type pv77FooServiceClientOptions struct {
	log *slog.Logger
}

// NewPv77FooServiceClientOptions initializes a new pv77FooServiceClientOptions value
func NewPv77FooServiceClientOptions() *pv77FooServiceClientOptions {
	return &pv77FooServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *pv77FooServiceClientOptions) WithLogger(l *slog.Logger) *pv77FooServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *pv77FooServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.patch.v1.Pv77FooService.Pv77Foo executes a test.patch.v1.Pv77FooService.Pv77Foo workflow and blocks until error or response received
func (c *pv77FooServiceClient) Pv77Foo(ctx context.Context, req *Pv77FooInput, options ...*Pv77FooOptions) (*Pv77FooOutput, error) {
	run, err := c.Pv77FooAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77FooAsync starts a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow and returns a handle to the workflow run
func (c *pv77FooServiceClient) Pv77FooAsync(ctx context.Context, req *Pv77FooInput, options ...*Pv77FooOptions) (Pv77FooRun, error) {
	var o *Pv77FooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77FooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, Pv77FooWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &pv77FooRun{
		client: c,
		run:    run,
	}, nil
}

// GetPv77Foo fetches an existing test.patch.v1.Pv77FooService.Pv77Foo execution
func (c *pv77FooServiceClient) GetPv77Foo(ctx context.Context, workflowID string, runID string) Pv77FooRun {
	return &pv77FooRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *pv77FooServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *pv77FooServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// Pv77FooOptions provides configuration for a test.patch.v1.Pv77FooService.Pv77Foo workflow operation
type Pv77FooOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewPv77FooOptions initializes a new Pv77FooOptions value
func NewPv77FooOptions() *Pv77FooOptions {
	return &Pv77FooOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *Pv77FooOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = Pv77FooServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *Pv77FooOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *Pv77FooOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77FooOptions) WithExecutionTimeout(d time.Duration) *Pv77FooOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *Pv77FooOptions) WithID(id string) *Pv77FooOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77FooOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77FooOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77FooOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77FooOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77FooOptions) WithRunTimeout(d time.Duration) *Pv77FooOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77FooOptions) WithSearchAttributes(sa map[string]any) *Pv77FooOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77FooOptions) WithTaskTimeout(d time.Duration) *Pv77FooOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77FooOptions) WithTaskQueue(tq string) *Pv77FooOptions {
	o.taskQueue = &tq
	return o
}

// Pv77FooRun describes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow run
type Pv77FooRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*Pv77FooOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// pv77FooRun provides an internal implementation of a(n) Pv77FooRunRun
type pv77FooRun struct {
	client *pv77FooServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *pv77FooRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *pv77FooRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *pv77FooRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *pv77FooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *pv77FooRun) Get(ctx context.Context) (*Pv77FooOutput, error) {
	var resp Pv77FooOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *pv77FooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// Pv77FooFunction implements a "test.patch.v1.Pv77FooService.Pv77Foo" workflow
	Pv77FooFunction func(workflow.Context, *Pv77FooInput) (*Pv77FooOutput, error)
)

// Pv77FooServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// Pv77FooServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	Pv77FooServiceWorkflowFunctions interface {
		// Pv77Foo executes a "test.patch.v1.Pv77FooService.Pv77Foo" workflow inline
		Pv77Foo(workflow.Context, *Pv77FooInput) (*Pv77FooOutput, error)
	}
	// pv77FooServiceWorkflowFunctions provides an internal Pv77FooServiceWorkflowFunctions implementation
	pv77FooServiceWorkflowFunctions struct{}
)

func NewPv77FooServiceWorkflowFunctions() Pv77FooServiceWorkflowFunctions {
	return &pv77FooServiceWorkflowFunctions{}
}

// Pv77Foo executes a "test.patch.v1.Pv77FooService.Pv77Foo" workflow inline
func (f *pv77FooServiceWorkflowFunctions) Pv77Foo(ctx workflow.Context, req *Pv77FooInput) (*Pv77FooOutput, error) {
	if Pv77FooFunction == nil {
		return nil, errors.New("Pv77Foo requires workflow registration via RegisterPv77FooServiceWorkflows or RegisterPv77FooWorkflow")
	}
	return Pv77FooFunction(ctx, req)
}

// Pv77FooServiceWorkflows provides methods for initializing new test.patch.v1.Pv77FooService workflow values
type Pv77FooServiceWorkflows interface {
	// Pv77Foo initializes a new a(n) Pv77FooWorkflow implementation
	Pv77Foo(ctx workflow.Context, input *Pv77FooWorkflowInput) (Pv77FooWorkflow, error)
}

// RegisterPv77FooServiceWorkflows registers test.patch.v1.Pv77FooService workflows with the given worker
func RegisterPv77FooServiceWorkflows(r worker.WorkflowRegistry, workflows Pv77FooServiceWorkflows) {
	RegisterPv77FooWorkflow(r, workflows.Pv77Foo)
}

// RegisterPv77FooWorkflow registers a test.patch.v1.Pv77FooService.Pv77Foo workflow with the given worker
func RegisterPv77FooWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *Pv77FooWorkflowInput) (Pv77FooWorkflow, error)) {
	Pv77FooFunction = buildPv77Foo(wf)
	r.RegisterWorkflowWithOptions(Pv77FooFunction, workflow.RegisterOptions{Name: Pv77FooWorkflowName})
}

// buildPv77Foo converts a Pv77Foo workflow struct into a valid workflow function
func buildPv77Foo(ctor func(workflow.Context, *Pv77FooWorkflowInput) (Pv77FooWorkflow, error)) func(workflow.Context, *Pv77FooInput) (*Pv77FooOutput, error) {
	return func(ctx workflow.Context, req *Pv77FooInput) (*Pv77FooOutput, error) {
		input := &Pv77FooWorkflowInput{
			Req: req,
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, Pv77FooServiceTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// Pv77FooWorkflowInput describes the input to a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow constructor
type Pv77FooWorkflowInput struct {
	Req *Pv77FooInput
}

// Pv77FooWorkflow describes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow implementation
type Pv77FooWorkflow interface {
	// Execute defines the entrypoint to a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow
	Execute(ctx workflow.Context) (*Pv77FooOutput, error)
}

// Pv77FooChild executes a child test.patch.v1.Pv77FooService.Pv77Foo workflow and blocks until error or response received
func Pv77FooChild(ctx workflow.Context, req *Pv77FooInput, options ...*Pv77FooChildOptions) (*Pv77FooOutput, error) {
	childRun, err := Pv77FooChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// Pv77FooChildAsync starts a child test.patch.v1.Pv77FooService.Pv77Foo workflow and returns a handle to the child workflow run
func Pv77FooChildAsync(ctx workflow.Context, req *Pv77FooInput, options ...*Pv77FooChildOptions) (*Pv77FooChildRun, error) {
	var o *Pv77FooChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77FooChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &Pv77FooChildRun{Future: workflow.ExecuteChildWorkflow(ctx, Pv77FooWorkflowName, req)}, nil
}

// Pv77FooChildOptions provides configuration for a child test.patch.v1.Pv77FooService.Pv77Foo workflow operation
type Pv77FooChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewPv77FooChildOptions initializes a new Pv77FooChildOptions value
func NewPv77FooChildOptions() *Pv77FooChildOptions {
	return &Pv77FooChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *Pv77FooChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, Pv77FooServiceTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = Pv77FooServiceTaskQueue
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *Pv77FooChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *Pv77FooChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77FooChildOptions) WithExecutionTimeout(d time.Duration) *Pv77FooChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *Pv77FooChildOptions) WithID(id string) *Pv77FooChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77FooChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77FooChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77FooChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77FooChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77FooChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77FooChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77FooChildOptions) WithRunTimeout(d time.Duration) *Pv77FooChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77FooChildOptions) WithSearchAttributes(sa map[string]any) *Pv77FooChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77FooChildOptions) WithTaskTimeout(d time.Duration) *Pv77FooChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77FooChildOptions) WithTaskQueue(tq string) *Pv77FooChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77FooChildOptions) WithWaitForCancellation(wait bool) *Pv77FooChildOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77FooChildRun describes a child Pv77Foo workflow run
type Pv77FooChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *Pv77FooChildRun) Get(ctx workflow.Context) (*Pv77FooOutput, error) {
	var resp Pv77FooOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *Pv77FooChildRun) Select(sel workflow.Selector, fn func(*Pv77FooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *Pv77FooChildRun) SelectStart(sel workflow.Selector, fn func(*Pv77FooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *Pv77FooChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// Pv77FooServiceActivities describes available worker activities
type Pv77FooServiceActivities interface {
	// test.patch.v1.Pv77FooService.Pv77Foo implements a(n) test.patch.v1.Pv77FooActivity activity definition
	Pv77Foo(ctx context.Context, req *Pv77FooInput) (*Pv77FooOutput, error)
}

// RegisterPv77FooServiceActivities registers activities with a worker
func RegisterPv77FooServiceActivities(r worker.ActivityRegistry, activities Pv77FooServiceActivities) {
	RegisterPv77FooActivity(r, activities.Pv77Foo)
}

// RegisterPv77FooActivity registers a test.patch.v1.Pv77FooActivity activity
func RegisterPv77FooActivity(r worker.ActivityRegistry, fn func(context.Context, *Pv77FooInput) (*Pv77FooOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: Pv77FooActivityName,
	})
}

// Pv77FooFuture describes a(n) test.patch.v1.Pv77FooActivity activity execution
type Pv77FooFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *Pv77FooFuture) Get(ctx workflow.Context) (*Pv77FooOutput, error) {
	var resp Pv77FooOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *Pv77FooFuture) Select(sel workflow.Selector, fn func(*Pv77FooFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Pv77Foo executes a(n) test.patch.v1.Pv77FooActivity activity
func Pv77Foo(ctx workflow.Context, req *Pv77FooInput, options ...*Pv77FooActivityOptions) (*Pv77FooOutput, error) {
	return Pv77FooAsync(ctx, req, options...).Get(ctx)
}

// Pv77FooAsync executes a(n) test.patch.v1.Pv77FooActivity activity (asynchronously)
func Pv77FooAsync(ctx workflow.Context, req *Pv77FooInput, options ...*Pv77FooActivityOptions) *Pv77FooFuture {
	var o *Pv77FooActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77FooActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77FooFuture{Future: errF}
	}
	activity := Pv77FooActivityName
	future := &Pv77FooFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// Pv77FooLocal executes a(n) test.patch.v1.Pv77FooActivity activity (locally)
func Pv77FooLocal(ctx workflow.Context, req *Pv77FooInput, options ...*Pv77FooLocalActivityOptions) (*Pv77FooOutput, error) {
	return Pv77FooLocalAsync(ctx, req, options...).Get(ctx)
}

// Pv77FooLocalAsync executes a(n) test.patch.v1.Pv77FooActivity activity (asynchronously, locally)
func Pv77FooLocalAsync(ctx workflow.Context, req *Pv77FooInput, options ...*Pv77FooLocalActivityOptions) *Pv77FooFuture {
	var o *Pv77FooLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77FooLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77FooFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = Pv77FooActivityName
	}
	future := &Pv77FooFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// Pv77FooActivityOptions provides configuration for a(n) test.patch.v1.Pv77FooActivity activity
type Pv77FooActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewPv77FooActivityOptions initializes a new Pv77FooActivityOptions value
func NewPv77FooActivityOptions() *Pv77FooActivityOptions {
	return &Pv77FooActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77FooActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_77_use-parent-task-queue", workflow.DefaultVersion, 1) == 1 {
			if tq := patch.DefaultTaskQueue(ctx, Pv77FooServiceTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
				opts.TaskQueue = tq
			}
		} else {
			opts.TaskQueue = Pv77FooServiceTaskQueue
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *Pv77FooActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *Pv77FooActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *Pv77FooActivityOptions) WithHeartbeatTimeout(d time.Duration) *Pv77FooActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77FooActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77FooActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77FooActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77FooActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *Pv77FooActivityOptions) WithScheduleToStartTimeout(d time.Duration) *Pv77FooActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77FooActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77FooActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77FooActivityOptions) WithTaskQueue(tq string) *Pv77FooActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77FooActivityOptions) WithWaitForCancellation(wait bool) *Pv77FooActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77FooLocalActivityOptions provides configuration for a(n) test.patch.v1.Pv77FooActivity activity
type Pv77FooLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *Pv77FooInput) (*Pv77FooOutput, error)
}

// NewPv77FooLocalActivityOptions initializes a new Pv77FooLocalActivityOptions value
func NewPv77FooLocalActivityOptions() *Pv77FooLocalActivityOptions {
	return &Pv77FooLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77FooLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.patch.v1.Pv77FooActivity implementation
func (o *Pv77FooLocalActivityOptions) Local(fn func(context.Context, *Pv77FooInput) (*Pv77FooOutput, error)) *Pv77FooLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *Pv77FooLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *Pv77FooLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77FooLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77FooLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77FooLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77FooLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77FooLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77FooLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestPv77FooServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows Pv77FooServiceWorkflows
}

var _ Pv77FooServiceClient = &TestPv77FooServiceClient{}

// NewTestPv77FooServiceClient initializes a new TestPv77FooServiceClient value
func NewTestPv77FooServiceClient(env *testsuite.TestWorkflowEnvironment, workflows Pv77FooServiceWorkflows, activities Pv77FooServiceActivities) *TestPv77FooServiceClient {
	if workflows != nil {
		RegisterPv77FooServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterPv77FooServiceActivities(env, activities)
	}
	return &TestPv77FooServiceClient{env, workflows}
}

// Pv77Foo executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow in the test environment
func (c *TestPv77FooServiceClient) Pv77Foo(ctx context.Context, req *Pv77FooInput, opts ...*Pv77FooOptions) (*Pv77FooOutput, error) {
	run, err := c.Pv77FooAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77FooAsync executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow in the test environment
func (c *TestPv77FooServiceClient) Pv77FooAsync(ctx context.Context, req *Pv77FooInput, options ...*Pv77FooOptions) (Pv77FooRun, error) {
	var o *Pv77FooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77FooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testPv77FooRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetPv77Foo is a noop
func (c *TestPv77FooServiceClient) GetPv77Foo(ctx context.Context, workflowID string, runID string) Pv77FooRun {
	return &testPv77FooRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestPv77FooServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestPv77FooServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ Pv77FooRun = &testPv77FooRun{}

// testPv77FooRun provides convenience methods for interacting with a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow in the test environment
type testPv77FooRun struct {
	client    *TestPv77FooServiceClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *Pv77FooInput
	workflows Pv77FooServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testPv77FooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.patch.v1.Pv77FooService.Pv77Foo workflow result
func (r *testPv77FooRun) Get(context.Context) (*Pv77FooOutput, error) {
	r.env.ExecuteWorkflow(Pv77FooWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result Pv77FooOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.patch.v1.Pv77FooService.Pv77Foo workflow run's workflow ID
func (r *testPv77FooRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testPv77FooRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testPv77FooRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testPv77FooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Pv77FooServiceCliOptions describes runtime configuration for test.patch.v1.Pv77FooService cli
type Pv77FooServiceCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewPv77FooServiceCliOptions initializes a new Pv77FooServiceCliOptions value
func NewPv77FooServiceCliOptions() *Pv77FooServiceCliOptions {
	return &Pv77FooServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *Pv77FooServiceCliOptions) WithAfter(fn func(*v2.Context) error) *Pv77FooServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *Pv77FooServiceCliOptions) WithBefore(fn func(*v2.Context) error) *Pv77FooServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *Pv77FooServiceCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *Pv77FooServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *Pv77FooServiceCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *Pv77FooServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewPv77FooServiceCli initializes a cli for a(n) test.patch.v1.Pv77FooService service
func NewPv77FooServiceCli(options ...*Pv77FooServiceCliOptions) (*v2.App, error) {
	commands, err := newPv77FooServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "pv-77-foo-service",
		Commands: commands,
	}, nil
}

// NewPv77FooServiceCliCommand initializes a cli command for a test.patch.v1.Pv77FooService service with subcommands for each query, signal, update, and workflow
func NewPv77FooServiceCliCommand(options ...*Pv77FooServiceCliOptions) (*v2.Command, error) {
	subcommands, err := newPv77FooServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "pv-77-foo-service",
		Subcommands: subcommands,
	}, nil
}

// newPv77FooServiceCommands initializes (sub)commands for a test.patch.v1.Pv77FooService cli or command
func newPv77FooServiceCommands(options ...*Pv77FooServiceCliOptions) ([]*v2.Command, error) {
	opts := &Pv77FooServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "pv-77-foo",
			Usage:                  "executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "pv77-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringSliceFlag{
					Name:     "next",
					Usage:    "set the value of the operation's \"Next\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewPv77FooServiceClient(tc)
				req, err := UnmarshalCliFlagsToPv77FooInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.Pv77FooAsync(cmd.Context, req, NewPv77FooOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", Pv77FooWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.patch.v1.Pv77FooService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToPv77FooInput unmarshals a Pv77FooInput from command line flags
func UnmarshalCliFlagsToPv77FooInput(cmd *v2.Context) (*Pv77FooInput, error) {
	var result Pv77FooInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("next") {
		hasValues = true
		var tmp Pv77FooInput
		if err := protojson.Unmarshal([]byte(fmt.Sprintf("{\"next\":%s}", cmd.String("next"))), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"next\" map flag: %w", err)
		}
		result.Next = tmp.Next
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithPv77FooServiceSchemeTypes registers all Pv77FooService protobuf types with the given scheme
func WithPv77FooServiceSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77FooInput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77FooOutput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77FooOutput").Messages().ByName("DefaultsEntry"))
	}
}

// Pv77BarServiceTaskQueue is the default task-queue for a test.patch.v1.Pv77BarService worker
const Pv77BarServiceTaskQueue = "pv77-v1"

// test.patch.v1.Pv77BarService workflow names
const (
	Pv77BarWorkflowName = "test.patch.v1.Pv77BarService.Pv77Bar"
)

// test.patch.v1.Pv77BarService activity names
const (
	Pv77BarActivityName = "test.patch.v1.Pv77BarActivity"
)

// Pv77BarServiceClient describes a client for a(n) test.patch.v1.Pv77BarService worker
type Pv77BarServiceClient interface {
	// Pv77Bar executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow and blocks until error or response received
	Pv77Bar(ctx context.Context, req *Pv77BarInput, opts ...*Pv77BarOptions) (*Pv77BarOutput, error)

	// Pv77BarAsync starts a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow and returns a handle to the workflow run
	Pv77BarAsync(ctx context.Context, req *Pv77BarInput, opts ...*Pv77BarOptions) (Pv77BarRun, error)

	// GetPv77Bar retrieves a handle to an existing test.patch.v1.Pv77BarService.Pv77Bar workflow execution
	GetPv77Bar(ctx context.Context, workflowID string, runID string) Pv77BarRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// pv77BarServiceClient implements a temporal client for a test.patch.v1.Pv77BarService service
type pv77BarServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewPv77BarServiceClient initializes a new test.patch.v1.Pv77BarService client
func NewPv77BarServiceClient(c client.Client, options ...*pv77BarServiceClientOptions) Pv77BarServiceClient {
	var cfg *pv77BarServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77BarServiceClientOptions()
	}
	return &pv77BarServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewPv77BarServiceClientWithOptions initializes a new Pv77BarService client with the given options
func NewPv77BarServiceClientWithOptions(c client.Client, opts client.Options, options ...*pv77BarServiceClientOptions) (Pv77BarServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *pv77BarServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77BarServiceClientOptions()
	}
	return &pv77BarServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// pv77BarServiceClientOptions describes optional runtime configuration for a Pv77BarServiceClient
type pv77BarServiceClientOptions struct {
	log *slog.Logger
}

// NewPv77BarServiceClientOptions initializes a new pv77BarServiceClientOptions value
func NewPv77BarServiceClientOptions() *pv77BarServiceClientOptions {
	return &pv77BarServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *pv77BarServiceClientOptions) WithLogger(l *slog.Logger) *pv77BarServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *pv77BarServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.patch.v1.Pv77BarService.Pv77Bar executes a test.patch.v1.Pv77BarService.Pv77Bar workflow and blocks until error or response received
func (c *pv77BarServiceClient) Pv77Bar(ctx context.Context, req *Pv77BarInput, options ...*Pv77BarOptions) (*Pv77BarOutput, error) {
	run, err := c.Pv77BarAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77BarAsync starts a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow and returns a handle to the workflow run
func (c *pv77BarServiceClient) Pv77BarAsync(ctx context.Context, req *Pv77BarInput, options ...*Pv77BarOptions) (Pv77BarRun, error) {
	var o *Pv77BarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, Pv77BarWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &pv77BarRun{
		client: c,
		run:    run,
	}, nil
}

// GetPv77Bar fetches an existing test.patch.v1.Pv77BarService.Pv77Bar execution
func (c *pv77BarServiceClient) GetPv77Bar(ctx context.Context, workflowID string, runID string) Pv77BarRun {
	return &pv77BarRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *pv77BarServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *pv77BarServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// Pv77BarOptions provides configuration for a test.patch.v1.Pv77BarService.Pv77Bar workflow operation
type Pv77BarOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewPv77BarOptions initializes a new Pv77BarOptions value
func NewPv77BarOptions() *Pv77BarOptions {
	return &Pv77BarOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *Pv77BarOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = Pv77BarServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *Pv77BarOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *Pv77BarOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77BarOptions) WithExecutionTimeout(d time.Duration) *Pv77BarOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *Pv77BarOptions) WithID(id string) *Pv77BarOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77BarOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77BarOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BarOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BarOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77BarOptions) WithRunTimeout(d time.Duration) *Pv77BarOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77BarOptions) WithSearchAttributes(sa map[string]any) *Pv77BarOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77BarOptions) WithTaskTimeout(d time.Duration) *Pv77BarOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77BarOptions) WithTaskQueue(tq string) *Pv77BarOptions {
	o.taskQueue = &tq
	return o
}

// Pv77BarRun describes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow run
type Pv77BarRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*Pv77BarOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// pv77BarRun provides an internal implementation of a(n) Pv77BarRunRun
type pv77BarRun struct {
	client *pv77BarServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *pv77BarRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *pv77BarRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *pv77BarRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *pv77BarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *pv77BarRun) Get(ctx context.Context) (*Pv77BarOutput, error) {
	var resp Pv77BarOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *pv77BarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// Pv77BarFunction implements a "test.patch.v1.Pv77BarService.Pv77Bar" workflow
	Pv77BarFunction func(workflow.Context, *Pv77BarInput) (*Pv77BarOutput, error)
)

// Pv77BarServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// Pv77BarServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	Pv77BarServiceWorkflowFunctions interface {
		// Pv77Bar executes a "test.patch.v1.Pv77BarService.Pv77Bar" workflow inline
		Pv77Bar(workflow.Context, *Pv77BarInput) (*Pv77BarOutput, error)
	}
	// pv77BarServiceWorkflowFunctions provides an internal Pv77BarServiceWorkflowFunctions implementation
	pv77BarServiceWorkflowFunctions struct{}
)

func NewPv77BarServiceWorkflowFunctions() Pv77BarServiceWorkflowFunctions {
	return &pv77BarServiceWorkflowFunctions{}
}

// Pv77Bar executes a "test.patch.v1.Pv77BarService.Pv77Bar" workflow inline
func (f *pv77BarServiceWorkflowFunctions) Pv77Bar(ctx workflow.Context, req *Pv77BarInput) (*Pv77BarOutput, error) {
	if Pv77BarFunction == nil {
		return nil, errors.New("Pv77Bar requires workflow registration via RegisterPv77BarServiceWorkflows or RegisterPv77BarWorkflow")
	}
	return Pv77BarFunction(ctx, req)
}

// Pv77BarServiceWorkflows provides methods for initializing new test.patch.v1.Pv77BarService workflow values
type Pv77BarServiceWorkflows interface {
	// Pv77Bar initializes a new a(n) Pv77BarWorkflow implementation
	Pv77Bar(ctx workflow.Context, input *Pv77BarWorkflowInput) (Pv77BarWorkflow, error)
}

// RegisterPv77BarServiceWorkflows registers test.patch.v1.Pv77BarService workflows with the given worker
func RegisterPv77BarServiceWorkflows(r worker.WorkflowRegistry, workflows Pv77BarServiceWorkflows) {
	RegisterPv77BarWorkflow(r, workflows.Pv77Bar)
}

// RegisterPv77BarWorkflow registers a test.patch.v1.Pv77BarService.Pv77Bar workflow with the given worker
func RegisterPv77BarWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *Pv77BarWorkflowInput) (Pv77BarWorkflow, error)) {
	Pv77BarFunction = buildPv77Bar(wf)
	r.RegisterWorkflowWithOptions(Pv77BarFunction, workflow.RegisterOptions{Name: Pv77BarWorkflowName})
}

// buildPv77Bar converts a Pv77Bar workflow struct into a valid workflow function
func buildPv77Bar(ctor func(workflow.Context, *Pv77BarWorkflowInput) (Pv77BarWorkflow, error)) func(workflow.Context, *Pv77BarInput) (*Pv77BarOutput, error) {
	return func(ctx workflow.Context, req *Pv77BarInput) (*Pv77BarOutput, error) {
		input := &Pv77BarWorkflowInput{
			Req: req,
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, Pv77BarServiceTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// Pv77BarWorkflowInput describes the input to a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow constructor
type Pv77BarWorkflowInput struct {
	Req *Pv77BarInput
}

// Pv77BarWorkflow describes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow implementation
type Pv77BarWorkflow interface {
	// Execute defines the entrypoint to a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow
	Execute(ctx workflow.Context) (*Pv77BarOutput, error)
}

// Pv77BarChild executes a child test.patch.v1.Pv77BarService.Pv77Bar workflow and blocks until error or response received
func Pv77BarChild(ctx workflow.Context, req *Pv77BarInput, options ...*Pv77BarChildOptions) (*Pv77BarOutput, error) {
	childRun, err := Pv77BarChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// Pv77BarChildAsync starts a child test.patch.v1.Pv77BarService.Pv77Bar workflow and returns a handle to the child workflow run
func Pv77BarChildAsync(ctx workflow.Context, req *Pv77BarInput, options ...*Pv77BarChildOptions) (*Pv77BarChildRun, error) {
	var o *Pv77BarChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BarChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &Pv77BarChildRun{Future: workflow.ExecuteChildWorkflow(ctx, Pv77BarWorkflowName, req)}, nil
}

// Pv77BarChildOptions provides configuration for a child test.patch.v1.Pv77BarService.Pv77Bar workflow operation
type Pv77BarChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewPv77BarChildOptions initializes a new Pv77BarChildOptions value
func NewPv77BarChildOptions() *Pv77BarChildOptions {
	return &Pv77BarChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *Pv77BarChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if tq := patch.DefaultTaskQueue(ctx, Pv77BarServiceTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
			opts.TaskQueue = tq
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *Pv77BarChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *Pv77BarChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77BarChildOptions) WithExecutionTimeout(d time.Duration) *Pv77BarChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *Pv77BarChildOptions) WithID(id string) *Pv77BarChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77BarChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77BarChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77BarChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77BarChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BarChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BarChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77BarChildOptions) WithRunTimeout(d time.Duration) *Pv77BarChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77BarChildOptions) WithSearchAttributes(sa map[string]any) *Pv77BarChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77BarChildOptions) WithTaskTimeout(d time.Duration) *Pv77BarChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77BarChildOptions) WithTaskQueue(tq string) *Pv77BarChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77BarChildOptions) WithWaitForCancellation(wait bool) *Pv77BarChildOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77BarChildRun describes a child Pv77Bar workflow run
type Pv77BarChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *Pv77BarChildRun) Get(ctx workflow.Context) (*Pv77BarOutput, error) {
	var resp Pv77BarOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *Pv77BarChildRun) Select(sel workflow.Selector, fn func(*Pv77BarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *Pv77BarChildRun) SelectStart(sel workflow.Selector, fn func(*Pv77BarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *Pv77BarChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// Pv77BarServiceActivities describes available worker activities
type Pv77BarServiceActivities interface {
	// test.patch.v1.Pv77BarService.Pv77Bar implements a(n) test.patch.v1.Pv77BarActivity activity definition
	Pv77Bar(ctx context.Context, req *Pv77BarInput) (*Pv77BarOutput, error)
}

// RegisterPv77BarServiceActivities registers activities with a worker
func RegisterPv77BarServiceActivities(r worker.ActivityRegistry, activities Pv77BarServiceActivities) {
	RegisterPv77BarActivity(r, activities.Pv77Bar)
}

// RegisterPv77BarActivity registers a test.patch.v1.Pv77BarActivity activity
func RegisterPv77BarActivity(r worker.ActivityRegistry, fn func(context.Context, *Pv77BarInput) (*Pv77BarOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: Pv77BarActivityName,
	})
}

// Pv77BarFuture describes a(n) test.patch.v1.Pv77BarActivity activity execution
type Pv77BarFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *Pv77BarFuture) Get(ctx workflow.Context) (*Pv77BarOutput, error) {
	var resp Pv77BarOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *Pv77BarFuture) Select(sel workflow.Selector, fn func(*Pv77BarFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Pv77Bar executes a(n) test.patch.v1.Pv77BarActivity activity
func Pv77Bar(ctx workflow.Context, req *Pv77BarInput, options ...*Pv77BarActivityOptions) (*Pv77BarOutput, error) {
	return Pv77BarAsync(ctx, req, options...).Get(ctx)
}

// Pv77BarAsync executes a(n) test.patch.v1.Pv77BarActivity activity (asynchronously)
func Pv77BarAsync(ctx workflow.Context, req *Pv77BarInput, options ...*Pv77BarActivityOptions) *Pv77BarFuture {
	var o *Pv77BarActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BarActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77BarFuture{Future: errF}
	}
	activity := Pv77BarActivityName
	future := &Pv77BarFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// Pv77BarLocal executes a(n) test.patch.v1.Pv77BarActivity activity (locally)
func Pv77BarLocal(ctx workflow.Context, req *Pv77BarInput, options ...*Pv77BarLocalActivityOptions) (*Pv77BarOutput, error) {
	return Pv77BarLocalAsync(ctx, req, options...).Get(ctx)
}

// Pv77BarLocalAsync executes a(n) test.patch.v1.Pv77BarActivity activity (asynchronously, locally)
func Pv77BarLocalAsync(ctx workflow.Context, req *Pv77BarInput, options ...*Pv77BarLocalActivityOptions) *Pv77BarFuture {
	var o *Pv77BarLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BarLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77BarFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = Pv77BarActivityName
	}
	future := &Pv77BarFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// Pv77BarActivityOptions provides configuration for a(n) test.patch.v1.Pv77BarActivity activity
type Pv77BarActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewPv77BarActivityOptions initializes a new Pv77BarActivityOptions value
func NewPv77BarActivityOptions() *Pv77BarActivityOptions {
	return &Pv77BarActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77BarActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if tq := patch.DefaultTaskQueue(ctx, Pv77BarServiceTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
			opts.TaskQueue = tq
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *Pv77BarActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *Pv77BarActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *Pv77BarActivityOptions) WithHeartbeatTimeout(d time.Duration) *Pv77BarActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BarActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BarActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77BarActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77BarActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *Pv77BarActivityOptions) WithScheduleToStartTimeout(d time.Duration) *Pv77BarActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77BarActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77BarActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77BarActivityOptions) WithTaskQueue(tq string) *Pv77BarActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77BarActivityOptions) WithWaitForCancellation(wait bool) *Pv77BarActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77BarLocalActivityOptions provides configuration for a(n) test.patch.v1.Pv77BarActivity activity
type Pv77BarLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *Pv77BarInput) (*Pv77BarOutput, error)
}

// NewPv77BarLocalActivityOptions initializes a new Pv77BarLocalActivityOptions value
func NewPv77BarLocalActivityOptions() *Pv77BarLocalActivityOptions {
	return &Pv77BarLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77BarLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.patch.v1.Pv77BarActivity implementation
func (o *Pv77BarLocalActivityOptions) Local(fn func(context.Context, *Pv77BarInput) (*Pv77BarOutput, error)) *Pv77BarLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *Pv77BarLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *Pv77BarLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BarLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BarLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77BarLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77BarLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77BarLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77BarLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestPv77BarServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows Pv77BarServiceWorkflows
}

var _ Pv77BarServiceClient = &TestPv77BarServiceClient{}

// NewTestPv77BarServiceClient initializes a new TestPv77BarServiceClient value
func NewTestPv77BarServiceClient(env *testsuite.TestWorkflowEnvironment, workflows Pv77BarServiceWorkflows, activities Pv77BarServiceActivities) *TestPv77BarServiceClient {
	if workflows != nil {
		RegisterPv77BarServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterPv77BarServiceActivities(env, activities)
	}
	return &TestPv77BarServiceClient{env, workflows}
}

// Pv77Bar executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow in the test environment
func (c *TestPv77BarServiceClient) Pv77Bar(ctx context.Context, req *Pv77BarInput, opts ...*Pv77BarOptions) (*Pv77BarOutput, error) {
	run, err := c.Pv77BarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77BarAsync executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow in the test environment
func (c *TestPv77BarServiceClient) Pv77BarAsync(ctx context.Context, req *Pv77BarInput, options ...*Pv77BarOptions) (Pv77BarRun, error) {
	var o *Pv77BarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testPv77BarRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetPv77Bar is a noop
func (c *TestPv77BarServiceClient) GetPv77Bar(ctx context.Context, workflowID string, runID string) Pv77BarRun {
	return &testPv77BarRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestPv77BarServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestPv77BarServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ Pv77BarRun = &testPv77BarRun{}

// testPv77BarRun provides convenience methods for interacting with a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow in the test environment
type testPv77BarRun struct {
	client    *TestPv77BarServiceClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *Pv77BarInput
	workflows Pv77BarServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testPv77BarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.patch.v1.Pv77BarService.Pv77Bar workflow result
func (r *testPv77BarRun) Get(context.Context) (*Pv77BarOutput, error) {
	r.env.ExecuteWorkflow(Pv77BarWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result Pv77BarOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.patch.v1.Pv77BarService.Pv77Bar workflow run's workflow ID
func (r *testPv77BarRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testPv77BarRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testPv77BarRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testPv77BarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Pv77BarServiceCliOptions describes runtime configuration for test.patch.v1.Pv77BarService cli
type Pv77BarServiceCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewPv77BarServiceCliOptions initializes a new Pv77BarServiceCliOptions value
func NewPv77BarServiceCliOptions() *Pv77BarServiceCliOptions {
	return &Pv77BarServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *Pv77BarServiceCliOptions) WithAfter(fn func(*v2.Context) error) *Pv77BarServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *Pv77BarServiceCliOptions) WithBefore(fn func(*v2.Context) error) *Pv77BarServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *Pv77BarServiceCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *Pv77BarServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *Pv77BarServiceCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *Pv77BarServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewPv77BarServiceCli initializes a cli for a(n) test.patch.v1.Pv77BarService service
func NewPv77BarServiceCli(options ...*Pv77BarServiceCliOptions) (*v2.App, error) {
	commands, err := newPv77BarServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "pv-77-bar-service",
		Commands: commands,
	}, nil
}

// NewPv77BarServiceCliCommand initializes a cli command for a test.patch.v1.Pv77BarService service with subcommands for each query, signal, update, and workflow
func NewPv77BarServiceCliCommand(options ...*Pv77BarServiceCliOptions) (*v2.Command, error) {
	subcommands, err := newPv77BarServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "pv-77-bar-service",
		Subcommands: subcommands,
	}, nil
}

// newPv77BarServiceCommands initializes (sub)commands for a test.patch.v1.Pv77BarService cli or command
func newPv77BarServiceCommands(options ...*Pv77BarServiceCliOptions) ([]*v2.Command, error) {
	opts := &Pv77BarServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "pv-77-bar",
			Usage:                  "executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "pv77-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringSliceFlag{
					Name:     "next",
					Usage:    "set the value of the operation's \"Next\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewPv77BarServiceClient(tc)
				req, err := UnmarshalCliFlagsToPv77BarInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.Pv77BarAsync(cmd.Context, req, NewPv77BarOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", Pv77BarWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.patch.v1.Pv77BarService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToPv77BarInput unmarshals a Pv77BarInput from command line flags
func UnmarshalCliFlagsToPv77BarInput(cmd *v2.Context) (*Pv77BarInput, error) {
	var result Pv77BarInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("next") {
		hasValues = true
		var tmp Pv77BarInput
		if err := protojson.Unmarshal([]byte(fmt.Sprintf("{\"next\":%s}", cmd.String("next"))), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"next\" map flag: %w", err)
		}
		result.Next = tmp.Next
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithPv77BarServiceSchemeTypes registers all Pv77BarService protobuf types with the given scheme
func WithPv77BarServiceSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77BarInput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77BarOutput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77BarOutput").Messages().ByName("DefaultsEntry"))
	}
}

// Pv77BazServiceTaskQueue is the default task-queue for a test.patch.v1.Pv77BazService worker
const Pv77BazServiceTaskQueue = "pv77-v3"

// test.patch.v1.Pv77BazService workflow names
const (
	Pv77BazWorkflowName = "test.patch.v1.Pv77BazService.Pv77Baz"
)

// test.patch.v1.Pv77BazService activity names
const (
	Pv77BazActivityName = "test.patch.v1.Pv77BazActivity"
)

// Pv77BazServiceClient describes a client for a(n) test.patch.v1.Pv77BazService worker
type Pv77BazServiceClient interface {
	// Pv77Baz executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow and blocks until error or response received
	Pv77Baz(ctx context.Context, req *Pv77BazInput, opts ...*Pv77BazOptions) (*Pv77BazOutput, error)

	// Pv77BazAsync starts a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow and returns a handle to the workflow run
	Pv77BazAsync(ctx context.Context, req *Pv77BazInput, opts ...*Pv77BazOptions) (Pv77BazRun, error)

	// GetPv77Baz retrieves a handle to an existing test.patch.v1.Pv77BazService.Pv77Baz workflow execution
	GetPv77Baz(ctx context.Context, workflowID string, runID string) Pv77BazRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// pv77BazServiceClient implements a temporal client for a test.patch.v1.Pv77BazService service
type pv77BazServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewPv77BazServiceClient initializes a new test.patch.v1.Pv77BazService client
func NewPv77BazServiceClient(c client.Client, options ...*pv77BazServiceClientOptions) Pv77BazServiceClient {
	var cfg *pv77BazServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77BazServiceClientOptions()
	}
	return &pv77BazServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewPv77BazServiceClientWithOptions initializes a new Pv77BazService client with the given options
func NewPv77BazServiceClientWithOptions(c client.Client, opts client.Options, options ...*pv77BazServiceClientOptions) (Pv77BazServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *pv77BazServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77BazServiceClientOptions()
	}
	return &pv77BazServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// pv77BazServiceClientOptions describes optional runtime configuration for a Pv77BazServiceClient
type pv77BazServiceClientOptions struct {
	log *slog.Logger
}

// NewPv77BazServiceClientOptions initializes a new pv77BazServiceClientOptions value
func NewPv77BazServiceClientOptions() *pv77BazServiceClientOptions {
	return &pv77BazServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *pv77BazServiceClientOptions) WithLogger(l *slog.Logger) *pv77BazServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *pv77BazServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.patch.v1.Pv77BazService.Pv77Baz executes a test.patch.v1.Pv77BazService.Pv77Baz workflow and blocks until error or response received
func (c *pv77BazServiceClient) Pv77Baz(ctx context.Context, req *Pv77BazInput, options ...*Pv77BazOptions) (*Pv77BazOutput, error) {
	run, err := c.Pv77BazAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77BazAsync starts a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow and returns a handle to the workflow run
func (c *pv77BazServiceClient) Pv77BazAsync(ctx context.Context, req *Pv77BazInput, options ...*Pv77BazOptions) (Pv77BazRun, error) {
	var o *Pv77BazOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BazOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, Pv77BazWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &pv77BazRun{
		client: c,
		run:    run,
	}, nil
}

// GetPv77Baz fetches an existing test.patch.v1.Pv77BazService.Pv77Baz execution
func (c *pv77BazServiceClient) GetPv77Baz(ctx context.Context, workflowID string, runID string) Pv77BazRun {
	return &pv77BazRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *pv77BazServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *pv77BazServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// Pv77BazOptions provides configuration for a test.patch.v1.Pv77BazService.Pv77Baz workflow operation
type Pv77BazOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewPv77BazOptions initializes a new Pv77BazOptions value
func NewPv77BazOptions() *Pv77BazOptions {
	return &Pv77BazOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *Pv77BazOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = Pv77BazServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *Pv77BazOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *Pv77BazOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77BazOptions) WithExecutionTimeout(d time.Duration) *Pv77BazOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *Pv77BazOptions) WithID(id string) *Pv77BazOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77BazOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77BazOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BazOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BazOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77BazOptions) WithRunTimeout(d time.Duration) *Pv77BazOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77BazOptions) WithSearchAttributes(sa map[string]any) *Pv77BazOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77BazOptions) WithTaskTimeout(d time.Duration) *Pv77BazOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77BazOptions) WithTaskQueue(tq string) *Pv77BazOptions {
	o.taskQueue = &tq
	return o
}

// Pv77BazRun describes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow run
type Pv77BazRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*Pv77BazOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// pv77BazRun provides an internal implementation of a(n) Pv77BazRunRun
type pv77BazRun struct {
	client *pv77BazServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *pv77BazRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *pv77BazRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *pv77BazRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *pv77BazRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *pv77BazRun) Get(ctx context.Context) (*Pv77BazOutput, error) {
	var resp Pv77BazOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *pv77BazRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// Pv77BazFunction implements a "test.patch.v1.Pv77BazService.Pv77Baz" workflow
	Pv77BazFunction func(workflow.Context, *Pv77BazInput) (*Pv77BazOutput, error)
)

// Pv77BazServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// Pv77BazServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	Pv77BazServiceWorkflowFunctions interface {
		// Pv77Baz executes a "test.patch.v1.Pv77BazService.Pv77Baz" workflow inline
		Pv77Baz(workflow.Context, *Pv77BazInput) (*Pv77BazOutput, error)
	}
	// pv77BazServiceWorkflowFunctions provides an internal Pv77BazServiceWorkflowFunctions implementation
	pv77BazServiceWorkflowFunctions struct{}
)

func NewPv77BazServiceWorkflowFunctions() Pv77BazServiceWorkflowFunctions {
	return &pv77BazServiceWorkflowFunctions{}
}

// Pv77Baz executes a "test.patch.v1.Pv77BazService.Pv77Baz" workflow inline
func (f *pv77BazServiceWorkflowFunctions) Pv77Baz(ctx workflow.Context, req *Pv77BazInput) (*Pv77BazOutput, error) {
	if Pv77BazFunction == nil {
		return nil, errors.New("Pv77Baz requires workflow registration via RegisterPv77BazServiceWorkflows or RegisterPv77BazWorkflow")
	}
	return Pv77BazFunction(ctx, req)
}

// Pv77BazServiceWorkflows provides methods for initializing new test.patch.v1.Pv77BazService workflow values
type Pv77BazServiceWorkflows interface {
	// Pv77Baz initializes a new a(n) Pv77BazWorkflow implementation
	Pv77Baz(ctx workflow.Context, input *Pv77BazWorkflowInput) (Pv77BazWorkflow, error)
}

// RegisterPv77BazServiceWorkflows registers test.patch.v1.Pv77BazService workflows with the given worker
func RegisterPv77BazServiceWorkflows(r worker.WorkflowRegistry, workflows Pv77BazServiceWorkflows) {
	RegisterPv77BazWorkflow(r, workflows.Pv77Baz)
}

// RegisterPv77BazWorkflow registers a test.patch.v1.Pv77BazService.Pv77Baz workflow with the given worker
func RegisterPv77BazWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *Pv77BazWorkflowInput) (Pv77BazWorkflow, error)) {
	Pv77BazFunction = buildPv77Baz(wf)
	r.RegisterWorkflowWithOptions(Pv77BazFunction, workflow.RegisterOptions{Name: Pv77BazWorkflowName})
}

// buildPv77Baz converts a Pv77Baz workflow struct into a valid workflow function
func buildPv77Baz(ctor func(workflow.Context, *Pv77BazWorkflowInput) (Pv77BazWorkflow, error)) func(workflow.Context, *Pv77BazInput) (*Pv77BazOutput, error) {
	return func(ctx workflow.Context, req *Pv77BazInput) (*Pv77BazOutput, error) {
		input := &Pv77BazWorkflowInput{
			Req: req,
		}
		// inject default task queue and override into workflow context
		ctx = patch.WithDefaultTaskQueue(workflow.WithValue, ctx, Pv77BazServiceTaskQueue, workflow.GetInfo(ctx).TaskQueueName)
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// Pv77BazWorkflowInput describes the input to a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow constructor
type Pv77BazWorkflowInput struct {
	Req *Pv77BazInput
}

// Pv77BazWorkflow describes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow implementation
type Pv77BazWorkflow interface {
	// Execute defines the entrypoint to a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow
	Execute(ctx workflow.Context) (*Pv77BazOutput, error)
}

// Pv77BazChild executes a child test.patch.v1.Pv77BazService.Pv77Baz workflow and blocks until error or response received
func Pv77BazChild(ctx workflow.Context, req *Pv77BazInput, options ...*Pv77BazChildOptions) (*Pv77BazOutput, error) {
	childRun, err := Pv77BazChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// Pv77BazChildAsync starts a child test.patch.v1.Pv77BazService.Pv77Baz workflow and returns a handle to the child workflow run
func Pv77BazChildAsync(ctx workflow.Context, req *Pv77BazInput, options ...*Pv77BazChildOptions) (*Pv77BazChildRun, error) {
	var o *Pv77BazChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BazChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &Pv77BazChildRun{Future: workflow.ExecuteChildWorkflow(ctx, Pv77BazWorkflowName, req)}, nil
}

// Pv77BazChildOptions provides configuration for a child test.patch.v1.Pv77BazService.Pv77Baz workflow operation
type Pv77BazChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewPv77BazChildOptions initializes a new Pv77BazChildOptions value
func NewPv77BazChildOptions() *Pv77BazChildOptions {
	return &Pv77BazChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *Pv77BazChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if tq := patch.DefaultTaskQueue(ctx, Pv77BazServiceTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
			opts.TaskQueue = tq
		}
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *Pv77BazChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *Pv77BazChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77BazChildOptions) WithExecutionTimeout(d time.Duration) *Pv77BazChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *Pv77BazChildOptions) WithID(id string) *Pv77BazChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77BazChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77BazChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77BazChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77BazChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BazChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BazChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77BazChildOptions) WithRunTimeout(d time.Duration) *Pv77BazChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77BazChildOptions) WithSearchAttributes(sa map[string]any) *Pv77BazChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77BazChildOptions) WithTaskTimeout(d time.Duration) *Pv77BazChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77BazChildOptions) WithTaskQueue(tq string) *Pv77BazChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77BazChildOptions) WithWaitForCancellation(wait bool) *Pv77BazChildOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77BazChildRun describes a child Pv77Baz workflow run
type Pv77BazChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *Pv77BazChildRun) Get(ctx workflow.Context) (*Pv77BazOutput, error) {
	var resp Pv77BazOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *Pv77BazChildRun) Select(sel workflow.Selector, fn func(*Pv77BazChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *Pv77BazChildRun) SelectStart(sel workflow.Selector, fn func(*Pv77BazChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *Pv77BazChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// Pv77BazServiceActivities describes available worker activities
type Pv77BazServiceActivities interface {
	// test.patch.v1.Pv77BazService.Pv77Baz implements a(n) test.patch.v1.Pv77BazActivity activity definition
	Pv77Baz(ctx context.Context, req *Pv77BazInput) (*Pv77BazOutput, error)
}

// RegisterPv77BazServiceActivities registers activities with a worker
func RegisterPv77BazServiceActivities(r worker.ActivityRegistry, activities Pv77BazServiceActivities) {
	RegisterPv77BazActivity(r, activities.Pv77Baz)
}

// RegisterPv77BazActivity registers a test.patch.v1.Pv77BazActivity activity
func RegisterPv77BazActivity(r worker.ActivityRegistry, fn func(context.Context, *Pv77BazInput) (*Pv77BazOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: Pv77BazActivityName,
	})
}

// Pv77BazFuture describes a(n) test.patch.v1.Pv77BazActivity activity execution
type Pv77BazFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *Pv77BazFuture) Get(ctx workflow.Context) (*Pv77BazOutput, error) {
	var resp Pv77BazOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *Pv77BazFuture) Select(sel workflow.Selector, fn func(*Pv77BazFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Pv77Baz executes a(n) test.patch.v1.Pv77BazActivity activity
func Pv77Baz(ctx workflow.Context, req *Pv77BazInput, options ...*Pv77BazActivityOptions) (*Pv77BazOutput, error) {
	return Pv77BazAsync(ctx, req, options...).Get(ctx)
}

// Pv77BazAsync executes a(n) test.patch.v1.Pv77BazActivity activity (asynchronously)
func Pv77BazAsync(ctx workflow.Context, req *Pv77BazInput, options ...*Pv77BazActivityOptions) *Pv77BazFuture {
	var o *Pv77BazActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BazActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77BazFuture{Future: errF}
	}
	activity := Pv77BazActivityName
	future := &Pv77BazFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// Pv77BazLocal executes a(n) test.patch.v1.Pv77BazActivity activity (locally)
func Pv77BazLocal(ctx workflow.Context, req *Pv77BazInput, options ...*Pv77BazLocalActivityOptions) (*Pv77BazOutput, error) {
	return Pv77BazLocalAsync(ctx, req, options...).Get(ctx)
}

// Pv77BazLocalAsync executes a(n) test.patch.v1.Pv77BazActivity activity (asynchronously, locally)
func Pv77BazLocalAsync(ctx workflow.Context, req *Pv77BazInput, options ...*Pv77BazLocalActivityOptions) *Pv77BazFuture {
	var o *Pv77BazLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BazLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77BazFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = Pv77BazActivityName
	}
	future := &Pv77BazFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// Pv77BazActivityOptions provides configuration for a(n) test.patch.v1.Pv77BazActivity activity
type Pv77BazActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewPv77BazActivityOptions initializes a new Pv77BazActivityOptions value
func NewPv77BazActivityOptions() *Pv77BazActivityOptions {
	return &Pv77BazActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77BazActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		// use parent workflow task queue for child workflows and activities
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_77-use-parent-task-queue
		if tq := patch.DefaultTaskQueue(ctx, Pv77BazServiceTaskQueue); tq != "" && tq != workflow.GetInfo(ctx).TaskQueueName {
			opts.TaskQueue = tq
		}
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *Pv77BazActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *Pv77BazActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *Pv77BazActivityOptions) WithHeartbeatTimeout(d time.Duration) *Pv77BazActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BazActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BazActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77BazActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77BazActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *Pv77BazActivityOptions) WithScheduleToStartTimeout(d time.Duration) *Pv77BazActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77BazActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77BazActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77BazActivityOptions) WithTaskQueue(tq string) *Pv77BazActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77BazActivityOptions) WithWaitForCancellation(wait bool) *Pv77BazActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77BazLocalActivityOptions provides configuration for a(n) test.patch.v1.Pv77BazActivity activity
type Pv77BazLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *Pv77BazInput) (*Pv77BazOutput, error)
}

// NewPv77BazLocalActivityOptions initializes a new Pv77BazLocalActivityOptions value
func NewPv77BazLocalActivityOptions() *Pv77BazLocalActivityOptions {
	return &Pv77BazLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77BazLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.patch.v1.Pv77BazActivity implementation
func (o *Pv77BazLocalActivityOptions) Local(fn func(context.Context, *Pv77BazInput) (*Pv77BazOutput, error)) *Pv77BazLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *Pv77BazLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *Pv77BazLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77BazLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77BazLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77BazLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77BazLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77BazLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77BazLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestPv77BazServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows Pv77BazServiceWorkflows
}

var _ Pv77BazServiceClient = &TestPv77BazServiceClient{}

// NewTestPv77BazServiceClient initializes a new TestPv77BazServiceClient value
func NewTestPv77BazServiceClient(env *testsuite.TestWorkflowEnvironment, workflows Pv77BazServiceWorkflows, activities Pv77BazServiceActivities) *TestPv77BazServiceClient {
	if workflows != nil {
		RegisterPv77BazServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterPv77BazServiceActivities(env, activities)
	}
	return &TestPv77BazServiceClient{env, workflows}
}

// Pv77Baz executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow in the test environment
func (c *TestPv77BazServiceClient) Pv77Baz(ctx context.Context, req *Pv77BazInput, opts ...*Pv77BazOptions) (*Pv77BazOutput, error) {
	run, err := c.Pv77BazAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77BazAsync executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow in the test environment
func (c *TestPv77BazServiceClient) Pv77BazAsync(ctx context.Context, req *Pv77BazInput, options ...*Pv77BazOptions) (Pv77BazRun, error) {
	var o *Pv77BazOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77BazOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testPv77BazRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetPv77Baz is a noop
func (c *TestPv77BazServiceClient) GetPv77Baz(ctx context.Context, workflowID string, runID string) Pv77BazRun {
	return &testPv77BazRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestPv77BazServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestPv77BazServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ Pv77BazRun = &testPv77BazRun{}

// testPv77BazRun provides convenience methods for interacting with a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow in the test environment
type testPv77BazRun struct {
	client    *TestPv77BazServiceClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *Pv77BazInput
	workflows Pv77BazServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testPv77BazRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.patch.v1.Pv77BazService.Pv77Baz workflow result
func (r *testPv77BazRun) Get(context.Context) (*Pv77BazOutput, error) {
	r.env.ExecuteWorkflow(Pv77BazWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result Pv77BazOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.patch.v1.Pv77BazService.Pv77Baz workflow run's workflow ID
func (r *testPv77BazRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testPv77BazRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testPv77BazRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testPv77BazRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Pv77BazServiceCliOptions describes runtime configuration for test.patch.v1.Pv77BazService cli
type Pv77BazServiceCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewPv77BazServiceCliOptions initializes a new Pv77BazServiceCliOptions value
func NewPv77BazServiceCliOptions() *Pv77BazServiceCliOptions {
	return &Pv77BazServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *Pv77BazServiceCliOptions) WithAfter(fn func(*v2.Context) error) *Pv77BazServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *Pv77BazServiceCliOptions) WithBefore(fn func(*v2.Context) error) *Pv77BazServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *Pv77BazServiceCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *Pv77BazServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *Pv77BazServiceCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *Pv77BazServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewPv77BazServiceCli initializes a cli for a(n) test.patch.v1.Pv77BazService service
func NewPv77BazServiceCli(options ...*Pv77BazServiceCliOptions) (*v2.App, error) {
	commands, err := newPv77BazServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "pv-77-baz-service",
		Commands: commands,
	}, nil
}

// NewPv77BazServiceCliCommand initializes a cli command for a test.patch.v1.Pv77BazService service with subcommands for each query, signal, update, and workflow
func NewPv77BazServiceCliCommand(options ...*Pv77BazServiceCliOptions) (*v2.Command, error) {
	subcommands, err := newPv77BazServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "pv-77-baz-service",
		Subcommands: subcommands,
	}, nil
}

// newPv77BazServiceCommands initializes (sub)commands for a test.patch.v1.Pv77BazService cli or command
func newPv77BazServiceCommands(options ...*Pv77BazServiceCliOptions) ([]*v2.Command, error) {
	opts := &Pv77BazServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "pv-77-baz",
			Usage:                  "executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "pv77-v3",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringSliceFlag{
					Name:     "next",
					Usage:    "set the value of the operation's \"Next\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewPv77BazServiceClient(tc)
				req, err := UnmarshalCliFlagsToPv77BazInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.Pv77BazAsync(cmd.Context, req, NewPv77BazOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", Pv77BazWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.patch.v1.Pv77BazService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToPv77BazInput unmarshals a Pv77BazInput from command line flags
func UnmarshalCliFlagsToPv77BazInput(cmd *v2.Context) (*Pv77BazInput, error) {
	var result Pv77BazInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("next") {
		hasValues = true
		var tmp Pv77BazInput
		if err := protojson.Unmarshal([]byte(fmt.Sprintf("{\"next\":%s}", cmd.String("next"))), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"next\" map flag: %w", err)
		}
		result.Next = tmp.Next
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithPv77BazServiceSchemeTypes registers all Pv77BazService protobuf types with the given scheme
func WithPv77BazServiceSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77BazInput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77BazOutput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77BazOutput").Messages().ByName("DefaultsEntry"))
	}
}

// Pv77QuxServiceTaskQueue is the default task-queue for a test.patch.v1.Pv77QuxService worker
const Pv77QuxServiceTaskQueue = "pv77-v2"

// test.patch.v1.Pv77QuxService workflow names
const (
	Pv77QuxWorkflowName = "test.patch.v1.Pv77QuxService.Pv77Qux"
)

// test.patch.v1.Pv77QuxService activity names
const (
	Pv77QuxActivityName = "test.patch.v1.Pv77QuxActivity"
)

// Pv77QuxServiceClient describes a client for a(n) test.patch.v1.Pv77QuxService worker
type Pv77QuxServiceClient interface {
	// Pv77Qux executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow and blocks until error or response received
	Pv77Qux(ctx context.Context, req *Pv77QuxInput, opts ...*Pv77QuxOptions) (*Pv77QuxOutput, error)

	// Pv77QuxAsync starts a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow and returns a handle to the workflow run
	Pv77QuxAsync(ctx context.Context, req *Pv77QuxInput, opts ...*Pv77QuxOptions) (Pv77QuxRun, error)

	// GetPv77Qux retrieves a handle to an existing test.patch.v1.Pv77QuxService.Pv77Qux workflow execution
	GetPv77Qux(ctx context.Context, workflowID string, runID string) Pv77QuxRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// pv77QuxServiceClient implements a temporal client for a test.patch.v1.Pv77QuxService service
type pv77QuxServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewPv77QuxServiceClient initializes a new test.patch.v1.Pv77QuxService client
func NewPv77QuxServiceClient(c client.Client, options ...*pv77QuxServiceClientOptions) Pv77QuxServiceClient {
	var cfg *pv77QuxServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77QuxServiceClientOptions()
	}
	return &pv77QuxServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewPv77QuxServiceClientWithOptions initializes a new Pv77QuxService client with the given options
func NewPv77QuxServiceClientWithOptions(c client.Client, opts client.Options, options ...*pv77QuxServiceClientOptions) (Pv77QuxServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *pv77QuxServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewPv77QuxServiceClientOptions()
	}
	return &pv77QuxServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// pv77QuxServiceClientOptions describes optional runtime configuration for a Pv77QuxServiceClient
type pv77QuxServiceClientOptions struct {
	log *slog.Logger
}

// NewPv77QuxServiceClientOptions initializes a new pv77QuxServiceClientOptions value
func NewPv77QuxServiceClientOptions() *pv77QuxServiceClientOptions {
	return &pv77QuxServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *pv77QuxServiceClientOptions) WithLogger(l *slog.Logger) *pv77QuxServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *pv77QuxServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.patch.v1.Pv77QuxService.Pv77Qux executes a test.patch.v1.Pv77QuxService.Pv77Qux workflow and blocks until error or response received
func (c *pv77QuxServiceClient) Pv77Qux(ctx context.Context, req *Pv77QuxInput, options ...*Pv77QuxOptions) (*Pv77QuxOutput, error) {
	run, err := c.Pv77QuxAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77QuxAsync starts a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow and returns a handle to the workflow run
func (c *pv77QuxServiceClient) Pv77QuxAsync(ctx context.Context, req *Pv77QuxInput, options ...*Pv77QuxOptions) (Pv77QuxRun, error) {
	var o *Pv77QuxOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77QuxOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, Pv77QuxWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &pv77QuxRun{
		client: c,
		run:    run,
	}, nil
}

// GetPv77Qux fetches an existing test.patch.v1.Pv77QuxService.Pv77Qux execution
func (c *pv77QuxServiceClient) GetPv77Qux(ctx context.Context, workflowID string, runID string) Pv77QuxRun {
	return &pv77QuxRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *pv77QuxServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *pv77QuxServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// Pv77QuxOptions provides configuration for a test.patch.v1.Pv77QuxService.Pv77Qux workflow operation
type Pv77QuxOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewPv77QuxOptions initializes a new Pv77QuxOptions value
func NewPv77QuxOptions() *Pv77QuxOptions {
	return &Pv77QuxOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *Pv77QuxOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = Pv77QuxServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *Pv77QuxOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *Pv77QuxOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77QuxOptions) WithExecutionTimeout(d time.Duration) *Pv77QuxOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *Pv77QuxOptions) WithID(id string) *Pv77QuxOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77QuxOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77QuxOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77QuxOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77QuxOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77QuxOptions) WithRunTimeout(d time.Duration) *Pv77QuxOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77QuxOptions) WithSearchAttributes(sa map[string]any) *Pv77QuxOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77QuxOptions) WithTaskTimeout(d time.Duration) *Pv77QuxOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77QuxOptions) WithTaskQueue(tq string) *Pv77QuxOptions {
	o.taskQueue = &tq
	return o
}

// Pv77QuxRun describes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow run
type Pv77QuxRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*Pv77QuxOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// pv77QuxRun provides an internal implementation of a(n) Pv77QuxRunRun
type pv77QuxRun struct {
	client *pv77QuxServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *pv77QuxRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *pv77QuxRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *pv77QuxRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *pv77QuxRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *pv77QuxRun) Get(ctx context.Context) (*Pv77QuxOutput, error) {
	var resp Pv77QuxOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *pv77QuxRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// Pv77QuxFunction implements a "test.patch.v1.Pv77QuxService.Pv77Qux" workflow
	Pv77QuxFunction func(workflow.Context, *Pv77QuxInput) (*Pv77QuxOutput, error)
)

// Pv77QuxServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// Pv77QuxServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	Pv77QuxServiceWorkflowFunctions interface {
		// Pv77Qux executes a "test.patch.v1.Pv77QuxService.Pv77Qux" workflow inline
		Pv77Qux(workflow.Context, *Pv77QuxInput) (*Pv77QuxOutput, error)
	}
	// pv77QuxServiceWorkflowFunctions provides an internal Pv77QuxServiceWorkflowFunctions implementation
	pv77QuxServiceWorkflowFunctions struct{}
)

func NewPv77QuxServiceWorkflowFunctions() Pv77QuxServiceWorkflowFunctions {
	return &pv77QuxServiceWorkflowFunctions{}
}

// Pv77Qux executes a "test.patch.v1.Pv77QuxService.Pv77Qux" workflow inline
func (f *pv77QuxServiceWorkflowFunctions) Pv77Qux(ctx workflow.Context, req *Pv77QuxInput) (*Pv77QuxOutput, error) {
	if Pv77QuxFunction == nil {
		return nil, errors.New("Pv77Qux requires workflow registration via RegisterPv77QuxServiceWorkflows or RegisterPv77QuxWorkflow")
	}
	return Pv77QuxFunction(ctx, req)
}

// Pv77QuxServiceWorkflows provides methods for initializing new test.patch.v1.Pv77QuxService workflow values
type Pv77QuxServiceWorkflows interface {
	// Pv77Qux initializes a new a(n) Pv77QuxWorkflow implementation
	Pv77Qux(ctx workflow.Context, input *Pv77QuxWorkflowInput) (Pv77QuxWorkflow, error)
}

// RegisterPv77QuxServiceWorkflows registers test.patch.v1.Pv77QuxService workflows with the given worker
func RegisterPv77QuxServiceWorkflows(r worker.WorkflowRegistry, workflows Pv77QuxServiceWorkflows) {
	RegisterPv77QuxWorkflow(r, workflows.Pv77Qux)
}

// RegisterPv77QuxWorkflow registers a test.patch.v1.Pv77QuxService.Pv77Qux workflow with the given worker
func RegisterPv77QuxWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *Pv77QuxWorkflowInput) (Pv77QuxWorkflow, error)) {
	Pv77QuxFunction = buildPv77Qux(wf)
	r.RegisterWorkflowWithOptions(Pv77QuxFunction, workflow.RegisterOptions{Name: Pv77QuxWorkflowName})
}

// buildPv77Qux converts a Pv77Qux workflow struct into a valid workflow function
func buildPv77Qux(ctor func(workflow.Context, *Pv77QuxWorkflowInput) (Pv77QuxWorkflow, error)) func(workflow.Context, *Pv77QuxInput) (*Pv77QuxOutput, error) {
	return func(ctx workflow.Context, req *Pv77QuxInput) (*Pv77QuxOutput, error) {
		input := &Pv77QuxWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// Pv77QuxWorkflowInput describes the input to a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow constructor
type Pv77QuxWorkflowInput struct {
	Req *Pv77QuxInput
}

// Pv77QuxWorkflow describes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow implementation
type Pv77QuxWorkflow interface {
	// Execute defines the entrypoint to a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow
	Execute(ctx workflow.Context) (*Pv77QuxOutput, error)
}

// Pv77QuxChild executes a child test.patch.v1.Pv77QuxService.Pv77Qux workflow and blocks until error or response received
func Pv77QuxChild(ctx workflow.Context, req *Pv77QuxInput, options ...*Pv77QuxChildOptions) (*Pv77QuxOutput, error) {
	childRun, err := Pv77QuxChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// Pv77QuxChildAsync starts a child test.patch.v1.Pv77QuxService.Pv77Qux workflow and returns a handle to the child workflow run
func Pv77QuxChildAsync(ctx workflow.Context, req *Pv77QuxInput, options ...*Pv77QuxChildOptions) (*Pv77QuxChildRun, error) {
	var o *Pv77QuxChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77QuxChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &Pv77QuxChildRun{Future: workflow.ExecuteChildWorkflow(ctx, Pv77QuxWorkflowName, req)}, nil
}

// Pv77QuxChildOptions provides configuration for a child test.patch.v1.Pv77QuxService.Pv77Qux workflow operation
type Pv77QuxChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewPv77QuxChildOptions initializes a new Pv77QuxChildOptions value
func NewPv77QuxChildOptions() *Pv77QuxChildOptions {
	return &Pv77QuxChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *Pv77QuxChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = Pv77QuxServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *Pv77QuxChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *Pv77QuxChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *Pv77QuxChildOptions) WithExecutionTimeout(d time.Duration) *Pv77QuxChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *Pv77QuxChildOptions) WithID(id string) *Pv77QuxChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77QuxChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *Pv77QuxChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *Pv77QuxChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77QuxChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77QuxChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77QuxChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *Pv77QuxChildOptions) WithRunTimeout(d time.Duration) *Pv77QuxChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *Pv77QuxChildOptions) WithSearchAttributes(sa map[string]any) *Pv77QuxChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *Pv77QuxChildOptions) WithTaskTimeout(d time.Duration) *Pv77QuxChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77QuxChildOptions) WithTaskQueue(tq string) *Pv77QuxChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77QuxChildOptions) WithWaitForCancellation(wait bool) *Pv77QuxChildOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77QuxChildRun describes a child Pv77Qux workflow run
type Pv77QuxChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *Pv77QuxChildRun) Get(ctx workflow.Context) (*Pv77QuxOutput, error) {
	var resp Pv77QuxOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *Pv77QuxChildRun) Select(sel workflow.Selector, fn func(*Pv77QuxChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *Pv77QuxChildRun) SelectStart(sel workflow.Selector, fn func(*Pv77QuxChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *Pv77QuxChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// Pv77QuxServiceActivities describes available worker activities
type Pv77QuxServiceActivities interface {
	// test.patch.v1.Pv77QuxService.Pv77Qux implements a(n) test.patch.v1.Pv77QuxActivity activity definition
	Pv77Qux(ctx context.Context, req *Pv77QuxInput) (*Pv77QuxOutput, error)
}

// RegisterPv77QuxServiceActivities registers activities with a worker
func RegisterPv77QuxServiceActivities(r worker.ActivityRegistry, activities Pv77QuxServiceActivities) {
	RegisterPv77QuxActivity(r, activities.Pv77Qux)
}

// RegisterPv77QuxActivity registers a test.patch.v1.Pv77QuxActivity activity
func RegisterPv77QuxActivity(r worker.ActivityRegistry, fn func(context.Context, *Pv77QuxInput) (*Pv77QuxOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: Pv77QuxActivityName,
	})
}

// Pv77QuxFuture describes a(n) test.patch.v1.Pv77QuxActivity activity execution
type Pv77QuxFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *Pv77QuxFuture) Get(ctx workflow.Context) (*Pv77QuxOutput, error) {
	var resp Pv77QuxOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *Pv77QuxFuture) Select(sel workflow.Selector, fn func(*Pv77QuxFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Pv77Qux executes a(n) test.patch.v1.Pv77QuxActivity activity
func Pv77Qux(ctx workflow.Context, req *Pv77QuxInput, options ...*Pv77QuxActivityOptions) (*Pv77QuxOutput, error) {
	return Pv77QuxAsync(ctx, req, options...).Get(ctx)
}

// Pv77QuxAsync executes a(n) test.patch.v1.Pv77QuxActivity activity (asynchronously)
func Pv77QuxAsync(ctx workflow.Context, req *Pv77QuxInput, options ...*Pv77QuxActivityOptions) *Pv77QuxFuture {
	var o *Pv77QuxActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77QuxActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77QuxFuture{Future: errF}
	}
	activity := Pv77QuxActivityName
	future := &Pv77QuxFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// Pv77QuxLocal executes a(n) test.patch.v1.Pv77QuxActivity activity (locally)
func Pv77QuxLocal(ctx workflow.Context, req *Pv77QuxInput, options ...*Pv77QuxLocalActivityOptions) (*Pv77QuxOutput, error) {
	return Pv77QuxLocalAsync(ctx, req, options...).Get(ctx)
}

// Pv77QuxLocalAsync executes a(n) test.patch.v1.Pv77QuxActivity activity (asynchronously, locally)
func Pv77QuxLocalAsync(ctx workflow.Context, req *Pv77QuxInput, options ...*Pv77QuxLocalActivityOptions) *Pv77QuxFuture {
	var o *Pv77QuxLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77QuxLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &Pv77QuxFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = Pv77QuxActivityName
	}
	future := &Pv77QuxFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// Pv77QuxActivityOptions provides configuration for a(n) test.patch.v1.Pv77QuxActivity activity
type Pv77QuxActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewPv77QuxActivityOptions initializes a new Pv77QuxActivityOptions value
func NewPv77QuxActivityOptions() *Pv77QuxActivityOptions {
	return &Pv77QuxActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77QuxActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = Pv77QuxServiceTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *Pv77QuxActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *Pv77QuxActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *Pv77QuxActivityOptions) WithHeartbeatTimeout(d time.Duration) *Pv77QuxActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77QuxActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77QuxActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77QuxActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77QuxActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *Pv77QuxActivityOptions) WithScheduleToStartTimeout(d time.Duration) *Pv77QuxActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77QuxActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77QuxActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *Pv77QuxActivityOptions) WithTaskQueue(tq string) *Pv77QuxActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *Pv77QuxActivityOptions) WithWaitForCancellation(wait bool) *Pv77QuxActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// Pv77QuxLocalActivityOptions provides configuration for a(n) test.patch.v1.Pv77QuxActivity activity
type Pv77QuxLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *Pv77QuxInput) (*Pv77QuxOutput, error)
}

// NewPv77QuxLocalActivityOptions initializes a new Pv77QuxLocalActivityOptions value
func NewPv77QuxLocalActivityOptions() *Pv77QuxLocalActivityOptions {
	return &Pv77QuxLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *Pv77QuxLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom test.patch.v1.Pv77QuxActivity implementation
func (o *Pv77QuxLocalActivityOptions) Local(fn func(context.Context, *Pv77QuxInput) (*Pv77QuxOutput, error)) *Pv77QuxLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *Pv77QuxLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *Pv77QuxLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *Pv77QuxLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *Pv77QuxLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *Pv77QuxLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *Pv77QuxLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *Pv77QuxLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *Pv77QuxLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestPv77QuxServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows Pv77QuxServiceWorkflows
}

var _ Pv77QuxServiceClient = &TestPv77QuxServiceClient{}

// NewTestPv77QuxServiceClient initializes a new TestPv77QuxServiceClient value
func NewTestPv77QuxServiceClient(env *testsuite.TestWorkflowEnvironment, workflows Pv77QuxServiceWorkflows, activities Pv77QuxServiceActivities) *TestPv77QuxServiceClient {
	if workflows != nil {
		RegisterPv77QuxServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterPv77QuxServiceActivities(env, activities)
	}
	return &TestPv77QuxServiceClient{env, workflows}
}

// Pv77Qux executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow in the test environment
func (c *TestPv77QuxServiceClient) Pv77Qux(ctx context.Context, req *Pv77QuxInput, opts ...*Pv77QuxOptions) (*Pv77QuxOutput, error) {
	run, err := c.Pv77QuxAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77QuxAsync executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow in the test environment
func (c *TestPv77QuxServiceClient) Pv77QuxAsync(ctx context.Context, req *Pv77QuxInput, options ...*Pv77QuxOptions) (Pv77QuxRun, error) {
	var o *Pv77QuxOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewPv77QuxOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testPv77QuxRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetPv77Qux is a noop
func (c *TestPv77QuxServiceClient) GetPv77Qux(ctx context.Context, workflowID string, runID string) Pv77QuxRun {
	return &testPv77QuxRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestPv77QuxServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestPv77QuxServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ Pv77QuxRun = &testPv77QuxRun{}

// testPv77QuxRun provides convenience methods for interacting with a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow in the test environment
type testPv77QuxRun struct {
	client    *TestPv77QuxServiceClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *Pv77QuxInput
	workflows Pv77QuxServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testPv77QuxRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.patch.v1.Pv77QuxService.Pv77Qux workflow result
func (r *testPv77QuxRun) Get(context.Context) (*Pv77QuxOutput, error) {
	r.env.ExecuteWorkflow(Pv77QuxWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result Pv77QuxOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.patch.v1.Pv77QuxService.Pv77Qux workflow run's workflow ID
func (r *testPv77QuxRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testPv77QuxRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testPv77QuxRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testPv77QuxRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Pv77QuxServiceCliOptions describes runtime configuration for test.patch.v1.Pv77QuxService cli
type Pv77QuxServiceCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewPv77QuxServiceCliOptions initializes a new Pv77QuxServiceCliOptions value
func NewPv77QuxServiceCliOptions() *Pv77QuxServiceCliOptions {
	return &Pv77QuxServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *Pv77QuxServiceCliOptions) WithAfter(fn func(*v2.Context) error) *Pv77QuxServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *Pv77QuxServiceCliOptions) WithBefore(fn func(*v2.Context) error) *Pv77QuxServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *Pv77QuxServiceCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *Pv77QuxServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *Pv77QuxServiceCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *Pv77QuxServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewPv77QuxServiceCli initializes a cli for a(n) test.patch.v1.Pv77QuxService service
func NewPv77QuxServiceCli(options ...*Pv77QuxServiceCliOptions) (*v2.App, error) {
	commands, err := newPv77QuxServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "pv-77-qux-service",
		Commands: commands,
	}, nil
}

// NewPv77QuxServiceCliCommand initializes a cli command for a test.patch.v1.Pv77QuxService service with subcommands for each query, signal, update, and workflow
func NewPv77QuxServiceCliCommand(options ...*Pv77QuxServiceCliOptions) (*v2.Command, error) {
	subcommands, err := newPv77QuxServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "pv-77-qux-service",
		Subcommands: subcommands,
	}, nil
}

// newPv77QuxServiceCommands initializes (sub)commands for a test.patch.v1.Pv77QuxService cli or command
func newPv77QuxServiceCommands(options ...*Pv77QuxServiceCliOptions) ([]*v2.Command, error) {
	opts := &Pv77QuxServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "pv-77-qux",
			Usage:                  "executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "pv77-v2",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringSliceFlag{
					Name:     "next",
					Usage:    "set the value of the operation's \"Next\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewPv77QuxServiceClient(tc)
				req, err := UnmarshalCliFlagsToPv77QuxInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.Pv77QuxAsync(cmd.Context, req, NewPv77QuxOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", Pv77QuxWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.patch.v1.Pv77QuxService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToPv77QuxInput unmarshals a Pv77QuxInput from command line flags
func UnmarshalCliFlagsToPv77QuxInput(cmd *v2.Context) (*Pv77QuxInput, error) {
	var result Pv77QuxInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("next") {
		hasValues = true
		var tmp Pv77QuxInput
		if err := protojson.Unmarshal([]byte(fmt.Sprintf("{\"next\":%s}", cmd.String("next"))), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"next\" map flag: %w", err)
		}
		result.Next = tmp.Next
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithPv77QuxServiceSchemeTypes registers all Pv77QuxService protobuf types with the given scheme
func WithPv77QuxServiceSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77QuxInput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77QuxOutput"))
		s.RegisterType(File_test_patch_v1_pv77_proto.Messages().ByName("Pv77QuxOutput").Messages().ByName("DefaultsEntry"))
	}
}
