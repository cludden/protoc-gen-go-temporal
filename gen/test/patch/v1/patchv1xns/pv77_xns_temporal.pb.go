// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.14.4-next (e82835bad5227fc67a146f370ba42ab3f41c10cf)
//	go go1.22.2
//	protoc (unknown)
//
// source: test/patch/v1/pv77.proto
package patchv1xns

import (
	"context"
	"errors"
	"fmt"
	temporalv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/v1"
	xnsv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/xns/v1"
	v1 "github.com/cludden/protoc-gen-go-temporal/gen/test/patch/v1"
	xns "github.com/cludden/protoc-gen-go-temporal/pkg/xns"
	uuid "github.com/google/uuid"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"time"
)

// Pv77FooServiceOptions is used to configure test.patch.v1.Pv77FooService xns activity registration
type Pv77FooServiceOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewPv77FooServiceOptions initializes a new Pv77FooServiceOptions value
func NewPv77FooServiceOptions() *Pv77FooServiceOptions {
	return &Pv77FooServiceOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *Pv77FooServiceOptions) WithErrorConverter(errorConverter func(error) error) *Pv77FooServiceOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *Pv77FooServiceOptions) WithFilter(filter func(string) string) *Pv77FooServiceOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *Pv77FooServiceOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *Pv77FooServiceOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// pv77FooServiceOptions is a reference to the Pv77FooServiceOptions initialized at registration
var pv77FooServiceOptions *Pv77FooServiceOptions

// RegisterPv77FooServiceActivities registers test.patch.v1.Pv77FooService cross-namespace activities
func RegisterPv77FooServiceActivities(r worker.ActivityRegistry, c v1.Pv77FooServiceClient, options ...*Pv77FooServiceOptions) {
	if pv77FooServiceOptions == nil && len(options) > 0 && options[0] != nil {
		pv77FooServiceOptions = options[0]
	}
	a := &pv77FooServiceActivities{c}
	if name := pv77FooServiceOptions.filterActivity("test.patch.v1.Pv77FooService.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := pv77FooServiceOptions.filterActivity(v1.Pv77FooWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.Pv77Foo, activity.RegisterOptions{Name: name})
	}
}

// Pv77FooWorkflowOptions are used to configure a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow execution
type Pv77FooWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewPv77FooWorkflowOptions initializes a new Pv77FooWorkflowOptions value
func NewPv77FooWorkflowOptions() *Pv77FooWorkflowOptions {
	return &Pv77FooWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *Pv77FooWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *Pv77FooWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *Pv77FooWorkflowOptions) WithDetached(d bool) *Pv77FooWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *Pv77FooWorkflowOptions) WithHeartbeatInterval(d time.Duration) *Pv77FooWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *Pv77FooWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77FooWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *Pv77FooWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *Pv77FooWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// Pv77FooRun provides a handle to a test.patch.v1.Pv77FooService.Pv77Foo workflow execution
type Pv77FooRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.Pv77FooOutput, error)

	// ID returns the workflow id
	ID() string
}

// pv77FooRun provides a(n) Pv77FooRun implementation
type pv77FooRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *pv77FooRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelPv77FooServiceWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *pv77FooRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *pv77FooRun) Get(ctx workflow.Context) (*v1.Pv77FooOutput, error) {
	var resp v1.Pv77FooOutput
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *pv77FooRun) ID() string {
	return r.id
}

// Pv77Foo executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow and blocks until error or response is received
func Pv77Foo(ctx workflow.Context, req *v1.Pv77FooInput, opts ...*Pv77FooWorkflowOptions) (*v1.Pv77FooOutput, error) {
	run, err := Pv77FooAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77FooAsync executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow and returns a handle to the underlying activity
func Pv77FooAsync(ctx workflow.Context, req *v1.Pv77FooInput, opts ...*Pv77FooWorkflowOptions) (Pv77FooRun, error) {
	activityName := pv77FooServiceOptions.filterActivity(v1.Pv77FooWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.Pv77FooWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &Pv77FooWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &pv77FooRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// CancelPv77FooServiceWorkflow cancels an existing workflow
func CancelPv77FooServiceWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelPv77FooServiceWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelPv77FooServiceWorkflowAsync cancels an existing workflow
func CancelPv77FooServiceWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := pv77FooServiceOptions.filterActivity("test.patch.v1.Pv77FooService.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for test.patch.v1.Pv77FooService.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// pv77FooServiceActivities provides activities that can be used to interact with a(n) Pv77FooService service's workflow, queries, signals, and updates across namespaces
type pv77FooServiceActivities struct {
	client v1.Pv77FooServiceClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *pv77FooServiceActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// Pv77Foo executes a(n) test.patch.v1.Pv77FooService.Pv77Foo workflow via an activity
func (a *pv77FooServiceActivities) Pv77Foo(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.Pv77FooOutput, err error) {
	// unmarshal workflow request
	var req v1.Pv77FooInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, pv77FooServiceOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/patch/v1.Pv77FooInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.Pv77FooRun
	run, err = a.client.Pv77FooAsync(ctx, &req, v1.NewPv77FooOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, pv77FooServiceOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, pv77FooServiceOptions.convertError(err)
					}
				}
				return nil, pv77FooServiceOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, pv77FooServiceOptions.convertError(err)
		}
	}
}

// Pv77BarServiceOptions is used to configure test.patch.v1.Pv77BarService xns activity registration
type Pv77BarServiceOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewPv77BarServiceOptions initializes a new Pv77BarServiceOptions value
func NewPv77BarServiceOptions() *Pv77BarServiceOptions {
	return &Pv77BarServiceOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *Pv77BarServiceOptions) WithErrorConverter(errorConverter func(error) error) *Pv77BarServiceOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *Pv77BarServiceOptions) WithFilter(filter func(string) string) *Pv77BarServiceOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *Pv77BarServiceOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *Pv77BarServiceOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// pv77BarServiceOptions is a reference to the Pv77BarServiceOptions initialized at registration
var pv77BarServiceOptions *Pv77BarServiceOptions

// RegisterPv77BarServiceActivities registers test.patch.v1.Pv77BarService cross-namespace activities
func RegisterPv77BarServiceActivities(r worker.ActivityRegistry, c v1.Pv77BarServiceClient, options ...*Pv77BarServiceOptions) {
	if pv77BarServiceOptions == nil && len(options) > 0 && options[0] != nil {
		pv77BarServiceOptions = options[0]
	}
	a := &pv77BarServiceActivities{c}
	if name := pv77BarServiceOptions.filterActivity("test.patch.v1.Pv77BarService.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := pv77BarServiceOptions.filterActivity(v1.Pv77BarWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.Pv77Bar, activity.RegisterOptions{Name: name})
	}
}

// Pv77BarWorkflowOptions are used to configure a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow execution
type Pv77BarWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewPv77BarWorkflowOptions initializes a new Pv77BarWorkflowOptions value
func NewPv77BarWorkflowOptions() *Pv77BarWorkflowOptions {
	return &Pv77BarWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *Pv77BarWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *Pv77BarWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *Pv77BarWorkflowOptions) WithDetached(d bool) *Pv77BarWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *Pv77BarWorkflowOptions) WithHeartbeatInterval(d time.Duration) *Pv77BarWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *Pv77BarWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77BarWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *Pv77BarWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *Pv77BarWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// Pv77BarRun provides a handle to a test.patch.v1.Pv77BarService.Pv77Bar workflow execution
type Pv77BarRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.Pv77BarOutput, error)

	// ID returns the workflow id
	ID() string
}

// pv77BarRun provides a(n) Pv77BarRun implementation
type pv77BarRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *pv77BarRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelPv77BarServiceWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *pv77BarRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *pv77BarRun) Get(ctx workflow.Context) (*v1.Pv77BarOutput, error) {
	var resp v1.Pv77BarOutput
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *pv77BarRun) ID() string {
	return r.id
}

// Pv77Bar executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow and blocks until error or response is received
func Pv77Bar(ctx workflow.Context, req *v1.Pv77BarInput, opts ...*Pv77BarWorkflowOptions) (*v1.Pv77BarOutput, error) {
	run, err := Pv77BarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77BarAsync executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow and returns a handle to the underlying activity
func Pv77BarAsync(ctx workflow.Context, req *v1.Pv77BarInput, opts ...*Pv77BarWorkflowOptions) (Pv77BarRun, error) {
	activityName := pv77BarServiceOptions.filterActivity(v1.Pv77BarWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.Pv77BarWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &Pv77BarWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &pv77BarRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// CancelPv77BarServiceWorkflow cancels an existing workflow
func CancelPv77BarServiceWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelPv77BarServiceWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelPv77BarServiceWorkflowAsync cancels an existing workflow
func CancelPv77BarServiceWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := pv77BarServiceOptions.filterActivity("test.patch.v1.Pv77BarService.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for test.patch.v1.Pv77BarService.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// pv77BarServiceActivities provides activities that can be used to interact with a(n) Pv77BarService service's workflow, queries, signals, and updates across namespaces
type pv77BarServiceActivities struct {
	client v1.Pv77BarServiceClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *pv77BarServiceActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// Pv77Bar executes a(n) test.patch.v1.Pv77BarService.Pv77Bar workflow via an activity
func (a *pv77BarServiceActivities) Pv77Bar(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.Pv77BarOutput, err error) {
	// unmarshal workflow request
	var req v1.Pv77BarInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, pv77BarServiceOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/patch/v1.Pv77BarInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.Pv77BarRun
	run, err = a.client.Pv77BarAsync(ctx, &req, v1.NewPv77BarOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, pv77BarServiceOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, pv77BarServiceOptions.convertError(err)
					}
				}
				return nil, pv77BarServiceOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, pv77BarServiceOptions.convertError(err)
		}
	}
}

// Pv77BazServiceOptions is used to configure test.patch.v1.Pv77BazService xns activity registration
type Pv77BazServiceOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewPv77BazServiceOptions initializes a new Pv77BazServiceOptions value
func NewPv77BazServiceOptions() *Pv77BazServiceOptions {
	return &Pv77BazServiceOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *Pv77BazServiceOptions) WithErrorConverter(errorConverter func(error) error) *Pv77BazServiceOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *Pv77BazServiceOptions) WithFilter(filter func(string) string) *Pv77BazServiceOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *Pv77BazServiceOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *Pv77BazServiceOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// pv77BazServiceOptions is a reference to the Pv77BazServiceOptions initialized at registration
var pv77BazServiceOptions *Pv77BazServiceOptions

// RegisterPv77BazServiceActivities registers test.patch.v1.Pv77BazService cross-namespace activities
func RegisterPv77BazServiceActivities(r worker.ActivityRegistry, c v1.Pv77BazServiceClient, options ...*Pv77BazServiceOptions) {
	if pv77BazServiceOptions == nil && len(options) > 0 && options[0] != nil {
		pv77BazServiceOptions = options[0]
	}
	a := &pv77BazServiceActivities{c}
	if name := pv77BazServiceOptions.filterActivity("test.patch.v1.Pv77BazService.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := pv77BazServiceOptions.filterActivity(v1.Pv77BazWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.Pv77Baz, activity.RegisterOptions{Name: name})
	}
}

// Pv77BazWorkflowOptions are used to configure a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow execution
type Pv77BazWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewPv77BazWorkflowOptions initializes a new Pv77BazWorkflowOptions value
func NewPv77BazWorkflowOptions() *Pv77BazWorkflowOptions {
	return &Pv77BazWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *Pv77BazWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *Pv77BazWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *Pv77BazWorkflowOptions) WithDetached(d bool) *Pv77BazWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *Pv77BazWorkflowOptions) WithHeartbeatInterval(d time.Duration) *Pv77BazWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *Pv77BazWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77BazWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *Pv77BazWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *Pv77BazWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// Pv77BazRun provides a handle to a test.patch.v1.Pv77BazService.Pv77Baz workflow execution
type Pv77BazRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.Pv77BazOutput, error)

	// ID returns the workflow id
	ID() string
}

// pv77BazRun provides a(n) Pv77BazRun implementation
type pv77BazRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *pv77BazRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelPv77BazServiceWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *pv77BazRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *pv77BazRun) Get(ctx workflow.Context) (*v1.Pv77BazOutput, error) {
	var resp v1.Pv77BazOutput
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *pv77BazRun) ID() string {
	return r.id
}

// Pv77Baz executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow and blocks until error or response is received
func Pv77Baz(ctx workflow.Context, req *v1.Pv77BazInput, opts ...*Pv77BazWorkflowOptions) (*v1.Pv77BazOutput, error) {
	run, err := Pv77BazAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77BazAsync executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow and returns a handle to the underlying activity
func Pv77BazAsync(ctx workflow.Context, req *v1.Pv77BazInput, opts ...*Pv77BazWorkflowOptions) (Pv77BazRun, error) {
	activityName := pv77BazServiceOptions.filterActivity(v1.Pv77BazWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.Pv77BazWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &Pv77BazWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &pv77BazRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// CancelPv77BazServiceWorkflow cancels an existing workflow
func CancelPv77BazServiceWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelPv77BazServiceWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelPv77BazServiceWorkflowAsync cancels an existing workflow
func CancelPv77BazServiceWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := pv77BazServiceOptions.filterActivity("test.patch.v1.Pv77BazService.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for test.patch.v1.Pv77BazService.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// pv77BazServiceActivities provides activities that can be used to interact with a(n) Pv77BazService service's workflow, queries, signals, and updates across namespaces
type pv77BazServiceActivities struct {
	client v1.Pv77BazServiceClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *pv77BazServiceActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// Pv77Baz executes a(n) test.patch.v1.Pv77BazService.Pv77Baz workflow via an activity
func (a *pv77BazServiceActivities) Pv77Baz(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.Pv77BazOutput, err error) {
	// unmarshal workflow request
	var req v1.Pv77BazInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, pv77BazServiceOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/patch/v1.Pv77BazInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.Pv77BazRun
	run, err = a.client.Pv77BazAsync(ctx, &req, v1.NewPv77BazOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, pv77BazServiceOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, pv77BazServiceOptions.convertError(err)
					}
				}
				return nil, pv77BazServiceOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, pv77BazServiceOptions.convertError(err)
		}
	}
}

// Pv77QuxServiceOptions is used to configure test.patch.v1.Pv77QuxService xns activity registration
type Pv77QuxServiceOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewPv77QuxServiceOptions initializes a new Pv77QuxServiceOptions value
func NewPv77QuxServiceOptions() *Pv77QuxServiceOptions {
	return &Pv77QuxServiceOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *Pv77QuxServiceOptions) WithErrorConverter(errorConverter func(error) error) *Pv77QuxServiceOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *Pv77QuxServiceOptions) WithFilter(filter func(string) string) *Pv77QuxServiceOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *Pv77QuxServiceOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *Pv77QuxServiceOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// pv77QuxServiceOptions is a reference to the Pv77QuxServiceOptions initialized at registration
var pv77QuxServiceOptions *Pv77QuxServiceOptions

// RegisterPv77QuxServiceActivities registers test.patch.v1.Pv77QuxService cross-namespace activities
func RegisterPv77QuxServiceActivities(r worker.ActivityRegistry, c v1.Pv77QuxServiceClient, options ...*Pv77QuxServiceOptions) {
	if pv77QuxServiceOptions == nil && len(options) > 0 && options[0] != nil {
		pv77QuxServiceOptions = options[0]
	}
	a := &pv77QuxServiceActivities{c}
	if name := pv77QuxServiceOptions.filterActivity("test.patch.v1.Pv77QuxService.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := pv77QuxServiceOptions.filterActivity(v1.Pv77QuxWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.Pv77Qux, activity.RegisterOptions{Name: name})
	}
}

// Pv77QuxWorkflowOptions are used to configure a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow execution
type Pv77QuxWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewPv77QuxWorkflowOptions initializes a new Pv77QuxWorkflowOptions value
func NewPv77QuxWorkflowOptions() *Pv77QuxWorkflowOptions {
	return &Pv77QuxWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *Pv77QuxWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *Pv77QuxWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *Pv77QuxWorkflowOptions) WithDetached(d bool) *Pv77QuxWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *Pv77QuxWorkflowOptions) WithHeartbeatInterval(d time.Duration) *Pv77QuxWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *Pv77QuxWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *Pv77QuxWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *Pv77QuxWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *Pv77QuxWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// Pv77QuxRun provides a handle to a test.patch.v1.Pv77QuxService.Pv77Qux workflow execution
type Pv77QuxRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) (*v1.Pv77QuxOutput, error)

	// ID returns the workflow id
	ID() string
}

// pv77QuxRun provides a(n) Pv77QuxRun implementation
type pv77QuxRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *pv77QuxRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if _, err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelPv77QuxServiceWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *pv77QuxRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *pv77QuxRun) Get(ctx workflow.Context) (*v1.Pv77QuxOutput, error) {
	var resp v1.Pv77QuxOutput
	if err := r.future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ID returns the underlying workflow id
func (r *pv77QuxRun) ID() string {
	return r.id
}

// Pv77Qux executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow and blocks until error or response is received
func Pv77Qux(ctx workflow.Context, req *v1.Pv77QuxInput, opts ...*Pv77QuxWorkflowOptions) (*v1.Pv77QuxOutput, error) {
	run, err := Pv77QuxAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// Pv77QuxAsync executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow and returns a handle to the underlying activity
func Pv77QuxAsync(ctx workflow.Context, req *v1.Pv77QuxInput, opts ...*Pv77QuxWorkflowOptions) (Pv77QuxRun, error) {
	activityName := pv77QuxServiceOptions.filterActivity(v1.Pv77QuxWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.Pv77QuxWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &Pv77QuxWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &pv77QuxRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// CancelPv77QuxServiceWorkflow cancels an existing workflow
func CancelPv77QuxServiceWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelPv77QuxServiceWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelPv77QuxServiceWorkflowAsync cancels an existing workflow
func CancelPv77QuxServiceWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := pv77QuxServiceOptions.filterActivity("test.patch.v1.Pv77QuxService.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for test.patch.v1.Pv77QuxService.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// pv77QuxServiceActivities provides activities that can be used to interact with a(n) Pv77QuxService service's workflow, queries, signals, and updates across namespaces
type pv77QuxServiceActivities struct {
	client v1.Pv77QuxServiceClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *pv77QuxServiceActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// Pv77Qux executes a(n) test.patch.v1.Pv77QuxService.Pv77Qux workflow via an activity
func (a *pv77QuxServiceActivities) Pv77Qux(ctx context.Context, input *xnsv1.WorkflowRequest) (resp *v1.Pv77QuxOutput, err error) {
	// unmarshal workflow request
	var req v1.Pv77QuxInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return nil, pv77QuxServiceOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/test/patch/v1.Pv77QuxInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.Pv77QuxRun
	run, err = a.client.Pv77QuxAsync(ctx, &req, v1.NewPv77QuxOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return nil, pv77QuxServiceOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil, nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		resp, err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return nil, temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return nil, pv77QuxServiceOptions.convertError(err)
					}
				}
				return nil, pv77QuxServiceOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return resp, pv77QuxServiceOptions.convertError(err)
		}
	}
}
