// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/issue-135/v1/issue-135.proto
package issue_135v1

import (
	"context"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	activity "go.temporal.io/sdk/activity"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	"time"
)

// test.issue_135.v1.FOOBar activity names
const (
	DoActivityName = "DoName"
)

// FOOBarActivities describes available worker activities
type FOOBarActivities interface {
	// CheckStatus checks if the SSH connection to a host is reachable.
	Do(ctx context.Context, req *DoRequest) (*DoResponse, error)
}

// RegisterFOOBarActivities registers activities with a worker
func RegisterFOOBarActivities(r worker.ActivityRegistry, activities FOOBarActivities) {
	RegisterDoActivity(r, activities.Do)
}

// RegisterDoActivity registers a DoName activity
func RegisterDoActivity(r worker.ActivityRegistry, fn func(context.Context, *DoRequest) (*DoResponse, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: DoActivityName,
	})
}

// DoFuture describes a(n) DoName activity execution
type DoFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *DoFuture) Get(ctx workflow.Context) (*DoResponse, error) {
	var resp DoResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *DoFuture) Select(sel workflow.Selector, fn func(*DoFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// CheckStatus checks if the SSH connection to a host is reachable.
func Do(ctx workflow.Context, req *DoRequest, options ...*DoActivityOptions) (*DoResponse, error) {
	return DoAsync(ctx, req, options...).Get(ctx)
}

// CheckStatus checks if the SSH connection to a host is reachable.
func DoAsync(ctx workflow.Context, req *DoRequest, options ...*DoActivityOptions) *DoFuture {
	var o *DoActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewDoActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &DoFuture{Future: errF}
	}
	activity := DoActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &DoFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// CheckStatus checks if the SSH connection to a host is reachable.
func DoLocal(ctx workflow.Context, req *DoRequest, options ...*DoLocalActivityOptions) (*DoResponse, error) {
	return DoLocalAsync(ctx, req, options...).Get(ctx)
}

// CheckStatus checks if the SSH connection to a host is reachable.
func DoLocalAsync(ctx workflow.Context, req *DoRequest, options ...*DoLocalActivityOptions) *DoFuture {
	var o *DoLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewDoLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &DoFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = DoActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &DoFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// DoActivityOptions provides configuration for a(n) DoName activity
type DoActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewDoActivityOptions initializes a new DoActivityOptions value
func NewDoActivityOptions() *DoActivityOptions {
	return &DoActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *DoActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *DoActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *DoActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *DoActivityOptions) WithDataConverter(dc converter.DataConverter) *DoActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *DoActivityOptions) WithHeartbeatTimeout(d time.Duration) *DoActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *DoActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *DoActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *DoActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *DoActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *DoActivityOptions) WithScheduleToStartTimeout(d time.Duration) *DoActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *DoActivityOptions) WithStartToCloseTimeout(d time.Duration) *DoActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *DoActivityOptions) WithTaskQueue(tq string) *DoActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *DoActivityOptions) WithWaitForCancellation(wait bool) *DoActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// DoLocalActivityOptions provides configuration for a(n) DoName activity
type DoLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *DoRequest) (*DoResponse, error)
}

// NewDoLocalActivityOptions initializes a new DoLocalActivityOptions value
func NewDoLocalActivityOptions() *DoLocalActivityOptions {
	return &DoLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *DoLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom DoName implementation
func (o *DoLocalActivityOptions) Local(fn func(context.Context, *DoRequest) (*DoResponse, error)) *DoLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *DoLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *DoLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *DoLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *DoLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *DoLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *DoLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *DoLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *DoLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *DoLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *DoLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithFOOBarSchemeTypes registers all FOOBar protobuf types with the given scheme
func WithFOOBarSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_issue_135_v1_issue_135_proto.Messages().ByName("DoRequest"))
		s.RegisterType(File_test_issue_135_v1_issue_135_proto.Messages().ByName("DoResponse"))
	}
}
