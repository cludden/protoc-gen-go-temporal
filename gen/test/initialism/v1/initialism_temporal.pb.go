// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 0.0.1-next (3e592fe37f9be40f2baedec2fa2b953fb16fb907)
//	go go1.24.0
//	protoc (unknown)
//
// source: test/initialism/v1/initialism.proto
package v1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"time"
)

// AwstaskQueue is the default task-queue for a mycompany.initialism.AWS worker
const AwstaskQueue = "aws-task-queue"

// mycompany.initialism.AWS workflow names
const (
	ManageAwsworkflowName         = "mycompany.initialism.AWS.ManageAWS"
	ManageAwsresourceWorkflowName = "mycompany.initialism.AWS.ManageAWSResource"
)

// mycompany.initialism.AWS workflow id expressions
var (
	ManageAwsidexpression         = expression.MustParseExpression("some-workflow-1/${! id }/${! uuid_v4() }")
	ManageAwsresourceIdexpression = expression.MustParseExpression("some-workflow-2/${! uuid_v4() }")
)

// Awsclient describes a client for a(n) mycompany.initialism.AWS worker
type Awsclient interface {
	// ManageAWS does some workflow thing.
	ManageAws(ctx context.Context, req *ManageAWSRequest, opts ...*ManageAwsoptions) (*ManageAWSResponse, error)

	// ManageAwsasync starts a(n) mycompany.initialism.AWS.ManageAWS workflow and returns a handle to the workflow run
	ManageAwsasync(ctx context.Context, req *ManageAWSRequest, opts ...*ManageAwsoptions) (ManageAwsrun, error)

	// GetManageAws retrieves a handle to an existing mycompany.initialism.AWS.ManageAWS workflow execution
	GetManageAws(ctx context.Context, workflowID string, runID string) ManageAwsrun

	// ManageAWSResource does some workflow thing.
	ManageAwsresource(ctx context.Context, req *ManageAWSResourceRequest, opts ...*ManageAwsresourceOptions) (*ManageAWSResourceResponse, error)

	// ManageAwsresourceAsync starts a(n) mycompany.initialism.AWS.ManageAWSResource workflow and returns a handle to the workflow run
	ManageAwsresourceAsync(ctx context.Context, req *ManageAWSResourceRequest, opts ...*ManageAwsresourceOptions) (ManageAwsresourceRun, error)

	// GetManageAwsresource retrieves a handle to an existing mycompany.initialism.AWS.ManageAWSResource workflow execution
	GetManageAwsresource(ctx context.Context, workflowID string, runID string) ManageAwsresourceRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// awsclient implements a temporal client for a mycompany.initialism.AWS service
type awsclient struct {
	client client.Client
	log    *slog.Logger
}

// NewAwsclient initializes a new mycompany.initialism.AWS client
func NewAwsclient(c client.Client, options ...*awsclientOptions) Awsclient {
	var cfg *awsclientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewAwsclientOptions()
	}
	return &awsclient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewAwsclientWithOptions initializes a new AWS client with the given options
func NewAwsclientWithOptions(c client.Client, opts client.Options, options ...*awsclientOptions) (Awsclient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *awsclientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewAwsclientOptions()
	}
	return &awsclient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// awsclientOptions describes optional runtime configuration for a Awsclient
type awsclientOptions struct {
	log *slog.Logger
}

// NewAwsclientOptions initializes a new awsclientOptions value
func NewAwsclientOptions() *awsclientOptions {
	return &awsclientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *awsclientOptions) WithLogger(l *slog.Logger) *awsclientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *awsclientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// ManageAWS does some workflow thing.
func (c *awsclient) ManageAWS(ctx context.Context, req *ManageAWSRequest, options ...*ManageAwsoptions) (*ManageAWSResponse, error) {
	run, err := c.ManageAwsasync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWS does some workflow thing.
func (c *awsclient) ManageAwsasync(ctx context.Context, req *ManageAWSRequest, options ...*ManageAwsoptions) (ManageAwsrun, error) {
	var o *ManageAwsoptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAwsoptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ManageAwsworkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &manageAwsrun{
		client: c,
		run:    run,
	}, nil
}

// GetManageAws fetches an existing mycompany.initialism.AWS.ManageAWS execution
func (c *awsclient) GetManageAws(ctx context.Context, workflowID string, runID string) ManageAwsrun {
	return &manageAwsrun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// ManageAWSResource does some workflow thing.
func (c *awsclient) ManageAWSResource(ctx context.Context, req *ManageAWSResourceRequest, options ...*ManageAwsresourceOptions) (*ManageAWSResourceResponse, error) {
	run, err := c.ManageAwsresourceAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSResource does some workflow thing.
func (c *awsclient) ManageAwsresourceAsync(ctx context.Context, req *ManageAWSResourceRequest, options ...*ManageAwsresourceOptions) (ManageAwsresourceRun, error) {
	var o *ManageAwsresourceOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAwsresourceOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ManageAwsresourceWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &manageAwsresourceRun{
		client: c,
		run:    run,
	}, nil
}

// GetManageAwsresource fetches an existing mycompany.initialism.AWS.ManageAWSResource execution
func (c *awsclient) GetManageAwsresource(ctx context.Context, workflowID string, runID string) ManageAwsresourceRun {
	return &manageAwsresourceRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *awsclient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *awsclient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// ManageAwsoptions provides configuration for a mycompany.initialism.AWS.ManageAWS workflow operation
type ManageAwsoptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewManageAwsoptions initializes a new ManageAwsoptions value
func NewManageAwsoptions() *ManageAwsoptions {
	return &ManageAwsoptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ManageAwsoptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ManageAwsidexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsworkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AwstaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ManageAwsoptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ManageAwsoptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAwsoptions) WithExecutionTimeout(d time.Duration) *ManageAwsoptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ManageAwsoptions) WithID(id string) *ManageAwsoptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAwsoptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAwsoptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAwsoptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAwsoptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAwsoptions) WithRunTimeout(d time.Duration) *ManageAwsoptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAwsoptions) WithSearchAttributes(sa map[string]any) *ManageAwsoptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAwsoptions) WithTaskTimeout(d time.Duration) *ManageAwsoptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAwsoptions) WithTaskQueue(tq string) *ManageAwsoptions {
	o.taskQueue = &tq
	return o
}

// ManageAwsrun describes a(n) mycompany.initialism.AWS.ManageAWS workflow run
type ManageAwsrun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ManageAWSResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// manageAwsrun provides an internal implementation of a(n) ManageAwsrunRun
type manageAwsrun struct {
	client *awsclient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *manageAwsrun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *manageAwsrun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *manageAwsrun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *manageAwsrun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *manageAwsrun) Get(ctx context.Context) (*ManageAWSResponse, error) {
	var resp ManageAWSResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *manageAwsrun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// ManageAwsresourceOptions provides configuration for a mycompany.initialism.AWS.ManageAWSResource workflow operation
type ManageAwsresourceOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewManageAwsresourceOptions initializes a new ManageAwsresourceOptions value
func NewManageAwsresourceOptions() *ManageAwsresourceOptions {
	return &ManageAwsresourceOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ManageAwsresourceOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ManageAwsresourceIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsresourceWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AwstaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ManageAwsresourceOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ManageAwsresourceOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAwsresourceOptions) WithExecutionTimeout(d time.Duration) *ManageAwsresourceOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ManageAwsresourceOptions) WithID(id string) *ManageAwsresourceOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAwsresourceOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAwsresourceOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAwsresourceOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAwsresourceOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAwsresourceOptions) WithRunTimeout(d time.Duration) *ManageAwsresourceOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAwsresourceOptions) WithSearchAttributes(sa map[string]any) *ManageAwsresourceOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAwsresourceOptions) WithTaskTimeout(d time.Duration) *ManageAwsresourceOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAwsresourceOptions) WithTaskQueue(tq string) *ManageAwsresourceOptions {
	o.taskQueue = &tq
	return o
}

// ManageAwsresourceRun describes a(n) mycompany.initialism.AWS.ManageAWSResource workflow run
type ManageAwsresourceRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ManageAWSResourceResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// manageAwsresourceRun provides an internal implementation of a(n) ManageAwsresourceRunRun
type manageAwsresourceRun struct {
	client *awsclient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *manageAwsresourceRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *manageAwsresourceRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *manageAwsresourceRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *manageAwsresourceRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *manageAwsresourceRun) Get(ctx context.Context) (*ManageAWSResourceResponse, error) {
	var resp ManageAWSResourceResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *manageAwsresourceRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// ManageAWS does some workflow thing.
	ManageAwsfunction func(workflow.Context, *ManageAWSRequest) (*ManageAWSResponse, error)
	// ManageAWSResource does some workflow thing.
	ManageAwsresourceFunction func(workflow.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)
)

// AwsworkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// AwsworkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	AwsworkflowFunctions interface {
		// ManageAWS does some workflow thing.
		ManageAws(workflow.Context, *ManageAWSRequest) (*ManageAWSResponse, error)
		// ManageAWSResource does some workflow thing.
		ManageAwsresource(workflow.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error)
	}
	// awsworkflowFunctions provides an internal AwsworkflowFunctions implementation
	awsworkflowFunctions struct{}
)

func NewAwsworkflowFunctions() AwsworkflowFunctions {
	return &awsworkflowFunctions{}
}

// ManageAWS does some workflow thing.
func (f *awsworkflowFunctions) ManageAws(ctx workflow.Context, req *ManageAWSRequest) (*ManageAWSResponse, error) {
	if ManageAwsfunction == nil {
		return nil, errors.New("ManageAws requires workflow registration via RegisterAwsworkflows or RegisterManageAwsworkflow")
	}
	return ManageAwsfunction(ctx, req)
}

// ManageAWSResource does some workflow thing.
func (f *awsworkflowFunctions) ManageAwsresource(ctx workflow.Context, req *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error) {
	if ManageAwsresourceFunction == nil {
		return nil, errors.New("ManageAwsresource requires workflow registration via RegisterAwsworkflows or RegisterManageAwsresourceWorkflow")
	}
	return ManageAwsresourceFunction(ctx, req)
}

// Awsworkflows provides methods for initializing new mycompany.initialism.AWS workflow values
type Awsworkflows interface {
	// ManageAWS does some workflow thing.
	ManageAWS(ctx workflow.Context, input *ManageAwsworkflowInput) (ManageAwsworkflow, error)

	// ManageAWSResource does some workflow thing.
	ManageAWSResource(ctx workflow.Context, input *ManageAwsresourceWorkflowInput) (ManageAwsresourceWorkflow, error)
}

// RegisterAWSWorkflows registers mycompany.initialism.AWS workflows with the given worker
func RegisterAwsworkflows(r worker.WorkflowRegistry, workflows Awsworkflows) {
	RegisterManageAwsworkflow(r, workflows.ManageAWS)
	RegisterManageAwsresourceWorkflow(r, workflows.ManageAWSResource)
}

// RegisterManageAWSWorkflow registers a mycompany.initialism.AWS.ManageAWS workflow with the given worker
func RegisterManageAwsworkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ManageAwsworkflowInput) (ManageAwsworkflow, error)) {
	ManageAwsfunction = buildManageAWS(wf)
	r.RegisterWorkflowWithOptions(ManageAwsfunction, workflow.RegisterOptions{Name: ManageAwsworkflowName})
}

// buildManageAWS converts a ManageAWS workflow struct into a valid workflow function
func buildManageAWS(ctor func(workflow.Context, *ManageAwsworkflowInput) (ManageAwsworkflow, error)) func(workflow.Context, *ManageAWSRequest) (*ManageAWSResponse, error) {
	return func(ctx workflow.Context, req *ManageAWSRequest) (*ManageAWSResponse, error) {
		input := &ManageAwsworkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ManageAwsworkflowInput describes the input to a(n) mycompany.initialism.AWS.ManageAWS workflow constructor
type ManageAwsworkflowInput struct {
	Req *ManageAWSRequest
}

// ManageAWS does some workflow thing.
//
// workflow details: (name: "mycompany.initialism.AWS.ManageAWS", id: "some-workflow-1/${! id }/${! uuid_v4() }")
type ManageAwsworkflow interface {
	// Execute defines the entrypoint to a(n) mycompany.initialism.AWS.ManageAWS workflow
	Execute(ctx workflow.Context) (*ManageAWSResponse, error)
}

// ManageAWS does some workflow thing.
func ManageAwschild(ctx workflow.Context, req *ManageAWSRequest, options ...*ManageAwschildOptions) (*ManageAWSResponse, error) {
	childRun, err := ManageAwschildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ManageAWS does some workflow thing.
func ManageAwschildAsync(ctx workflow.Context, req *ManageAWSRequest, options ...*ManageAwschildOptions) (*ManageAwschildRun, error) {
	var o *ManageAwschildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAwschildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &ManageAwschildRun{Future: workflow.ExecuteChildWorkflow(ctx, ManageAwsworkflowName, req)}, nil
}

// ManageAwschildOptions provides configuration for a child mycompany.initialism.AWS.ManageAWS workflow operation
type ManageAwschildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewManageAwschildOptions initializes a new ManageAwschildOptions value
func NewManageAwschildOptions() *ManageAwschildOptions {
	return &ManageAwschildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ManageAwschildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ManageAwsidexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsworkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsworkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ManageAwsidexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsworkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AwstaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ManageAwschildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ManageAwschildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAwschildOptions) WithExecutionTimeout(d time.Duration) *ManageAwschildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ManageAwschildOptions) WithID(id string) *ManageAwschildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAwschildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAwschildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAwschildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ManageAwschildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAwschildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAwschildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAwschildOptions) WithRunTimeout(d time.Duration) *ManageAwschildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAwschildOptions) WithSearchAttributes(sa map[string]any) *ManageAwschildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAwschildOptions) WithTaskTimeout(d time.Duration) *ManageAwschildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAwschildOptions) WithTaskQueue(tq string) *ManageAwschildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ManageAwschildOptions) WithWaitForCancellation(wait bool) *ManageAwschildOptions {
	o.waitForCancellation = &wait
	return o
}

// ManageAwschildRun describes a child ManageAWS workflow run
type ManageAwschildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ManageAwschildRun) Get(ctx workflow.Context) (*ManageAWSResponse, error) {
	var resp ManageAWSResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ManageAwschildRun) Select(sel workflow.Selector, fn func(*ManageAwschildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ManageAwschildRun) SelectStart(sel workflow.Selector, fn func(*ManageAwschildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ManageAwschildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterManageAWSResourceWorkflow registers a mycompany.initialism.AWS.ManageAWSResource workflow with the given worker
func RegisterManageAwsresourceWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ManageAwsresourceWorkflowInput) (ManageAwsresourceWorkflow, error)) {
	ManageAwsresourceFunction = buildManageAWSResource(wf)
	r.RegisterWorkflowWithOptions(ManageAwsresourceFunction, workflow.RegisterOptions{Name: ManageAwsresourceWorkflowName})
}

// buildManageAWSResource converts a ManageAWSResource workflow struct into a valid workflow function
func buildManageAWSResource(ctor func(workflow.Context, *ManageAwsresourceWorkflowInput) (ManageAwsresourceWorkflow, error)) func(workflow.Context, *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error) {
	return func(ctx workflow.Context, req *ManageAWSResourceRequest) (*ManageAWSResourceResponse, error) {
		input := &ManageAwsresourceWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ManageAwsresourceWorkflowInput describes the input to a(n) mycompany.initialism.AWS.ManageAWSResource workflow constructor
type ManageAwsresourceWorkflowInput struct {
	Req *ManageAWSResourceRequest
}

// ManageAWSResource does some workflow thing.
//
// workflow details: (name: "mycompany.initialism.AWS.ManageAWSResource", id: "some-workflow-2/${! uuid_v4() }")
type ManageAwsresourceWorkflow interface {
	// Execute defines the entrypoint to a(n) mycompany.initialism.AWS.ManageAWSResource workflow
	Execute(ctx workflow.Context) (*ManageAWSResourceResponse, error)
}

// ManageAWSResource does some workflow thing.
func ManageAwsresourceChild(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAwsresourceChildOptions) (*ManageAWSResourceResponse, error) {
	childRun, err := ManageAwsresourceChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ManageAWSResource does some workflow thing.
func ManageAwsresourceChildAsync(ctx workflow.Context, req *ManageAWSResourceRequest, options ...*ManageAwsresourceChildOptions) (*ManageAwsresourceChildRun, error) {
	var o *ManageAwsresourceChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAwsresourceChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &ManageAwsresourceChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ManageAwsresourceWorkflowName, req)}, nil
}

// ManageAwsresourceChildOptions provides configuration for a child mycompany.initialism.AWS.ManageAWSResource workflow operation
type ManageAwsresourceChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewManageAwsresourceChildOptions initializes a new ManageAwsresourceChildOptions value
func NewManageAwsresourceChildOptions() *ManageAwsresourceChildOptions {
	return &ManageAwsresourceChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ManageAwsresourceChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ManageAwsresourceIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsresourceWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsresourceWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ManageAwsresourceIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ManageAwsresourceWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = AwstaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ManageAwsresourceChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ManageAwsresourceChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ManageAwsresourceChildOptions) WithExecutionTimeout(d time.Duration) *ManageAwsresourceChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ManageAwsresourceChildOptions) WithID(id string) *ManageAwsresourceChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAwsresourceChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ManageAwsresourceChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ManageAwsresourceChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ManageAwsresourceChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ManageAwsresourceChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ManageAwsresourceChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ManageAwsresourceChildOptions) WithRunTimeout(d time.Duration) *ManageAwsresourceChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ManageAwsresourceChildOptions) WithSearchAttributes(sa map[string]any) *ManageAwsresourceChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ManageAwsresourceChildOptions) WithTaskTimeout(d time.Duration) *ManageAwsresourceChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ManageAwsresourceChildOptions) WithTaskQueue(tq string) *ManageAwsresourceChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ManageAwsresourceChildOptions) WithWaitForCancellation(wait bool) *ManageAwsresourceChildOptions {
	o.waitForCancellation = &wait
	return o
}

// ManageAwsresourceChildRun describes a child ManageAWSResource workflow run
type ManageAwsresourceChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ManageAwsresourceChildRun) Get(ctx workflow.Context) (*ManageAWSResourceResponse, error) {
	var resp ManageAWSResourceResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ManageAwsresourceChildRun) Select(sel workflow.Selector, fn func(*ManageAwsresourceChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ManageAwsresourceChildRun) SelectStart(sel workflow.Selector, fn func(*ManageAwsresourceChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ManageAwsresourceChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// AWSActivities describes available worker activities
type AWSActivities interface{}

// RegisterAWSActivities registers activities with a worker
func RegisterAWSActivities(r worker.ActivityRegistry, activities Awsactivities) {}

// TestClient provides a testsuite-compatible Client
type TestAwsclient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows Awsworkflows
}

var _ Awsclient = &TestAwsclient{}

// NewTestAwsclient initializes a new TestAwsclient value
func NewTestAwsclient(env *testsuite.TestWorkflowEnvironment, workflows Awsworkflows, activities Awsactivities) *TestAwsclient {
	if workflows != nil {
		RegisterAwsworkflows(env, workflows)
	}
	if activities != nil {
		RegisterAwsactivities(env, activities)
	}
	return &TestAwsclient{env, workflows}
}

// ManageAWS executes a(n) mycompany.initialism.AWS.ManageAWS workflow in the test environment
func (c *TestAwsclient) ManageAWS(ctx context.Context, req *ManageAWSRequest, opts ...*ManageAwsoptions) (*ManageAWSResponse, error) {
	run, err := c.ManageAwsasync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSAsync executes a(n) mycompany.initialism.AWS.ManageAWS workflow in the test environment
func (c *TestAwsclient) ManageAwsasync(ctx context.Context, req *ManageAWSRequest, options ...*ManageAwsoptions) (ManageAwsrun, error) {
	var o *ManageAwsoptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAwsoptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testManageAwsrun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetManageAws is a noop
func (c *TestAwsclient) GetManageAws(ctx context.Context, workflowID string, runID string) ManageAwsrun {
	return &testManageAwsrun{env: c.env, workflows: c.workflows}
}

// ManageAWSResource executes a(n) mycompany.initialism.AWS.ManageAWSResource workflow in the test environment
func (c *TestAwsclient) ManageAWSResource(ctx context.Context, req *ManageAWSResourceRequest, opts ...*ManageAwsresourceOptions) (*ManageAWSResourceResponse, error) {
	run, err := c.ManageAwsresourceAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ManageAWSResourceAsync executes a(n) mycompany.initialism.AWS.ManageAWSResource workflow in the test environment
func (c *TestAwsclient) ManageAwsresourceAsync(ctx context.Context, req *ManageAWSResourceRequest, options ...*ManageAwsresourceOptions) (ManageAwsresourceRun, error) {
	var o *ManageAwsresourceOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewManageAwsresourceOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testManageAwsresourceRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetManageAwsresource is a noop
func (c *TestAwsclient) GetManageAwsresource(ctx context.Context, workflowID string, runID string) ManageAwsresourceRun {
	return &testManageAwsresourceRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestAwsclient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestAwsclient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ ManageAwsrun = &testManageAwsrun{}

// testManageAwsrun provides convenience methods for interacting with a(n) mycompany.initialism.AWS.ManageAWS workflow in the test environment
type testManageAwsrun struct {
	client    *TestAwsclient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *ManageAWSRequest
	workflows Awsworkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testManageAwsrun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.initialism.AWS.ManageAWS workflow result
func (r *testManageAwsrun) Get(context.Context) (*ManageAWSResponse, error) {
	r.env.ExecuteWorkflow(ManageAwsworkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ManageAWSResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.initialism.AWS.ManageAWS workflow run's workflow ID
func (r *testManageAwsrun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testManageAwsrun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testManageAwsrun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testManageAwsrun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ ManageAwsresourceRun = &testManageAwsresourceRun{}

// testManageAwsresourceRun provides convenience methods for interacting with a(n) mycompany.initialism.AWS.ManageAWSResource workflow in the test environment
type testManageAwsresourceRun struct {
	client    *TestAwsclient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *ManageAWSResourceRequest
	workflows Awsworkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testManageAwsresourceRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test mycompany.initialism.AWS.ManageAWSResource workflow result
func (r *testManageAwsresourceRun) Get(context.Context) (*ManageAWSResourceResponse, error) {
	r.env.ExecuteWorkflow(ManageAwsresourceWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ManageAWSResourceResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test mycompany.initialism.AWS.ManageAWSResource workflow run's workflow ID
func (r *testManageAwsresourceRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testManageAwsresourceRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testManageAwsresourceRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testManageAwsresourceRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// AwscliOptions describes runtime configuration for mycompany.initialism.AWS cli
type AwscliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewAwscliOptions initializes a new AwscliOptions value
func NewAwscliOptions() *AwscliOptions {
	return &AwscliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *AwscliOptions) WithAfter(fn func(*v2.Context) error) *AwscliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *AwscliOptions) WithBefore(fn func(*v2.Context) error) *AwscliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *AwscliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *AwscliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *AwscliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *AwscliOptions {
	opts.worker = fn
	return opts
}

// NewAwscli initializes a cli for a(n) mycompany.initialism.AWS service
func NewAwscli(options ...*AwscliOptions) (*v2.App, error) {
	commands, err := newAwscommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "aws",
		Commands: commands,
	}, nil
}

// NewAwscliCommand initializes a cli command for a mycompany.initialism.AWS service with subcommands for each query, signal, update, and workflow
func NewAwscliCommand(options ...*AwscliOptions) (*v2.Command, error) {
	subcommands, err := newAwscommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "aws",
		Subcommands: subcommands,
	}, nil
}

// newAwscommands initializes (sub)commands for a mycompany.initialism.AWS cli or command
func newAwscommands(options ...*AwscliOptions) ([]*v2.Command, error) {
	opts := &AwscliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "manage-aws",
			Usage:                  "ManageAWS does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "aws-task-queue",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "urn",
					Usage:    "set the value of the operation's \"Urn\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewAwsclient(tc)
				req, err := UnmarshalCliFlagsToManageAwsrequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ManageAwsasync(cmd.Context, req, NewManageAwsoptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ManageAwsworkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "manage-aws-resource",
			Usage:                  "ManageAWSResource does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "aws-task-queue",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "urn",
					Usage:    "set the value of the operation's \"Urn\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewAwsclient(tc)
				req, err := UnmarshalCliFlagsToManageAwsresourceRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ManageAwsresourceAsync(cmd.Context, req, NewManageAwsresourceOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ManageAwsresourceWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.initialism.AWS worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToManageAwsrequest unmarshals a ManageAWSRequest from command line flags
func UnmarshalCliFlagsToManageAwsrequest(cmd *v2.Context) (*ManageAWSRequest, error) {
	var result ManageAWSRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("urn") {
		hasValues = true
		result.Urn = cmd.String("urn")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToManageAwsresourceRequest unmarshals a ManageAWSResourceRequest from command line flags
func UnmarshalCliFlagsToManageAwsresourceRequest(cmd *v2.Context) (*ManageAWSResourceRequest, error) {
	var result ManageAWSResourceRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("urn") {
		hasValues = true
		result.Urn = cmd.String("urn")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithAwsschemeTypes registers all AWS protobuf types with the given scheme
func WithAwsschemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_initialism_v1_initialism_proto.Messages().ByName("ManageAWSRequest"))
		s.RegisterType(File_test_initialism_v1_initialism_proto.Messages().ByName("ManageAWSResponse"))
		s.RegisterType(File_test_initialism_v1_initialism_proto.Messages().ByName("ManageAWSResourceRequest"))
		s.RegisterType(File_test_initialism_v1_initialism_proto.Messages().ByName("ManageAWSResourceResponse"))
	}
}
