// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: test/workerversioning/v1/example.proto
package workerversioningv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"sync"
	"sync/atomic"
	"time"
)

// test.workerversioning.v1.Example workflow names
const (
	BarWorkflowName = "test.workerversioning.v1.Example.Bar"
	BazWorkflowName = "test.workerversioning.v1.Example.Baz"
	FooWorkflowName = "test.workerversioning.v1.Example.Foo"
	QuxWorkflowName = "test.workerversioning.v1.Example.Qux"
)

// test.workerversioning.v1.Example workflow id expressions
var (
	BarIdexpression = expression.MustParseExpression("workflowversioning.v1.Bar/${! uuid_v4()}")
	BazIdexpression = expression.MustParseExpression("workflowversioning.v1.Baz/${! uuid_v4()}")
	FooIdexpression = expression.MustParseExpression("workflowversioning.v1.Foo/${! uuid_v4()}")
	QuxIdexpression = expression.MustParseExpression("workflowversioning.v1.Qux/${! uuid_v4()}")
)

// ExampleClient describes a client for a(n) test.workerversioning.v1.Example worker
type ExampleClient interface {
	// Bar executes a(n) test.workerversioning.v1.Example.Bar workflow and blocks until error or response received
	Bar(ctx context.Context, req *BarInput, opts ...*BarOptions) (*BarOutput, error)

	// BarAsync starts a(n) test.workerversioning.v1.Example.Bar workflow and returns a handle to the workflow run
	BarAsync(ctx context.Context, req *BarInput, opts ...*BarOptions) (BarRun, error)

	// GetBar retrieves a handle to an existing test.workerversioning.v1.Example.Bar workflow execution
	GetBar(ctx context.Context, workflowID string, runID string) BarRun

	// Baz executes a(n) test.workerversioning.v1.Example.Baz workflow and blocks until error or response received
	Baz(ctx context.Context, req *BazInput, opts ...*BazOptions) (*BazOutput, error)

	// BazAsync starts a(n) test.workerversioning.v1.Example.Baz workflow and returns a handle to the workflow run
	BazAsync(ctx context.Context, req *BazInput, opts ...*BazOptions) (BazRun, error)

	// GetBaz retrieves a handle to an existing test.workerversioning.v1.Example.Baz workflow execution
	GetBaz(ctx context.Context, workflowID string, runID string) BazRun

	// Foo executes a(n) test.workerversioning.v1.Example.Foo workflow and blocks until error or response received
	Foo(ctx context.Context, req *FooInput, opts ...*FooOptions) (*FooOutput, error)

	// FooAsync starts a(n) test.workerversioning.v1.Example.Foo workflow and returns a handle to the workflow run
	FooAsync(ctx context.Context, req *FooInput, opts ...*FooOptions) (FooRun, error)

	// GetFoo retrieves a handle to an existing test.workerversioning.v1.Example.Foo workflow execution
	GetFoo(ctx context.Context, workflowID string, runID string) FooRun

	// Qux executes a(n) test.workerversioning.v1.Example.Qux workflow and blocks until error or response received
	Qux(ctx context.Context, req *QuxInput, opts ...*QuxOptions) (*QuxOutput, error)

	// QuxAsync starts a(n) test.workerversioning.v1.Example.Qux workflow and returns a handle to the workflow run
	QuxAsync(ctx context.Context, req *QuxInput, opts ...*QuxOptions) (QuxRun, error)

	// GetQux retrieves a handle to an existing test.workerversioning.v1.Example.Qux workflow execution
	GetQux(ctx context.Context, workflowID string, runID string) QuxRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// exampleClient implements a temporal client for a test.workerversioning.v1.Example service
type exampleClient struct {
	client client.Client
	log    *slog.Logger
}

// NewExampleClient initializes a new test.workerversioning.v1.Example client
func NewExampleClient(c client.Client, options ...*exampleClientOptions) ExampleClient {
	var cfg *exampleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewExampleClientOptions()
	}
	return &exampleClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewExampleClientWithOptions initializes a new Example client with the given options
func NewExampleClientWithOptions(c client.Client, opts client.Options, options ...*exampleClientOptions) (ExampleClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *exampleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewExampleClientOptions()
	}
	return &exampleClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// exampleClientOptions describes optional runtime configuration for a ExampleClient
type exampleClientOptions struct {
	log *slog.Logger
}

// NewExampleClientOptions initializes a new exampleClientOptions value
func NewExampleClientOptions() *exampleClientOptions {
	return &exampleClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *exampleClientOptions) WithLogger(l *slog.Logger) *exampleClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *exampleClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// test.workerversioning.v1.Example.Bar executes a test.workerversioning.v1.Example.Bar workflow and blocks until error or response received
func (c *exampleClient) Bar(ctx context.Context, req *BarInput, options ...*BarOptions) (*BarOutput, error) {
	run, err := c.BarAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// BarAsync starts a(n) test.workerversioning.v1.Example.Bar workflow and returns a handle to the workflow run
func (c *exampleClient) BarAsync(ctx context.Context, req *BarInput, options ...*BarOptions) (BarRun, error) {
	var o *BarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, BarWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &barRun{
		client: c,
		run:    run,
	}, nil
}

// GetBar fetches an existing test.workerversioning.v1.Example.Bar execution
func (c *exampleClient) GetBar(ctx context.Context, workflowID string, runID string) BarRun {
	return &barRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// test.workerversioning.v1.Example.Baz executes a test.workerversioning.v1.Example.Baz workflow and blocks until error or response received
func (c *exampleClient) Baz(ctx context.Context, req *BazInput, options ...*BazOptions) (*BazOutput, error) {
	run, err := c.BazAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// BazAsync starts a(n) test.workerversioning.v1.Example.Baz workflow and returns a handle to the workflow run
func (c *exampleClient) BazAsync(ctx context.Context, req *BazInput, options ...*BazOptions) (BazRun, error) {
	var o *BazOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBazOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, BazWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &bazRun{
		client: c,
		run:    run,
	}, nil
}

// GetBaz fetches an existing test.workerversioning.v1.Example.Baz execution
func (c *exampleClient) GetBaz(ctx context.Context, workflowID string, runID string) BazRun {
	return &bazRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// test.workerversioning.v1.Example.Foo executes a test.workerversioning.v1.Example.Foo workflow and blocks until error or response received
func (c *exampleClient) Foo(ctx context.Context, req *FooInput, options ...*FooOptions) (*FooOutput, error) {
	run, err := c.FooAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// FooAsync starts a(n) test.workerversioning.v1.Example.Foo workflow and returns a handle to the workflow run
func (c *exampleClient) FooAsync(ctx context.Context, req *FooInput, options ...*FooOptions) (FooRun, error) {
	var o *FooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, FooWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &fooRun{
		client: c,
		run:    run,
	}, nil
}

// GetFoo fetches an existing test.workerversioning.v1.Example.Foo execution
func (c *exampleClient) GetFoo(ctx context.Context, workflowID string, runID string) FooRun {
	return &fooRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// test.workerversioning.v1.Example.Qux executes a test.workerversioning.v1.Example.Qux workflow and blocks until error or response received
func (c *exampleClient) Qux(ctx context.Context, req *QuxInput, options ...*QuxOptions) (*QuxOutput, error) {
	run, err := c.QuxAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// QuxAsync starts a(n) test.workerversioning.v1.Example.Qux workflow and returns a handle to the workflow run
func (c *exampleClient) QuxAsync(ctx context.Context, req *QuxInput, options ...*QuxOptions) (QuxRun, error) {
	var o *QuxOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewQuxOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, QuxWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &quxRun{
		client: c,
		run:    run,
	}, nil
}

// GetQux fetches an existing test.workerversioning.v1.Example.Qux execution
func (c *exampleClient) GetQux(ctx context.Context, workflowID string, runID string) QuxRun {
	return &quxRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *exampleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *exampleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// BarOptions provides configuration for a test.workerversioning.v1.Example.Bar workflow operation
type BarOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewBarOptions initializes a new BarOptions value
func NewBarOptions() *BarOptions {
	return &BarOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *BarOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(BarIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", BarWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *BarOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *BarOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *BarOptions) WithEnableEagerStart(enable bool) *BarOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *BarOptions) WithExecutionTimeout(d time.Duration) *BarOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *BarOptions) WithID(id string) *BarOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *BarOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *BarOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BarOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BarOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *BarOptions) WithRunTimeout(d time.Duration) *BarOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *BarOptions) WithSearchAttributes(sa map[string]any) *BarOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *BarOptions) WithTaskTimeout(d time.Duration) *BarOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BarOptions) WithTaskQueue(tq string) *BarOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *BarOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *BarOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *BarOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *BarOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// BarRun describes a(n) test.workerversioning.v1.Example.Bar workflow run
type BarRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*BarOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// barRun provides an internal implementation of a(n) BarRunRun
type barRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *barRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *barRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *barRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *barRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *barRun) Get(ctx context.Context) (*BarOutput, error) {
	var resp BarOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *barRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// BazOptions provides configuration for a test.workerversioning.v1.Example.Baz workflow operation
type BazOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewBazOptions initializes a new BazOptions value
func NewBazOptions() *BazOptions {
	return &BazOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *BazOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(BazIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", BazWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *BazOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *BazOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *BazOptions) WithEnableEagerStart(enable bool) *BazOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *BazOptions) WithExecutionTimeout(d time.Duration) *BazOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *BazOptions) WithID(id string) *BazOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *BazOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *BazOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BazOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BazOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *BazOptions) WithRunTimeout(d time.Duration) *BazOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *BazOptions) WithSearchAttributes(sa map[string]any) *BazOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *BazOptions) WithTaskTimeout(d time.Duration) *BazOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BazOptions) WithTaskQueue(tq string) *BazOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *BazOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *BazOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *BazOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *BazOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// BazRun describes a(n) test.workerversioning.v1.Example.Baz workflow run
type BazRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*BazOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// bazRun provides an internal implementation of a(n) BazRunRun
type bazRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *bazRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *bazRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *bazRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *bazRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *bazRun) Get(ctx context.Context) (*BazOutput, error) {
	var resp BazOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *bazRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// FooOptions provides configuration for a test.workerversioning.v1.Example.Foo workflow operation
type FooOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewFooOptions initializes a new FooOptions value
func NewFooOptions() *FooOptions {
	return &FooOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *FooOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(FooIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", FooWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *FooOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *FooOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *FooOptions) WithEnableEagerStart(enable bool) *FooOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *FooOptions) WithExecutionTimeout(d time.Duration) *FooOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *FooOptions) WithID(id string) *FooOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *FooOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *FooOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *FooOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *FooOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *FooOptions) WithRunTimeout(d time.Duration) *FooOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *FooOptions) WithSearchAttributes(sa map[string]any) *FooOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *FooOptions) WithTaskTimeout(d time.Duration) *FooOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *FooOptions) WithTaskQueue(tq string) *FooOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *FooOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *FooOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *FooOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *FooOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// FooRun describes a(n) test.workerversioning.v1.Example.Foo workflow run
type FooRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*FooOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// fooRun provides an internal implementation of a(n) FooRunRun
type fooRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *fooRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *fooRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *fooRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *fooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *fooRun) Get(ctx context.Context) (*FooOutput, error) {
	var resp FooOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *fooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// QuxOptions provides configuration for a test.workerversioning.v1.Example.Qux workflow operation
type QuxOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	typedSearchAttributes    *temporal.SearchAttributes
	enableEagerStart         *bool
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewQuxOptions initializes a new QuxOptions value
func NewQuxOptions() *QuxOptions {
	return &QuxOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *QuxOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(QuxIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", QuxWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		return opts, errors.New("TaskQueue is required")
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.enableEagerStart; v != nil {
		opts.EnableEagerStart = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *QuxOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *QuxOptions {
	o.options = options
	return o
}

// WithEnableEagerStart sets the EnableEagerStart value
func (o *QuxOptions) WithEnableEagerStart(enable bool) *QuxOptions {
	o.enableEagerStart = &enable
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *QuxOptions) WithExecutionTimeout(d time.Duration) *QuxOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *QuxOptions) WithID(id string) *QuxOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *QuxOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *QuxOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *QuxOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *QuxOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *QuxOptions) WithRunTimeout(d time.Duration) *QuxOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *QuxOptions) WithSearchAttributes(sa map[string]any) *QuxOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *QuxOptions) WithTaskTimeout(d time.Duration) *QuxOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *QuxOptions) WithTaskQueue(tq string) *QuxOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *QuxOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *QuxOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *QuxOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *QuxOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// QuxRun describes a(n) test.workerversioning.v1.Example.Qux workflow run
type QuxRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*QuxOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// quxRun provides an internal implementation of a(n) QuxRunRun
type quxRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *quxRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *quxRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *quxRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *quxRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *quxRun) Get(ctx context.Context) (*QuxOutput, error) {
	var resp QuxOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *quxRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// exampleRegistrationMutex is a mutex for registering test.workerversioning.v1.Example workflows
	exampleRegistrationMutex sync.Mutex
	// BarFunction implements a "test.workerversioning.v1.Example.Bar" workflow
	BarFunction func(workflow.Context, *BarInput) (*BarOutput, error)
	// BazFunction implements a "test.workerversioning.v1.Example.Baz" workflow
	BazFunction func(workflow.Context, *BazInput) (*BazOutput, error)
	// FooFunction implements a "test.workerversioning.v1.Example.Foo" workflow
	FooFunction func(workflow.Context, *FooInput) (*FooOutput, error)
	// QuxFunction implements a "test.workerversioning.v1.Example.Qux" workflow
	QuxFunction func(workflow.Context, *QuxInput) (*QuxOutput, error)
)

// ExampleWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// ExampleWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	ExampleWorkflowFunctions interface {
		// Bar executes a "test.workerversioning.v1.Example.Bar" workflow inline
		Bar(workflow.Context, *BarInput) (*BarOutput, error)
		// Baz executes a "test.workerversioning.v1.Example.Baz" workflow inline
		Baz(workflow.Context, *BazInput) (*BazOutput, error)
		// Foo executes a "test.workerversioning.v1.Example.Foo" workflow inline
		Foo(workflow.Context, *FooInput) (*FooOutput, error)
		// Qux executes a "test.workerversioning.v1.Example.Qux" workflow inline
		Qux(workflow.Context, *QuxInput) (*QuxOutput, error)
	}
	// exampleWorkflowFunctions provides an internal ExampleWorkflowFunctions implementation
	exampleWorkflowFunctions struct{}
)

func NewExampleWorkflowFunctions() ExampleWorkflowFunctions {
	return &exampleWorkflowFunctions{}
}

// Bar executes a "test.workerversioning.v1.Example.Bar" workflow inline
func (f *exampleWorkflowFunctions) Bar(ctx workflow.Context, req *BarInput) (*BarOutput, error) {
	if BarFunction == nil {
		return nil, errors.New("Bar requires workflow registration via RegisterExampleWorkflows or RegisterBarWorkflow")
	}
	return BarFunction(ctx, req)
}

// Baz executes a "test.workerversioning.v1.Example.Baz" workflow inline
func (f *exampleWorkflowFunctions) Baz(ctx workflow.Context, req *BazInput) (*BazOutput, error) {
	if BazFunction == nil {
		return nil, errors.New("Baz requires workflow registration via RegisterExampleWorkflows or RegisterBazWorkflow")
	}
	return BazFunction(ctx, req)
}

// Foo executes a "test.workerversioning.v1.Example.Foo" workflow inline
func (f *exampleWorkflowFunctions) Foo(ctx workflow.Context, req *FooInput) (*FooOutput, error) {
	if FooFunction == nil {
		return nil, errors.New("Foo requires workflow registration via RegisterExampleWorkflows or RegisterFooWorkflow")
	}
	return FooFunction(ctx, req)
}

// Qux executes a "test.workerversioning.v1.Example.Qux" workflow inline
func (f *exampleWorkflowFunctions) Qux(ctx workflow.Context, req *QuxInput) (*QuxOutput, error) {
	if QuxFunction == nil {
		return nil, errors.New("Qux requires workflow registration via RegisterExampleWorkflows or RegisterQuxWorkflow")
	}
	return QuxFunction(ctx, req)
}

// ExampleWorkflows provides methods for initializing new test.workerversioning.v1.Example workflow values
type ExampleWorkflows interface {
	// Bar initializes a new a(n) BarWorkflow implementation
	Bar(ctx workflow.Context, input *BarWorkflowInput) (BarWorkflow, error)

	// Baz initializes a new a(n) BazWorkflow implementation
	Baz(ctx workflow.Context, input *BazWorkflowInput) (BazWorkflow, error)

	// Foo initializes a new a(n) FooWorkflow implementation
	Foo(ctx workflow.Context, input *FooWorkflowInput) (FooWorkflow, error)

	// Qux initializes a new a(n) QuxWorkflow implementation
	Qux(ctx workflow.Context, input *QuxWorkflowInput) (QuxWorkflow, error)
}

// RegisterExampleWorkflows registers test.workerversioning.v1.Example workflows with the given worker
func RegisterExampleWorkflows(r worker.WorkflowRegistry, workflows ExampleWorkflows) {
	RegisterBarWorkflow(r, workflows.Bar)
	RegisterBazWorkflow(r, workflows.Baz)
	RegisterFooWorkflow(r, workflows.Foo)
	RegisterQuxWorkflow(r, workflows.Qux)
}

// RegisterBarWorkflow registers a test.workerversioning.v1.Example.Bar workflow with the given worker
func RegisterBarWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *BarWorkflowInput) (BarWorkflow, error)) {
	exampleRegistrationMutex.Lock()
	defer exampleRegistrationMutex.Unlock()
	BarFunction = buildBar(wf)
	r.RegisterWorkflowWithOptions(BarFunction, workflow.RegisterOptions{Name: BarWorkflowName})
}

// buildBar converts a Bar workflow struct into a valid workflow function
func buildBar(ctor func(workflow.Context, *BarWorkflowInput) (BarWorkflow, error)) func(workflow.Context, *BarInput) (*BarOutput, error) {
	return func(ctx workflow.Context, req *BarInput) (*BarOutput, error) {
		input := &BarWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// BarWorkflowInput describes the input to a(n) test.workerversioning.v1.Example.Bar workflow constructor
type BarWorkflowInput struct {
	Req *BarInput
}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *BarWorkflowInput) ContinueAsNew(ctx workflow.Context, input *BarInput, options ...workflow.ContinueAsNewErrorOptions) (*BarOutput, error) {
	next := i.Req
	if input != nil {
		next = input
	}
	if len(options) > 0 {
		return nil, workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], BarWorkflowName, next)
	}
	return nil, workflow.NewContinueAsNewError(ctx, BarWorkflowName, next)
}

// BarWorkflow describes a(n) test.workerversioning.v1.Example.Bar workflow implementation
//
// workflow details: (id: "workflowversioning.v1.Bar/${! uuid_v4()}")
type BarWorkflow interface {
	// Execute defines the entrypoint to a(n) test.workerversioning.v1.Example.Bar workflow
	Execute(ctx workflow.Context) (*BarOutput, error)
}

// BarChild executes a child test.workerversioning.v1.Example.Bar workflow and blocks until error or response received
func BarChild(ctx workflow.Context, req *BarInput, options ...*BarChildOptions) (*BarOutput, error) {
	childRun, err := BarChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// BarChildAsync starts a child test.workerversioning.v1.Example.Bar workflow and returns a handle to the child workflow run
func BarChildAsync(ctx workflow.Context, req *BarInput, options ...*BarChildOptions) (*BarChildRun, error) {
	var o *BarChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &BarChildRun{Future: workflow.ExecuteChildWorkflow(ctx, BarWorkflowName, req)}, nil
}

// BarChildOptions provides configuration for a child test.workerversioning.v1.Example.Bar workflow operation
type BarChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewBarChildOptions initializes a new BarChildOptions value
func NewBarChildOptions() *BarChildOptions {
	return &BarChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *BarChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(BarIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", BarWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", BarWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(BarIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", BarWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *BarChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *BarChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *BarChildOptions) WithDataConverter(dc converter.DataConverter) *BarChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *BarChildOptions) WithExecutionTimeout(d time.Duration) *BarChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *BarChildOptions) WithID(id string) *BarChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *BarChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *BarChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *BarChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *BarChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BarChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BarChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *BarChildOptions) WithRunTimeout(d time.Duration) *BarChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *BarChildOptions) WithSearchAttributes(sa map[string]any) *BarChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *BarChildOptions) WithTaskTimeout(d time.Duration) *BarChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BarChildOptions) WithTaskQueue(tq string) *BarChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *BarChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *BarChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *BarChildOptions) WithWaitForCancellation(wait bool) *BarChildOptions {
	o.waitForCancellation = &wait
	return o
}

// BarChildRun describes a child Bar workflow run
type BarChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *BarChildRun) Get(ctx workflow.Context) (*BarOutput, error) {
	var resp BarOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *BarChildRun) Select(sel workflow.Selector, fn func(*BarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *BarChildRun) SelectStart(sel workflow.Selector, fn func(*BarChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *BarChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterBazWorkflow registers a test.workerversioning.v1.Example.Baz workflow with the given worker
func RegisterBazWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *BazWorkflowInput) (BazWorkflow, error)) {
	exampleRegistrationMutex.Lock()
	defer exampleRegistrationMutex.Unlock()
	BazFunction = buildBaz(wf)
	r.RegisterWorkflowWithOptions(BazFunction, workflow.RegisterOptions{
		Name:               BazWorkflowName,
		VersioningBehavior: workflow.VersioningBehaviorPinned,
	})
}

// buildBaz converts a Baz workflow struct into a valid workflow function
func buildBaz(ctor func(workflow.Context, *BazWorkflowInput) (BazWorkflow, error)) func(workflow.Context, *BazInput) (*BazOutput, error) {
	return func(ctx workflow.Context, req *BazInput) (*BazOutput, error) {
		input := &BazWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// BazWorkflowInput describes the input to a(n) test.workerversioning.v1.Example.Baz workflow constructor
type BazWorkflowInput struct {
	Req *BazInput
}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *BazWorkflowInput) ContinueAsNew(ctx workflow.Context, input *BazInput, options ...workflow.ContinueAsNewErrorOptions) (*BazOutput, error) {
	next := i.Req
	if input != nil {
		next = input
	}
	if len(options) > 0 {
		return nil, workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], BazWorkflowName, next)
	}
	return nil, workflow.NewContinueAsNewError(ctx, BazWorkflowName, next)
}

// BazWorkflow describes a(n) test.workerversioning.v1.Example.Baz workflow implementation
//
// workflow details: (id: "workflowversioning.v1.Baz/${! uuid_v4()}")
type BazWorkflow interface {
	// Execute defines the entrypoint to a(n) test.workerversioning.v1.Example.Baz workflow
	Execute(ctx workflow.Context) (*BazOutput, error)
}

// BazChild executes a child test.workerversioning.v1.Example.Baz workflow and blocks until error or response received
func BazChild(ctx workflow.Context, req *BazInput, options ...*BazChildOptions) (*BazOutput, error) {
	childRun, err := BazChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// BazChildAsync starts a child test.workerversioning.v1.Example.Baz workflow and returns a handle to the child workflow run
func BazChildAsync(ctx workflow.Context, req *BazInput, options ...*BazChildOptions) (*BazChildRun, error) {
	var o *BazChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBazChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &BazChildRun{Future: workflow.ExecuteChildWorkflow(ctx, BazWorkflowName, req)}, nil
}

// BazChildOptions provides configuration for a child test.workerversioning.v1.Example.Baz workflow operation
type BazChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewBazChildOptions initializes a new BazChildOptions value
func NewBazChildOptions() *BazChildOptions {
	return &BazChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *BazChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(BazIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", BazWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", BazWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(BazIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", BazWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *BazChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *BazChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *BazChildOptions) WithDataConverter(dc converter.DataConverter) *BazChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *BazChildOptions) WithExecutionTimeout(d time.Duration) *BazChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *BazChildOptions) WithID(id string) *BazChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *BazChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *BazChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *BazChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *BazChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *BazChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *BazChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *BazChildOptions) WithRunTimeout(d time.Duration) *BazChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *BazChildOptions) WithSearchAttributes(sa map[string]any) *BazChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *BazChildOptions) WithTaskTimeout(d time.Duration) *BazChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *BazChildOptions) WithTaskQueue(tq string) *BazChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *BazChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *BazChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *BazChildOptions) WithWaitForCancellation(wait bool) *BazChildOptions {
	o.waitForCancellation = &wait
	return o
}

// BazChildRun describes a child Baz workflow run
type BazChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *BazChildRun) Get(ctx workflow.Context) (*BazOutput, error) {
	var resp BazOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *BazChildRun) Select(sel workflow.Selector, fn func(*BazChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *BazChildRun) SelectStart(sel workflow.Selector, fn func(*BazChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *BazChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterFooWorkflow registers a test.workerversioning.v1.Example.Foo workflow with the given worker
func RegisterFooWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *FooWorkflowInput) (FooWorkflow, error)) {
	exampleRegistrationMutex.Lock()
	defer exampleRegistrationMutex.Unlock()
	FooFunction = buildFoo(wf)
	r.RegisterWorkflowWithOptions(FooFunction, workflow.RegisterOptions{Name: FooWorkflowName})
}

// buildFoo converts a Foo workflow struct into a valid workflow function
func buildFoo(ctor func(workflow.Context, *FooWorkflowInput) (FooWorkflow, error)) func(workflow.Context, *FooInput) (*FooOutput, error) {
	return func(ctx workflow.Context, req *FooInput) (*FooOutput, error) {
		input := &FooWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// FooWorkflowInput describes the input to a(n) test.workerversioning.v1.Example.Foo workflow constructor
type FooWorkflowInput struct {
	Req *FooInput
}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *FooWorkflowInput) ContinueAsNew(ctx workflow.Context, input *FooInput, options ...workflow.ContinueAsNewErrorOptions) (*FooOutput, error) {
	next := i.Req
	if input != nil {
		next = input
	}
	if len(options) > 0 {
		return nil, workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], FooWorkflowName, next)
	}
	return nil, workflow.NewContinueAsNewError(ctx, FooWorkflowName, next)
}

// FooWorkflow describes a(n) test.workerversioning.v1.Example.Foo workflow implementation
//
// workflow details: (id: "workflowversioning.v1.Foo/${! uuid_v4()}")
type FooWorkflow interface {
	// Execute defines the entrypoint to a(n) test.workerversioning.v1.Example.Foo workflow
	Execute(ctx workflow.Context) (*FooOutput, error)
}

// FooChild executes a child test.workerversioning.v1.Example.Foo workflow and blocks until error or response received
func FooChild(ctx workflow.Context, req *FooInput, options ...*FooChildOptions) (*FooOutput, error) {
	childRun, err := FooChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// FooChildAsync starts a child test.workerversioning.v1.Example.Foo workflow and returns a handle to the child workflow run
func FooChildAsync(ctx workflow.Context, req *FooInput, options ...*FooChildOptions) (*FooChildRun, error) {
	var o *FooChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &FooChildRun{Future: workflow.ExecuteChildWorkflow(ctx, FooWorkflowName, req)}, nil
}

// FooChildOptions provides configuration for a child test.workerversioning.v1.Example.Foo workflow operation
type FooChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewFooChildOptions initializes a new FooChildOptions value
func NewFooChildOptions() *FooChildOptions {
	return &FooChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *FooChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(FooIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", FooWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", FooWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(FooIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", FooWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *FooChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *FooChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *FooChildOptions) WithDataConverter(dc converter.DataConverter) *FooChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *FooChildOptions) WithExecutionTimeout(d time.Duration) *FooChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *FooChildOptions) WithID(id string) *FooChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *FooChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *FooChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *FooChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *FooChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *FooChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *FooChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *FooChildOptions) WithRunTimeout(d time.Duration) *FooChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *FooChildOptions) WithSearchAttributes(sa map[string]any) *FooChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *FooChildOptions) WithTaskTimeout(d time.Duration) *FooChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *FooChildOptions) WithTaskQueue(tq string) *FooChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *FooChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *FooChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *FooChildOptions) WithWaitForCancellation(wait bool) *FooChildOptions {
	o.waitForCancellation = &wait
	return o
}

// FooChildRun describes a child Foo workflow run
type FooChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *FooChildRun) Get(ctx workflow.Context) (*FooOutput, error) {
	var resp FooOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *FooChildRun) Select(sel workflow.Selector, fn func(*FooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *FooChildRun) SelectStart(sel workflow.Selector, fn func(*FooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *FooChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// RegisterQuxWorkflow registers a test.workerversioning.v1.Example.Qux workflow with the given worker
func RegisterQuxWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *QuxWorkflowInput) (QuxWorkflow, error)) {
	exampleRegistrationMutex.Lock()
	defer exampleRegistrationMutex.Unlock()
	QuxFunction = buildQux(wf)
	r.RegisterWorkflowWithOptions(QuxFunction, workflow.RegisterOptions{
		Name:               QuxWorkflowName,
		VersioningBehavior: workflow.VersioningBehaviorAutoUpgrade,
	})
}

// buildQux converts a Qux workflow struct into a valid workflow function
func buildQux(ctor func(workflow.Context, *QuxWorkflowInput) (QuxWorkflow, error)) func(workflow.Context, *QuxInput) (*QuxOutput, error) {
	return func(ctx workflow.Context, req *QuxInput) (*QuxOutput, error) {
		input := &QuxWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// QuxWorkflowInput describes the input to a(n) test.workerversioning.v1.Example.Qux workflow constructor
type QuxWorkflowInput struct {
	Req *QuxInput
}

// ContinueAsNew returns an appropriately configured ContinueAsNewError
func (i *QuxWorkflowInput) ContinueAsNew(ctx workflow.Context, input *QuxInput, options ...workflow.ContinueAsNewErrorOptions) (*QuxOutput, error) {
	next := i.Req
	if input != nil {
		next = input
	}
	if len(options) > 0 {
		return nil, workflow.NewContinueAsNewErrorWithOptions(ctx, options[0], QuxWorkflowName, next)
	}
	return nil, workflow.NewContinueAsNewError(ctx, QuxWorkflowName, next)
}

// QuxWorkflow describes a(n) test.workerversioning.v1.Example.Qux workflow implementation
//
// workflow details: (id: "workflowversioning.v1.Qux/${! uuid_v4()}")
type QuxWorkflow interface {
	// Execute defines the entrypoint to a(n) test.workerversioning.v1.Example.Qux workflow
	Execute(ctx workflow.Context) (*QuxOutput, error)
}

// QuxChild executes a child test.workerversioning.v1.Example.Qux workflow and blocks until error or response received
func QuxChild(ctx workflow.Context, req *QuxInput, options ...*QuxChildOptions) (*QuxOutput, error) {
	childRun, err := QuxChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// QuxChildAsync starts a child test.workerversioning.v1.Example.Qux workflow and returns a handle to the child workflow run
func QuxChildAsync(ctx workflow.Context, req *QuxInput, options ...*QuxChildOptions) (*QuxChildRun, error) {
	var o *QuxChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewQuxChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &QuxChildRun{Future: workflow.ExecuteChildWorkflow(ctx, QuxWorkflowName, req)}, nil
}

// QuxChildOptions provides configuration for a child test.workerversioning.v1.Example.Qux workflow operation
type QuxChildOptions struct {
	options               workflow.ChildWorkflowOptions
	executionTimeout      *time.Duration
	id                    *string
	idReusePolicy         enumsv1.WorkflowIdReusePolicy
	retryPolicy           *temporal.RetryPolicy
	runTimeout            *time.Duration
	searchAttributes      map[string]any
	taskQueue             *string
	taskTimeout           *time.Duration
	typedSearchAttributes *temporal.SearchAttributes
	dc                    converter.DataConverter
	parentClosePolicy     enumsv1.ParentClosePolicy
	waitForCancellation   *bool
}

// NewQuxChildOptions initializes a new QuxChildOptions value
func NewQuxChildOptions() *QuxChildOptions {
	return &QuxChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *QuxChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(QuxIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", QuxWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", QuxWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(QuxIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", QuxWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = workflow.GetInfo(ctx).TaskQueueName
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.typedSearchAttributes; v != nil {
		opts.TypedSearchAttributes = *v
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *QuxChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *QuxChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *QuxChildOptions) WithDataConverter(dc converter.DataConverter) *QuxChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *QuxChildOptions) WithExecutionTimeout(d time.Duration) *QuxChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *QuxChildOptions) WithID(id string) *QuxChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *QuxChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *QuxChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *QuxChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *QuxChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *QuxChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *QuxChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *QuxChildOptions) WithRunTimeout(d time.Duration) *QuxChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *QuxChildOptions) WithSearchAttributes(sa map[string]any) *QuxChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *QuxChildOptions) WithTaskTimeout(d time.Duration) *QuxChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *QuxChildOptions) WithTaskQueue(tq string) *QuxChildOptions {
	o.taskQueue = &tq
	return o
}

// WithTypedSearchAttributes sets the TypedSearchAttributes value
func (o *QuxChildOptions) WithTypedSearchAttributes(tsa temporal.SearchAttributes) *QuxChildOptions {
	o.typedSearchAttributes = &tsa
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *QuxChildOptions) WithWaitForCancellation(wait bool) *QuxChildOptions {
	o.waitForCancellation = &wait
	return o
}

// QuxChildRun describes a child Qux workflow run
type QuxChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *QuxChildRun) Get(ctx workflow.Context) (*QuxOutput, error) {
	var resp QuxOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *QuxChildRun) Select(sel workflow.Selector, fn func(*QuxChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *QuxChildRun) SelectStart(sel workflow.Selector, fn func(*QuxChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *QuxChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// ExampleActivities describes available worker activities
type ExampleActivities interface{}

// RegisterExampleActivities registers activities with a worker
func RegisterExampleActivities(r worker.ActivityRegistry, activities ExampleActivities) {}

// TestClient provides a testsuite-compatible Client
type TestExampleClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ExampleWorkflows
}

var _ ExampleClient = &TestExampleClient{}

// NewTestExampleClient initializes a new TestExampleClient value
func NewTestExampleClient(env *testsuite.TestWorkflowEnvironment, workflows ExampleWorkflows, activities ExampleActivities) *TestExampleClient {
	if workflows != nil {
		RegisterExampleWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterExampleActivities(env, activities)
	}
	return &TestExampleClient{env, workflows}
}

// Bar executes a(n) test.workerversioning.v1.Example.Bar workflow in the test environment
func (c *TestExampleClient) Bar(ctx context.Context, req *BarInput, opts ...*BarOptions) (*BarOutput, error) {
	run, err := c.BarAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// BarAsync executes a(n) test.workerversioning.v1.Example.Bar workflow in the test environment
func (c *TestExampleClient) BarAsync(ctx context.Context, req *BarInput, options ...*BarOptions) (BarRun, error) {
	var o *BarOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBarOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testBarRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetBar is a noop
func (c *TestExampleClient) GetBar(ctx context.Context, workflowID string, runID string) BarRun {
	return &testBarRun{env: c.env, workflows: c.workflows}
}

// Baz executes a(n) test.workerversioning.v1.Example.Baz workflow in the test environment
func (c *TestExampleClient) Baz(ctx context.Context, req *BazInput, opts ...*BazOptions) (*BazOutput, error) {
	run, err := c.BazAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// BazAsync executes a(n) test.workerversioning.v1.Example.Baz workflow in the test environment
func (c *TestExampleClient) BazAsync(ctx context.Context, req *BazInput, options ...*BazOptions) (BazRun, error) {
	var o *BazOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewBazOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testBazRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetBaz is a noop
func (c *TestExampleClient) GetBaz(ctx context.Context, workflowID string, runID string) BazRun {
	return &testBazRun{env: c.env, workflows: c.workflows}
}

// Foo executes a(n) test.workerversioning.v1.Example.Foo workflow in the test environment
func (c *TestExampleClient) Foo(ctx context.Context, req *FooInput, opts ...*FooOptions) (*FooOutput, error) {
	run, err := c.FooAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// FooAsync executes a(n) test.workerversioning.v1.Example.Foo workflow in the test environment
func (c *TestExampleClient) FooAsync(ctx context.Context, req *FooInput, options ...*FooOptions) (FooRun, error) {
	var o *FooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testFooRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetFoo is a noop
func (c *TestExampleClient) GetFoo(ctx context.Context, workflowID string, runID string) FooRun {
	return &testFooRun{env: c.env, workflows: c.workflows}
}

// Qux executes a(n) test.workerversioning.v1.Example.Qux workflow in the test environment
func (c *TestExampleClient) Qux(ctx context.Context, req *QuxInput, opts ...*QuxOptions) (*QuxOutput, error) {
	run, err := c.QuxAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// QuxAsync executes a(n) test.workerversioning.v1.Example.Qux workflow in the test environment
func (c *TestExampleClient) QuxAsync(ctx context.Context, req *QuxInput, options ...*QuxOptions) (QuxRun, error) {
	var o *QuxOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewQuxOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testQuxRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetQux is a noop
func (c *TestExampleClient) GetQux(ctx context.Context, workflowID string, runID string) QuxRun {
	return &testQuxRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestExampleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestExampleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ BarRun = &testBarRun{}

// testBarRun provides convenience methods for interacting with a(n) test.workerversioning.v1.Example.Bar workflow in the test environment
type testBarRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *BarInput
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testBarRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.workerversioning.v1.Example.Bar workflow result
func (r *testBarRun) Get(context.Context) (*BarOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(BarWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result BarOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.workerversioning.v1.Example.Bar workflow run's workflow ID
func (r *testBarRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testBarRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testBarRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testBarRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ BazRun = &testBazRun{}

// testBazRun provides convenience methods for interacting with a(n) test.workerversioning.v1.Example.Baz workflow in the test environment
type testBazRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *BazInput
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testBazRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.workerversioning.v1.Example.Baz workflow result
func (r *testBazRun) Get(context.Context) (*BazOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(BazWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result BazOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.workerversioning.v1.Example.Baz workflow run's workflow ID
func (r *testBazRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testBazRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testBazRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testBazRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ FooRun = &testFooRun{}

// testFooRun provides convenience methods for interacting with a(n) test.workerversioning.v1.Example.Foo workflow in the test environment
type testFooRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *FooInput
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testFooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.workerversioning.v1.Example.Foo workflow result
func (r *testFooRun) Get(context.Context) (*FooOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(FooWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result FooOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.workerversioning.v1.Example.Foo workflow run's workflow ID
func (r *testFooRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testFooRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testFooRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testFooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

var _ QuxRun = &testQuxRun{}

// testQuxRun provides convenience methods for interacting with a(n) test.workerversioning.v1.Example.Qux workflow in the test environment
type testQuxRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *QuxInput
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testQuxRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test test.workerversioning.v1.Example.Qux workflow result
func (r *testQuxRun) Get(context.Context) (*QuxOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(QuxWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result QuxOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test test.workerversioning.v1.Example.Qux workflow run's workflow ID
func (r *testQuxRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testQuxRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testQuxRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testQuxRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// ExampleCliOptions describes runtime configuration for test.workerversioning.v1.Example cli
type ExampleCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewExampleCliOptions initializes a new ExampleCliOptions value
func NewExampleCliOptions() *ExampleCliOptions {
	return &ExampleCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ExampleCliOptions) WithAfter(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ExampleCliOptions) WithBefore(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ExampleCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ExampleCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ExampleCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ExampleCliOptions {
	opts.worker = fn
	return opts
}

// NewExampleCli initializes a cli for a(n) test.workerversioning.v1.Example service
func NewExampleCli(options ...*ExampleCliOptions) (*v2.App, error) {
	commands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:                      "example",
		Usage:                     "test.workerversioning.v1.Example operations",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// NewExampleCliCommand initializes a cli command for a test.workerversioning.v1.Example service with subcommands for each query, signal, update, and workflow
func NewExampleCliCommand(options ...*ExampleCliOptions) (*v2.Command, error) {
	subcommands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "example",
		Usage:       "test.workerversioning.v1.Example operations",
		Subcommands: subcommands,
	}, nil
}

// newExampleCommands initializes (sub)commands for a test.workerversioning.v1.Example cli or command
func newExampleCommands(options ...*ExampleCliOptions) ([]*v2.Command, error) {
	opts := &ExampleCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "bar",
			Usage:                  "executes a(n) test.workerversioning.v1.Example.Bar workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "task-queue",
					Usage:    "task queue name",
					Aliases:  []string{"t"},
					EnvVars:  []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Required: true,
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToBarInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.BarAsync(cmd.Context, req, NewBarOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", BarWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "baz",
			Usage:                  "executes a(n) test.workerversioning.v1.Example.Baz workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "task-queue",
					Usage:    "task queue name",
					Aliases:  []string{"t"},
					EnvVars:  []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Required: true,
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToBazInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.BazAsync(cmd.Context, req, NewBazOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", BazWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "foo",
			Usage:                  "executes a(n) test.workerversioning.v1.Example.Foo workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "task-queue",
					Usage:    "task queue name",
					Aliases:  []string{"t"},
					EnvVars:  []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Required: true,
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToFooInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.FooAsync(cmd.Context, req, NewFooOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", FooWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "qux",
			Usage:                  "executes a(n) test.workerversioning.v1.Example.Qux workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "task-queue",
					Usage:    "task queue name",
					Aliases:  []string{"t"},
					EnvVars:  []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Required: true,
				},
				&v2.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToQuxInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.QuxAsync(cmd.Context, req, NewQuxOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", QuxWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a test.workerversioning.v1.Example worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToBarInput unmarshals a BarInput from command line flags
func UnmarshalCliFlagsToBarInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*BarInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result BarInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// UnmarshalCliFlagsToBazInput unmarshals a BazInput from command line flags
func UnmarshalCliFlagsToBazInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*BazInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result BazInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// UnmarshalCliFlagsToFooInput unmarshals a FooInput from command line flags
func UnmarshalCliFlagsToFooInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*FooInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result FooInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// UnmarshalCliFlagsToQuxInput unmarshals a QuxInput from command line flags
func UnmarshalCliFlagsToQuxInput(cmd *v2.Context, options ...helpers.UnmarshalCliFlagsOptions) (*QuxInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result QuxInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	return &result, nil
}

// WithExampleSchemeTypes registers all Example protobuf types with the given scheme
func WithExampleSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("BarInput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("BarOutput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("BazInput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("BazOutput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("FooInput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("FooOutput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("QuxInput"))
		s.RegisterType(File_test_workerversioning_v1_example_proto.Messages().ByName("QuxOutput"))
	}
}
