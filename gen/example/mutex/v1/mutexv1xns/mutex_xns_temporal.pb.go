// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 0.0.1-next (c119af1d2fcff0c4d02fcb42bcb8179a0945b8ad)
//	go go1.24.0
//	protoc (unknown)
//
// source: example/mutex/v1/mutex.proto
package mutexv1xns

import (
	"context"
	"errors"
	"fmt"
	v1 "github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1"
	temporalv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/v1"
	xnsv1 "github.com/cludden/protoc-gen-go-temporal/gen/temporal/xns/v1"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	xns "github.com/cludden/protoc-gen-go-temporal/pkg/xns"
	uuid "github.com/google/uuid"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	anypb "google.golang.org/protobuf/types/known/anypb"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"time"
)

// ExampleOptions is used to configure example.mutex.v1.Example xns activity registration
type ExampleOptions struct {
	// errorConverter is used to customize error
	errorConverter func(error) error
	// filter is used to filter xns activity registrations. It receives as
	// input the original activity name, and should return one of the following:
	// 1. the original activity name, for no changes
	// 2. a modified activity name, to override the original activity name
	// 3. an empty string, to skip registration
	filter func(string) string
}

// NewExampleOptions initializes a new ExampleOptions value
func NewExampleOptions() *ExampleOptions {
	return &ExampleOptions{}
}

// WithErrorConverter overrides the default error converter applied to xns activity errors
func (opts *ExampleOptions) WithErrorConverter(errorConverter func(error) error) *ExampleOptions {
	opts.errorConverter = errorConverter
	return opts
}

// Filter is used to filter registered xns activities or customize their name
func (opts *ExampleOptions) WithFilter(filter func(string) string) *ExampleOptions {
	opts.filter = filter
	return opts
}

// convertError is applied to all xns activity errors
func (opts *ExampleOptions) convertError(err error) error {
	if err == nil {
		return nil
	}
	if opts != nil && opts.errorConverter != nil {
		return opts.errorConverter(err)
	}
	return xns.ErrorToApplicationError(err)
}

// filterActivity is used to filter xns activity registrations
func (opts *ExampleOptions) filterActivity(name string) string {
	if opts == nil || opts.filter == nil {
		return name
	}
	return opts.filter(name)
}

// exampleOptions is a reference to the ExampleOptions initialized at registration
var exampleOptions *ExampleOptions

// RegisterExampleActivities registers example.mutex.v1.Example cross-namespace activities
func RegisterExampleActivities(r worker.ActivityRegistry, c v1.ExampleClient, options ...*ExampleOptions) {
	if exampleOptions == nil && len(options) > 0 && options[0] != nil {
		exampleOptions = options[0]
	}
	a := &exampleActivities{c}
	if name := exampleOptions.filterActivity("example.mutex.v1.Example.CancelWorkflow"); name != "" {
		r.RegisterActivityWithOptions(a.CancelWorkflow, activity.RegisterOptions{Name: name})
	}
	if name := exampleOptions.filterActivity(v1.MutexWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.Mutex, activity.RegisterOptions{Name: name})
	}
	if name := exampleOptions.filterActivity("example.mutex.v1.Example.MutexWithAcquireLock"); name != "" {
		r.RegisterActivityWithOptions(a.MutexWithAcquireLock, activity.RegisterOptions{Name: name})
	}
	if name := exampleOptions.filterActivity(v1.SampleWorkflowWithMutexWorkflowName); name != "" {
		r.RegisterActivityWithOptions(a.SampleWorkflowWithMutex, activity.RegisterOptions{Name: name})
	}
	if name := exampleOptions.filterActivity(v1.AcquireLockSignalName); name != "" {
		r.RegisterActivityWithOptions(a.AcquireLock, activity.RegisterOptions{Name: name})
	}
	if name := exampleOptions.filterActivity(v1.LockAcquiredSignalName); name != "" {
		r.RegisterActivityWithOptions(a.LockAcquired, activity.RegisterOptions{Name: name})
	}
	if name := exampleOptions.filterActivity(v1.ReleaseLockSignalName); name != "" {
		r.RegisterActivityWithOptions(a.ReleaseLock, activity.RegisterOptions{Name: name})
	}
}

// MutexWorkflowOptions are used to configure a(n) example.mutex.v1.Example.Mutex workflow execution
type MutexWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewMutexWorkflowOptions initializes a new MutexWorkflowOptions value
func NewMutexWorkflowOptions() *MutexWorkflowOptions {
	return &MutexWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *MutexWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *MutexWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *MutexWorkflowOptions) WithDetached(d bool) *MutexWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *MutexWorkflowOptions) WithHeartbeatInterval(d time.Duration) *MutexWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *MutexWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *MutexWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *MutexWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *MutexWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// MutexRun provides a handle to a example.mutex.v1.Example.Mutex workflow execution
type MutexRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) error

	// ID returns the workflow id
	ID() string

	// AcquireLock executes a(n) example.mutex.v1.Example.AcquireLock signal and blocks until completion
	AcquireLock(workflow.Context, *v1.AcquireLockInput, ...*AcquireLockSignalOptions) error

	// AcquireLockAsync executes a(n) example.mutex.v1.Example.AcquireLock signal and returns a handle to the underlying activity
	AcquireLockAsync(workflow.Context, *v1.AcquireLockInput, ...*AcquireLockSignalOptions) (AcquireLockSignalHandle, error)

	// ReleaseLock executes a(n) example.mutex.v1.Example.ReleaseLock signal and blocks until completion
	ReleaseLock(workflow.Context, *v1.ReleaseLockInput, ...*ReleaseLockSignalOptions) error

	// ReleaseLockAsync executes a(n) example.mutex.v1.Example.ReleaseLock signal and returns a handle to the underlying activity
	ReleaseLockAsync(workflow.Context, *v1.ReleaseLockInput, ...*ReleaseLockSignalOptions) (ReleaseLockSignalHandle, error)
}

// mutexRun provides a(n) MutexRun implementation
type mutexRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *mutexRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelExampleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *mutexRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *mutexRun) Get(ctx workflow.Context) error {
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *mutexRun) ID() string {
	return r.id
}

// AcquireLock executes a(n) example.mutex.v1.Example.AcquireLock signal and blocks until the underlying activity completes
func (r *mutexRun) AcquireLock(ctx workflow.Context, req *v1.AcquireLockInput, opts ...*AcquireLockSignalOptions) error {
	return AcquireLock(ctx, r.ID(), "", req, opts...)
}

// AcquireLockAsync executes a(n) example.mutex.v1.Example.AcquireLock signal and returns a handle to the underlying activity
func (r *mutexRun) AcquireLockAsync(ctx workflow.Context, req *v1.AcquireLockInput, opts ...*AcquireLockSignalOptions) (AcquireLockSignalHandle, error) {
	return AcquireLockAsync(ctx, r.ID(), "", req, opts...)
}

// ReleaseLock executes a(n) example.mutex.v1.Example.ReleaseLock signal and blocks until the underlying activity completes
func (r *mutexRun) ReleaseLock(ctx workflow.Context, req *v1.ReleaseLockInput, opts ...*ReleaseLockSignalOptions) error {
	return ReleaseLock(ctx, r.ID(), "", req, opts...)
}

// ReleaseLockAsync executes a(n) example.mutex.v1.Example.ReleaseLock signal and returns a handle to the underlying activity
func (r *mutexRun) ReleaseLockAsync(ctx workflow.Context, req *v1.ReleaseLockInput, opts ...*ReleaseLockSignalOptions) (ReleaseLockSignalHandle, error) {
	return ReleaseLockAsync(ctx, r.ID(), "", req, opts...)
}

// Mutex executes a(n) example.mutex.v1.Example.Mutex workflow and blocks until error or response is received
func Mutex(ctx workflow.Context, req *v1.MutexInput, opts ...*MutexWorkflowOptions) error {
	run, err := MutexAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexAsync executes a(n) example.mutex.v1.Example.Mutex workflow and returns a handle to the underlying activity
func MutexAsync(ctx workflow.Context, req *v1.MutexInput, opts ...*MutexWorkflowOptions) (MutexRun, error) {
	activityName := exampleOptions.filterActivity(v1.MutexWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.MutexWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &MutexWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.MutexIdexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"example.mutex.v1.Example.Mutex\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &mutexRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// MutexWithAcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal to a example.mutex.v1.Example.Mutex workflow, starting it if necessary, and blocks until the workflow completes
func MutexWithAcquireLock(ctx workflow.Context, req *v1.MutexInput, signal *v1.AcquireLockInput, opts ...*MutexWorkflowOptions) error {
	run, err := MutexWithAcquireLockAsync(ctx, req, signal, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexWithAcquireLockAsync sends a(n) example.mutex.v1.Example.AcquireLock signal to a(n) example.mutex.v1.Example.Mutex workflow, starting it if necessary, and returns a handle to the underlying activity
func MutexWithAcquireLockAsync(ctx workflow.Context, req *v1.MutexInput, signal *v1.AcquireLockInput, opts ...*MutexWorkflowOptions) (MutexRun, error) {
	activityName := exampleOptions.filterActivity("example.mutex.v1.Example.MutexWithAcquireLock")
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", "example.mutex.v1.Example.MutexWithAcquireLock"),
			"Unimplemented",
			nil,
		)
	}

	opt := &MutexWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.MutexIdexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"example.mutex.v1.Example.Mutex\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	// marshal signal request protobuf message
	wsignal, err := anypb.New(signal)
	if err != nil {
		return nil, fmt.Errorf("error marshalling signal request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &mutexRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			Signal:               wsignal,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// SampleWorkflowWithMutexWorkflowOptions are used to configure a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow execution
type SampleWorkflowWithMutexWorkflowOptions struct {
	ActivityOptions      *workflow.ActivityOptions
	Detached             bool
	HeartbeatInterval    time.Duration
	ParentClosePolicy    enumsv1.ParentClosePolicy
	StartWorkflowOptions *client.StartWorkflowOptions
}

// NewSampleWorkflowWithMutexWorkflowOptions initializes a new SampleWorkflowWithMutexWorkflowOptions value
func NewSampleWorkflowWithMutexWorkflowOptions() *SampleWorkflowWithMutexWorkflowOptions {
	return &SampleWorkflowWithMutexWorkflowOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *SampleWorkflowWithMutexWorkflowOptions) WithActivityOptions(ao workflow.ActivityOptions) *SampleWorkflowWithMutexWorkflowOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithDetached can be used to start a workflow execution and exit immediately
func (opts *SampleWorkflowWithMutexWorkflowOptions) WithDetached(d bool) *SampleWorkflowWithMutexWorkflowOptions {
	opts.Detached = d
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *SampleWorkflowWithMutexWorkflowOptions) WithHeartbeatInterval(d time.Duration) *SampleWorkflowWithMutexWorkflowOptions {
	opts.HeartbeatInterval = d
	return opts
}

// WithParentClosePolicy can be used to customize the cancellation propagation behavior
func (opts *SampleWorkflowWithMutexWorkflowOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *SampleWorkflowWithMutexWorkflowOptions {
	opts.ParentClosePolicy = policy
	return opts
}

// WithStartWorkflowOptions can be used to customize the start workflow options
func (opts *SampleWorkflowWithMutexWorkflowOptions) WithStartWorkflow(swo client.StartWorkflowOptions) *SampleWorkflowWithMutexWorkflowOptions {
	opts.StartWorkflowOptions = &swo
	return opts
}

// SampleWorkflowWithMutexRun provides a handle to a example.mutex.v1.Example.SampleWorkflowWithMutex workflow execution
type SampleWorkflowWithMutexRun interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error

	// Future returns the inner workflow.Future
	Future() workflow.Future

	// Get returns the inner workflow.Future
	Get(workflow.Context) error

	// ID returns the workflow id
	ID() string

	// LockAcquired executes a(n) example.mutex.v1.Example.LockAcquired signal and blocks until completion
	LockAcquired(workflow.Context, *v1.LockAcquiredInput, ...*LockAcquiredSignalOptions) error

	// LockAcquiredAsync executes a(n) example.mutex.v1.Example.LockAcquired signal and returns a handle to the underlying activity
	LockAcquiredAsync(workflow.Context, *v1.LockAcquiredInput, ...*LockAcquiredSignalOptions) (LockAcquiredSignalHandle, error)
}

// sampleWorkflowWithMutexRun provides a(n) SampleWorkflowWithMutexRun implementation
type sampleWorkflowWithMutexRun struct {
	cancel func()
	future workflow.Future
	id     string
}

// Cancel the underlying workflow execution
func (r *sampleWorkflowWithMutexRun) Cancel(ctx workflow.Context) error {
	if r.cancel != nil {
		r.cancel()
		if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
			return err
		}
		return nil
	}
	return CancelExampleWorkflow(ctx, r.id, "")
}

// Future returns the underlying activity future
func (r *sampleWorkflowWithMutexRun) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion and returns the underlying workflow result
func (r *sampleWorkflowWithMutexRun) Get(ctx workflow.Context) error {
	if err := r.future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// ID returns the underlying workflow id
func (r *sampleWorkflowWithMutexRun) ID() string {
	return r.id
}

// LockAcquired executes a(n) example.mutex.v1.Example.LockAcquired signal and blocks until the underlying activity completes
func (r *sampleWorkflowWithMutexRun) LockAcquired(ctx workflow.Context, req *v1.LockAcquiredInput, opts ...*LockAcquiredSignalOptions) error {
	return LockAcquired(ctx, r.ID(), "", req, opts...)
}

// LockAcquiredAsync executes a(n) example.mutex.v1.Example.LockAcquired signal and returns a handle to the underlying activity
func (r *sampleWorkflowWithMutexRun) LockAcquiredAsync(ctx workflow.Context, req *v1.LockAcquiredInput, opts ...*LockAcquiredSignalOptions) (LockAcquiredSignalHandle, error) {
	return LockAcquiredAsync(ctx, r.ID(), "", req, opts...)
}

// SampleWorkflowWithMutex executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow and blocks until error or response is received
func SampleWorkflowWithMutex(ctx workflow.Context, req *v1.SampleWorkflowWithMutexInput, opts ...*SampleWorkflowWithMutexWorkflowOptions) error {
	run, err := SampleWorkflowWithMutexAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SampleWorkflowWithMutexAsync executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow and returns a handle to the underlying activity
func SampleWorkflowWithMutexAsync(ctx workflow.Context, req *v1.SampleWorkflowWithMutexInput, opts ...*SampleWorkflowWithMutexWorkflowOptions) (SampleWorkflowWithMutexRun, error) {
	activityName := exampleOptions.filterActivity(v1.SampleWorkflowWithMutexWorkflowName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.SampleWorkflowWithMutexWorkflowName),
			"Unimplemented",
			nil,
		)
	}

	opt := &SampleWorkflowWithMutexWorkflowOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}
	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 86400000000000 // 1 day
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// configure start workflow options
	wo := client.StartWorkflowOptions{}
	if opt.StartWorkflowOptions != nil {
		wo = *opt.StartWorkflowOptions
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := expression.EvalExpression(v1.SampleWorkflowWithMutexIdexpression, req.ProtoReflect())
			if err != nil {
				workflow.GetLogger(ctx).Error("error evaluating id expression for \"example.mutex.v1.Example.SampleWorkflowWithMutex\" workflow", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		if err := workflow.SideEffect(ctx, func(ctx workflow.Context) any {
			id, err := uuid.NewRandom()
			if err != nil {
				workflow.GetLogger(ctx).Error("error generating workflow id", "error", err)
				return nil
			}
			return id
		}).Get(&wo.ID); err != nil {
			return nil, err
		}
	}
	if wo.ID == "" {
		return nil, temporal.NewNonRetryableApplicationError("workflow id is required", "InvalidArgument", nil)
	}

	// marshal start workflow options protobuf message
	swo, err := xns.MarshalStartWorkflowOptions(wo)
	if err != nil {
		return nil, fmt.Errorf("error marshalling start workflow options: %w", err)
	}

	// marshal workflow request protobuf message
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	var parentClosePolicy temporalv1.ParentClosePolicy
	switch opt.ParentClosePolicy {
	case enumsv1.PARENT_CLOSE_POLICY_ABANDON:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_ABANDON
	case enumsv1.PARENT_CLOSE_POLICY_REQUEST_CANCEL:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL
	case enumsv1.PARENT_CLOSE_POLICY_TERMINATE:
		parentClosePolicy = temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &sampleWorkflowWithMutexRun{
		cancel: cancel,
		id:     wo.ID,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.WorkflowRequest{
			Detached:             opt.Detached,
			HeartbeatInterval:    durationpb.New(opt.HeartbeatInterval),
			ParentClosePolicy:    parentClosePolicy,
			Request:              wreq,
			StartWorkflowOptions: swo,
		}),
	}, nil
}

// AcquireLockSignalOptions are used to configure a(n) example.mutex.v1.Example.AcquireLock signal execution
type AcquireLockSignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewAcquireLockSignalOptions initializes a new AcquireLockSignalOptions value
func NewAcquireLockSignalOptions() *AcquireLockSignalOptions {
	return &AcquireLockSignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *AcquireLockSignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *AcquireLockSignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *AcquireLockSignalOptions) WithHeartbeatInterval(d time.Duration) *AcquireLockSignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// AcquireLockSignalHandle provides a handle for a example.mutex.v1.Example.AcquireLock signal activity
type AcquireLockSignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// acquireLockSignalHandle provides a(n) AcquireLockQueryHandle implementation
type acquireLockSignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *acquireLockSignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *acquireLockSignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *acquireLockSignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// AcquireLock executes a(n) example.mutex.v1.Example.AcquireLock signal
func AcquireLock(ctx workflow.Context, workflowID string, runID string, req *v1.AcquireLockInput, opts ...*AcquireLockSignalOptions) error {
	handle, err := AcquireLockAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// AcquireLockAsync executes a(n) example.mutex.v1.Example.AcquireLock signal
func AcquireLockAsync(ctx workflow.Context, workflowID string, runID string, req *v1.AcquireLockInput, opts ...*AcquireLockSignalOptions) (AcquireLockSignalHandle, error) {
	activityName := exampleOptions.filterActivity(v1.AcquireLockSignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.AcquireLockSignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &AcquireLockSignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &acquireLockSignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// LockAcquiredSignalOptions are used to configure a(n) example.mutex.v1.Example.LockAcquired signal execution
type LockAcquiredSignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewLockAcquiredSignalOptions initializes a new LockAcquiredSignalOptions value
func NewLockAcquiredSignalOptions() *LockAcquiredSignalOptions {
	return &LockAcquiredSignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *LockAcquiredSignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *LockAcquiredSignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *LockAcquiredSignalOptions) WithHeartbeatInterval(d time.Duration) *LockAcquiredSignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// LockAcquiredSignalHandle provides a handle for a example.mutex.v1.Example.LockAcquired signal activity
type LockAcquiredSignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// lockAcquiredSignalHandle provides a(n) LockAcquiredQueryHandle implementation
type lockAcquiredSignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *lockAcquiredSignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *lockAcquiredSignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *lockAcquiredSignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// LockAcquired executes a(n) example.mutex.v1.Example.LockAcquired signal
func LockAcquired(ctx workflow.Context, workflowID string, runID string, req *v1.LockAcquiredInput, opts ...*LockAcquiredSignalOptions) error {
	handle, err := LockAcquiredAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// LockAcquiredAsync executes a(n) example.mutex.v1.Example.LockAcquired signal
func LockAcquiredAsync(ctx workflow.Context, workflowID string, runID string, req *v1.LockAcquiredInput, opts ...*LockAcquiredSignalOptions) (LockAcquiredSignalHandle, error) {
	activityName := exampleOptions.filterActivity(v1.LockAcquiredSignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.LockAcquiredSignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &LockAcquiredSignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &lockAcquiredSignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// ReleaseLockSignalOptions are used to configure a(n) example.mutex.v1.Example.ReleaseLock signal execution
type ReleaseLockSignalOptions struct {
	ActivityOptions   *workflow.ActivityOptions
	HeartbeatInterval time.Duration
}

// NewReleaseLockSignalOptions initializes a new ReleaseLockSignalOptions value
func NewReleaseLockSignalOptions() *ReleaseLockSignalOptions {
	return &ReleaseLockSignalOptions{}
}

// WithActivityOptions can be used to customize the activity options
func (opts *ReleaseLockSignalOptions) WithActivityOptions(ao workflow.ActivityOptions) *ReleaseLockSignalOptions {
	opts.ActivityOptions = &ao
	return opts
}

// WithHeartbeatInterval can be used to customize the activity heartbeat interval
func (opts *ReleaseLockSignalOptions) WithHeartbeatInterval(d time.Duration) *ReleaseLockSignalOptions {
	opts.HeartbeatInterval = d
	return opts
}

// ReleaseLockSignalHandle provides a handle for a example.mutex.v1.Example.ReleaseLock signal activity
type ReleaseLockSignalHandle interface {
	// Cancel cancels the workflow
	Cancel(workflow.Context) error
	// Future returns the inner workflow.Future
	Future() workflow.Future
	// Get returns the inner workflow.Future
	Get(workflow.Context) error
}

// releaseLockSignalHandle provides a(n) ReleaseLockQueryHandle implementation
type releaseLockSignalHandle struct {
	cancel func()
	future workflow.Future
}

// Cancel the underlying signal activity
func (r *releaseLockSignalHandle) Cancel(ctx workflow.Context) error {
	r.cancel()
	if err := r.Get(ctx); err != nil && !errors.Is(err, workflow.ErrCanceled) {
		return err
	}
	return nil
}

// Future returns the underlying activity future
func (r *releaseLockSignalHandle) Future() workflow.Future {
	return r.future
}

// Get blocks on activity completion
func (r *releaseLockSignalHandle) Get(ctx workflow.Context) error {
	return r.future.Get(ctx, nil)
}

// ReleaseLock executes a(n) example.mutex.v1.Example.ReleaseLock signal
func ReleaseLock(ctx workflow.Context, workflowID string, runID string, req *v1.ReleaseLockInput, opts ...*ReleaseLockSignalOptions) error {
	handle, err := ReleaseLockAsync(ctx, workflowID, runID, req, opts...)
	if err != nil {
		return err
	}
	return handle.Get(ctx)
}

// ReleaseLockAsync executes a(n) example.mutex.v1.Example.ReleaseLock signal
func ReleaseLockAsync(ctx workflow.Context, workflowID string, runID string, req *v1.ReleaseLockInput, opts ...*ReleaseLockSignalOptions) (ReleaseLockSignalHandle, error) {
	activityName := exampleOptions.filterActivity(v1.ReleaseLockSignalName)
	if activityName == "" {
		return nil, temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("no activity registered for %s", v1.ReleaseLockSignalName),
			"Unimplemented",
			nil,
		)
	}

	opt := &ReleaseLockSignalOptions{}
	if len(opts) > 0 && opts[0] != nil {
		opt = opts[0]
	}

	if opt.HeartbeatInterval == 0 {
		opt.HeartbeatInterval = time.Second * 30
	}

	// configure activity options
	ao := workflow.GetActivityOptions(ctx)
	if opt.ActivityOptions != nil {
		ao = *opt.ActivityOptions
	}
	if ao.HeartbeatTimeout == 0 {
		ao.HeartbeatTimeout = opt.HeartbeatInterval * 2
	}
	// WaitForCancellation must be set otherwise the underlying workflow is not guaranteed to be canceled
	ao.WaitForCancellation = true

	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.ScheduleToCloseTimeout = 60000000000 // 1 minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)

	// marshal workflow request
	wreq, err := anypb.New(req)
	if err != nil {
		return nil, fmt.Errorf("error marshalling workflow request: %w", err)
	}

	ctx, cancel := workflow.WithCancel(ctx)
	return &releaseLockSignalHandle{
		cancel: cancel,
		future: workflow.ExecuteActivity(ctx, activityName, &xnsv1.SignalRequest{
			HeartbeatInterval: durationpb.New(opt.HeartbeatInterval),
			WorkflowId:        workflowID,
			RunId:             runID,
			Request:           wreq,
		}),
	}, nil
}

// CancelExampleWorkflow cancels an existing workflow
func CancelExampleWorkflow(ctx workflow.Context, workflowID string, runID string) error {
	return CancelExampleWorkflowAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// CancelExampleWorkflowAsync cancels an existing workflow
func CancelExampleWorkflowAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	activityName := exampleOptions.filterActivity("example.mutex.v1.Example.CancelWorkflow")
	if activityName == "" {
		f, s := workflow.NewFuture(ctx)
		s.SetError(temporal.NewNonRetryableApplicationError(
			"no activity registered for example.mutex.v1.Example.CancelWorkflow",
			"Unimplemented",
			nil,
		))
		return f
	}
	ao := workflow.GetActivityOptions(ctx)
	if ao.StartToCloseTimeout == 0 && ao.ScheduleToCloseTimeout == 0 {
		ao.StartToCloseTimeout = time.Minute
	}
	ctx = workflow.WithActivityOptions(ctx, ao)
	return workflow.ExecuteActivity(ctx, activityName, workflowID, runID)
}

// exampleActivities provides activities that can be used to interact with a(n) Example service's workflow, queries, signals, and updates across namespaces
type exampleActivities struct {
	client v1.ExampleClient
}

// CancelWorkflow cancels an existing workflow execution
func (a *exampleActivities) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return a.client.CancelWorkflow(ctx, workflowID, runID)
}

// Mutex executes a(n) example.mutex.v1.Example.Mutex workflow via an activity
func (a *exampleActivities) Mutex(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req v1.MutexInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.MutexInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.MutexRun
	run, err = a.client.MutexAsync(ctx, &req, v1.NewMutexOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return exampleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return exampleOptions.convertError(err)
					}
				}
				return exampleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return exampleOptions.convertError(err)
		}
	}
}

// MutexWithAcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal to a(n) example.mutex.v1.Example.Mutex workflow via an activity
func (a *exampleActivities) MutexWithAcquireLock(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req v1.MutexInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.MutexInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// unmarshal signal request
	var signal v1.AcquireLockInput
	if err := input.Signal.UnmarshalTo(&signal); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.AcquireLockInput", input.Signal.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.MutexRun
	run, err = a.client.MutexWithAcquireLockAsync(ctx, &req, &signal, v1.NewMutexOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return exampleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return exampleOptions.convertError(err)
					}
				}
				return exampleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return exampleOptions.convertError(err)
		}
	}
}

// SampleWorkflowWithMutex executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow via an activity
func (a *exampleActivities) SampleWorkflowWithMutex(ctx context.Context, input *xnsv1.WorkflowRequest) (err error) {
	// unmarshal workflow request
	var req v1.SampleWorkflowWithMutexInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling workflow request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.SampleWorkflowWithMutexInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}

	// initialize workflow execution
	var run v1.SampleWorkflowWithMutexRun
	run, err = a.client.SampleWorkflowWithMutexAsync(ctx, &req, v1.NewSampleWorkflowWithMutexOptions().WithStartWorkflowOptions(
		xns.UnmarshalStartWorkflowOptions(input.GetStartWorkflowOptions()),
	))
	if err != nil {
		return exampleOptions.convertError(err)
	}

	// exit early if detached enabled
	if input.GetDetached() {
		return nil
	}

	// otherwise, wait for execution to complete in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = run.Get(ctx)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 30
	}

	// heartbeat activity while waiting for workflow execution to complete
	for {
		select {
		// send heartbeats periodically
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx, run.ID())

		// return retryable error on worker close
		case <-activity.GetWorkerStopChannel(ctx):
			return temporal.NewApplicationError("worker is stopping", "WorkerStopped")

		// catch parent activity context cancellation. in most cases, this should indicate a
		// server-sent cancellation, but there's a non-zero possibility that this cancellation
		// is received due to the worker stopping, prior to detecting the closing of the worker
		// stop channel. to give us an opportunity to detect a cancellation stemming from the
		// worker closing, we again check to see if the worker stop channel is closed before
		// propagating the cancellation
		case <-ctx.Done():
			select {
			case <-activity.GetWorkerStopChannel(ctx):
				return temporal.NewApplicationError("worker is stopping", "WorkerStopped")
			default:
				parentClosePolicy := input.GetParentClosePolicy()
				if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL || parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_TERMINATE {
					disconnectedCtx, cancel := context.WithTimeout(context.Background(), time.Minute)
					defer cancel()
					if parentClosePolicy == temporalv1.ParentClosePolicy_PARENT_CLOSE_POLICY_REQUEST_CANCEL {
						err = run.Cancel(disconnectedCtx)
					} else {
						err = run.Terminate(disconnectedCtx, "xns activity cancellation received", "error", ctx.Err())
					}
					if err != nil {
						return exampleOptions.convertError(err)
					}
				}
				return exampleOptions.convertError(temporal.NewCanceledError(ctx.Err().Error()))
			}

		// handle workflow completion
		case <-doneCh:
			return exampleOptions.convertError(err)
		}
	}
}

// AcquireLock executes a(n) example.mutex.v1.Example.AcquireLock signal via an activity
func (a *exampleActivities) AcquireLock(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// unmarshal signal request
	var req v1.AcquireLockInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.AcquireLockInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.AcquireLock(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			exampleOptions.convertError(ctx.Err())
		case <-doneCh:
			return exampleOptions.convertError(err)
		}
	}
}

// LockAcquired executes a(n) example.mutex.v1.Example.LockAcquired signal via an activity
func (a *exampleActivities) LockAcquired(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// unmarshal signal request
	var req v1.LockAcquiredInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.LockAcquiredInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.LockAcquired(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			exampleOptions.convertError(ctx.Err())
		case <-doneCh:
			return exampleOptions.convertError(err)
		}
	}
}

// ReleaseLock executes a(n) example.mutex.v1.Example.ReleaseLock signal via an activity
func (a *exampleActivities) ReleaseLock(ctx context.Context, input *xnsv1.SignalRequest) (err error) {
	// unmarshal signal request
	var req v1.ReleaseLockInput
	if err := input.Request.UnmarshalTo(&req); err != nil {
		return exampleOptions.convertError(temporal.NewNonRetryableApplicationError(
			fmt.Sprintf("error unmarshalling signal request of type %s as github.com/cludden/protoc-gen-go-temporal/gen/example/mutex/v1.ReleaseLockInput", input.Request.GetTypeUrl()),
			"InvalidArgument",
			err,
		))
	}
	// execute signal in child goroutine
	doneCh := make(chan struct{})
	go func() {
		err = a.client.ReleaseLock(ctx, input.GetWorkflowId(), input.GetRunId(), &req)
		close(doneCh)
	}()

	heartbeatInterval := input.GetHeartbeatInterval().AsDuration()
	if heartbeatInterval == 0 {
		heartbeatInterval = time.Second * 10
	}

	// heartbeat activity while waiting for signal to complete
	for {
		select {
		case <-time.After(heartbeatInterval):
			activity.RecordHeartbeat(ctx)
		case <-ctx.Done():
			exampleOptions.convertError(ctx.Err())
		case <-doneCh:
			return exampleOptions.convertError(err)
		}
	}
}
