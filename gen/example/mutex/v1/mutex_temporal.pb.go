// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.10.2-next (cf7bb8abe8c16d8977887195eae0e5ba5b97300c)
//	go go1.21.5
//	protoc (unknown)
//
// source: example/mutex/v1/mutex.proto
package mutexv1

import (
	"context"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	"log/slog"
	"os"
	"sort"
	"time"
)

// ExampleTaskQueue is the default task-queue for a example.mutex.v1.Example worker
const ExampleTaskQueue = "mutex"

// example.mutex.v1.Example workflow names
const (
	MutexWorkflowName                   = "example.mutex.v1.Example.Mutex"
	SampleWorkflowWithMutexWorkflowName = "example.mutex.v1.Example.SampleWorkflowWithMutex"
)

// example.mutex.v1.Example workflow id expressions
var (
	MutexIdexpression                   = expression.MustParseExpression("mutex:${! resourceId }")
	SampleWorkflowWithMutexIdexpression = expression.MustParseExpression("SampleWorkflow1WithMutex_${! uuid_v4() }")
)

// example.mutex.v1.Example activity names
const (
	MutexActivityName = "example.mutex.v1.Example.Mutex"
)

// example.mutex.v1.Example signal names
const (
	AcquireLockSignalName  = "example.mutex.v1.Example.AcquireLock"
	LockAcquiredSignalName = "example.mutex.v1.Example.LockAcquired"
	ReleaseLockSignalName  = "example.mutex.v1.Example.ReleaseLock"
)

// ExampleClient describes a client for a(n) example.mutex.v1.Example worker
type ExampleClient interface {
	// Mutex executes a(n) example.mutex.v1.Example.Mutex workflow and blocks until error or response received
	Mutex(ctx context.Context, req *MutexInput, opts ...*MutexOptions) error

	// MutexAsync starts a(n) example.mutex.v1.Example.Mutex workflow and returns a handle to the workflow run
	MutexAsync(ctx context.Context, req *MutexInput, opts ...*MutexOptions) (MutexRun, error)

	// GetMutex retrieves a handle to an existing example.mutex.v1.Example.Mutex workflow execution
	GetMutex(ctx context.Context, workflowID string, runID string) MutexRun

	// MutexWithAcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal to a(n) example.mutex.v1.Example.Mutex workflow, starting it if necessary, and blocks until workflow completion
	MutexWithAcquireLock(ctx context.Context, req *MutexInput, signal *AcquireLockInput, opts ...*MutexOptions) error

	// MutexWithAcquireLockAsync sends a(n) example.mutex.v1.Example.AcquireLock signal to a(n) example.mutex.v1.Example.Mutex workflow, starting it if necessary, and returns a handle to the workflow execution
	MutexWithAcquireLockAsync(ctx context.Context, req *MutexInput, signal *AcquireLockInput, opts ...*MutexOptions) (MutexRun, error)

	// SampleWorkflowWithMutex executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow and blocks until error or response received
	SampleWorkflowWithMutex(ctx context.Context, req *SampleWorkflowWithMutexInput, opts ...*SampleWorkflowWithMutexOptions) error

	// SampleWorkflowWithMutexAsync starts a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow and returns a handle to the workflow run
	SampleWorkflowWithMutexAsync(ctx context.Context, req *SampleWorkflowWithMutexInput, opts ...*SampleWorkflowWithMutexOptions) (SampleWorkflowWithMutexRun, error)

	// GetSampleWorkflowWithMutex retrieves a handle to an existing example.mutex.v1.Example.SampleWorkflowWithMutex workflow execution
	GetSampleWorkflowWithMutex(ctx context.Context, workflowID string, runID string) SampleWorkflowWithMutexRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// example.mutex.v1.Example.AcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal
	AcquireLock(ctx context.Context, workflowID string, runID string, signal *AcquireLockInput) error

	// example.mutex.v1.Example.LockAcquired sends a(n) example.mutex.v1.Example.LockAcquired signal
	LockAcquired(ctx context.Context, workflowID string, runID string, signal *LockAcquiredInput) error

	// example.mutex.v1.Example.ReleaseLock sends a(n) example.mutex.v1.Example.ReleaseLock signal
	ReleaseLock(ctx context.Context, workflowID string, runID string, signal *ReleaseLockInput) error
}

// exampleClient implements a temporal client for a example.mutex.v1.Example service
type exampleClient struct {
	client client.Client
	log    *slog.Logger
}

// NewExampleClient initializes a new example.mutex.v1.Example client
func NewExampleClient(c client.Client, options ...*exampleClientOptions) ExampleClient {
	var cfg *exampleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewExampleClientOptions()
	}
	return &exampleClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewExampleClientWithOptions initializes a new Example client with the given options
func NewExampleClientWithOptions(c client.Client, opts client.Options, options ...*exampleClientOptions) (ExampleClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *exampleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewExampleClientOptions()
	}
	return &exampleClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// exampleClientOptions describes optional runtime configuration for a ExampleClient
type exampleClientOptions struct {
	log *slog.Logger
}

// NewExampleClientOptions initializes a new exampleClientOptions value
func NewExampleClientOptions() *exampleClientOptions {
	return &exampleClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *exampleClientOptions) WithLogger(l *slog.Logger) *exampleClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *exampleClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.mutex.v1.Example.Mutex executes a example.mutex.v1.Example.Mutex workflow and blocks until error or response received
func (c *exampleClient) Mutex(ctx context.Context, req *MutexInput, options ...*MutexOptions) error {
	run, err := c.MutexAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexAsync starts a(n) example.mutex.v1.Example.Mutex workflow and returns a handle to the workflow run
func (c *exampleClient) MutexAsync(ctx context.Context, req *MutexInput, options ...*MutexOptions) (MutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(MutexIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for \"Mutex\" workflow: %w", err)
		}
		opts.ID = id
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    1000000000,
			MaximumInterval:    60000000000,
			BackoffCoefficient: 2.0,
			MaximumAttempts:    int32(5),
		}
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, MutexWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &mutexRun{
		client: c,
		run:    run,
	}, nil
}

// GetMutex fetches an existing example.mutex.v1.Example.Mutex execution
func (c *exampleClient) GetMutex(ctx context.Context, workflowID string, runID string) MutexRun {
	return &mutexRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// MutexWithAcquireLock starts a(n) example.mutex.v1.Example.Mutex workflow and sends a(n) example.mutex.v1.Example.AcquireLock signal in a transaction
func (c *exampleClient) MutexWithAcquireLock(ctx context.Context, req *MutexInput, signal *AcquireLockInput, options ...*MutexOptions) error {
	run, err := c.MutexWithAcquireLockAsync(ctx, req, signal, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexWithAcquireLockAsync starts a(n) example.mutex.v1.Example.Mutex workflow and sends a(n) example.mutex.v1.Example.AcquireLock signal in a transaction
func (c *exampleClient) MutexWithAcquireLockAsync(ctx context.Context, req *MutexInput, signal *AcquireLockInput, options ...*MutexOptions) (MutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(MutexIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for \"Mutex\" workflow: %w", err)
		}
		opts.ID = id
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    1000000000,
			MaximumInterval:    60000000000,
			BackoffCoefficient: 2.0,
			MaximumAttempts:    int32(5),
		}
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, AcquireLockSignalName, signal, *opts, MutexWorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &mutexRun{
		client: c,
		run:    run,
	}, nil
}

// example.mutex.v1.Example.SampleWorkflowWithMutex executes a example.mutex.v1.Example.SampleWorkflowWithMutex workflow and blocks until error or response received
func (c *exampleClient) SampleWorkflowWithMutex(ctx context.Context, req *SampleWorkflowWithMutexInput, options ...*SampleWorkflowWithMutexOptions) error {
	run, err := c.SampleWorkflowWithMutexAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SampleWorkflowWithMutexAsync starts a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow and returns a handle to the workflow run
func (c *exampleClient) SampleWorkflowWithMutexAsync(ctx context.Context, req *SampleWorkflowWithMutexInput, options ...*SampleWorkflowWithMutexOptions) (SampleWorkflowWithMutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SampleWorkflowWithMutexIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for \"SampleWorkflowWithMutex\" workflow: %w", err)
		}
		opts.ID = id
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, SampleWorkflowWithMutexWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &sampleWorkflowWithMutexRun{
		client: c,
		run:    run,
	}, nil
}

// GetSampleWorkflowWithMutex fetches an existing example.mutex.v1.Example.SampleWorkflowWithMutex execution
func (c *exampleClient) GetSampleWorkflowWithMutex(ctx context.Context, workflowID string, runID string) SampleWorkflowWithMutexRun {
	return &sampleWorkflowWithMutexRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *exampleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *exampleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// example.mutex.v1.Example.AcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal to an existing workflow
func (c *exampleClient) AcquireLock(ctx context.Context, workflowID string, runID string, signal *AcquireLockInput) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, AcquireLockSignalName, signal)
}

// example.mutex.v1.Example.LockAcquired sends a(n) example.mutex.v1.Example.LockAcquired signal to an existing workflow
func (c *exampleClient) LockAcquired(ctx context.Context, workflowID string, runID string, signal *LockAcquiredInput) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, LockAcquiredSignalName, signal)
}

// example.mutex.v1.Example.ReleaseLock sends a(n) example.mutex.v1.Example.ReleaseLock signal to an existing workflow
func (c *exampleClient) ReleaseLock(ctx context.Context, workflowID string, runID string, signal *ReleaseLockInput) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, ReleaseLockSignalName, signal)
}

// MutexOptions provides configuration for a example.mutex.v1.Example.Mutex workflow operation
type MutexOptions struct {
	opts *client.StartWorkflowOptions
}

// NewMutexOptions initializes a new MutexOptions value
func NewMutexOptions() *MutexOptions {
	return &MutexOptions{}
}

// WithStartWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *MutexOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *MutexOptions {
	opts.opts = &options
	return opts
}

// MutexRun describes a(n) example.mutex.v1.Example.Mutex workflow run
type MutexRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// example.mutex.v1.Example.AcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal
	AcquireLock(ctx context.Context, req *AcquireLockInput) error

	// example.mutex.v1.Example.ReleaseLock sends a(n) example.mutex.v1.Example.ReleaseLock signal
	ReleaseLock(ctx context.Context, req *ReleaseLockInput) error
}

// mutexRun provides an internal implementation of a(n) MutexRunRun
type mutexRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *mutexRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *mutexRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *mutexRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *mutexRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *mutexRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *mutexRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// example.mutex.v1.Example.AcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal
func (r *mutexRun) AcquireLock(ctx context.Context, req *AcquireLockInput) error {
	return r.client.AcquireLock(ctx, r.ID(), "", req)
}

// example.mutex.v1.Example.ReleaseLock sends a(n) example.mutex.v1.Example.ReleaseLock signal
func (r *mutexRun) ReleaseLock(ctx context.Context, req *ReleaseLockInput) error {
	return r.client.ReleaseLock(ctx, r.ID(), "", req)
}

// SampleWorkflowWithMutexOptions provides configuration for a example.mutex.v1.Example.SampleWorkflowWithMutex workflow operation
type SampleWorkflowWithMutexOptions struct {
	opts *client.StartWorkflowOptions
}

// NewSampleWorkflowWithMutexOptions initializes a new SampleWorkflowWithMutexOptions value
func NewSampleWorkflowWithMutexOptions() *SampleWorkflowWithMutexOptions {
	return &SampleWorkflowWithMutexOptions{}
}

// WithStartWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SampleWorkflowWithMutexOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SampleWorkflowWithMutexOptions {
	opts.opts = &options
	return opts
}

// SampleWorkflowWithMutexRun describes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow run
type SampleWorkflowWithMutexRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// example.mutex.v1.Example.LockAcquired sends a(n) example.mutex.v1.Example.LockAcquired signal
	LockAcquired(ctx context.Context, req *LockAcquiredInput) error
}

// sampleWorkflowWithMutexRun provides an internal implementation of a(n) SampleWorkflowWithMutexRunRun
type sampleWorkflowWithMutexRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *sampleWorkflowWithMutexRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *sampleWorkflowWithMutexRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *sampleWorkflowWithMutexRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *sampleWorkflowWithMutexRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *sampleWorkflowWithMutexRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *sampleWorkflowWithMutexRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// example.mutex.v1.Example.LockAcquired sends a(n) example.mutex.v1.Example.LockAcquired signal
func (r *sampleWorkflowWithMutexRun) LockAcquired(ctx context.Context, req *LockAcquiredInput) error {
	return r.client.LockAcquired(ctx, r.ID(), "", req)
}

// Reference to generated workflow functions
var (
	// MutexFunction implements a "MutexWorkflow" workflow
	MutexFunction func(workflow.Context, *MutexInput) error
	// SampleWorkflowWithMutexFunction implements a "SampleWorkflowWithMutexWorkflow" workflow
	SampleWorkflowWithMutexFunction func(workflow.Context, *SampleWorkflowWithMutexInput) error
)

// ExampleWorkflows provides methods for initializing new example.mutex.v1.Example workflow values
type ExampleWorkflows interface {
	// example.mutex.v1.Example.Mutex initializes a new a(n) MutexWorkflow implementation
	Mutex(ctx workflow.Context, input *MutexWorkflowInput) (MutexWorkflow, error)

	// example.mutex.v1.Example.SampleWorkflowWithMutex initializes a new a(n) SampleWorkflowWithMutexWorkflow implementation
	SampleWorkflowWithMutex(ctx workflow.Context, input *SampleWorkflowWithMutexWorkflowInput) (SampleWorkflowWithMutexWorkflow, error)
}

// RegisterExampleWorkflows registers example.mutex.v1.Example workflows with the given worker
func RegisterExampleWorkflows(r worker.WorkflowRegistry, workflows ExampleWorkflows) {
	RegisterMutexWorkflow(r, workflows.Mutex)
	RegisterSampleWorkflowWithMutexWorkflow(r, workflows.SampleWorkflowWithMutex)
}

// RegisterMutexWorkflow registers a example.mutex.v1.Example.Mutex workflow with the given worker
func RegisterMutexWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *MutexWorkflowInput) (MutexWorkflow, error)) {
	MutexFunction = buildMutex(wf)
	r.RegisterWorkflowWithOptions(MutexFunction, workflow.RegisterOptions{Name: MutexWorkflowName})
}

// buildMutex converts a Mutex workflow struct into a valid workflow function
func buildMutex(ctor func(workflow.Context, *MutexWorkflowInput) (MutexWorkflow, error)) func(workflow.Context, *MutexInput) error {
	return func(ctx workflow.Context, req *MutexInput) error {
		input := &MutexWorkflowInput{
			Req: req,
			AcquireLock: &AcquireLockSignal{
				Channel: workflow.GetSignalChannel(ctx, AcquireLockSignalName),
			},
			ReleaseLock: &ReleaseLockSignal{
				Channel: workflow.GetSignalChannel(ctx, ReleaseLockSignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// MutexWorkflowInput describes the input to a(n) example.mutex.v1.Example.Mutex workflow constructor
type MutexWorkflowInput struct {
	Req         *MutexInput
	AcquireLock *AcquireLockSignal
	ReleaseLock *ReleaseLockSignal
}

// MutexWorkflow describes a(n) example.mutex.v1.Example.Mutex workflow implementation
//
// workflow details: (id: "mutex:${! resourceId }")
type MutexWorkflow interface {
	// Execute defines the entrypoint to a(n) example.mutex.v1.Example.Mutex workflow
	Execute(ctx workflow.Context) error
}

// MutexChild executes a child example.mutex.v1.Example.Mutex workflow and blocks until error or response received
func MutexChild(ctx workflow.Context, req *MutexInput, options ...*MutexChildOptions) error {
	childRun, err := MutexChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// MutexChildAsync starts a child example.mutex.v1.Example.Mutex workflow and returns a handle to the child workflow run
func MutexChildAsync(ctx workflow.Context, req *MutexInput, options ...*MutexChildOptions) (*MutexChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(MutexIdexpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    1000000000,
			MaximumInterval:    60000000000,
			BackoffCoefficient: 2.0,
			MaximumAttempts:    int32(5),
		}
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &MutexChildRun{Future: workflow.ExecuteChildWorkflow(ctx, MutexWorkflowName, req)}, nil
}

// MutexChildOptions provides configuration for a example.mutex.v1.Example.Mutex workflow operation
type MutexChildOptions struct {
	opts *workflow.ChildWorkflowOptions
}

// NewMutexChildOptions initializes a new MutexChildOptions value
func NewMutexChildOptions() *MutexChildOptions {
	return &MutexChildOptions{}
}

// WithChildWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *MutexChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *MutexChildOptions {
	opts.opts = &options
	return opts
}

// MutexChildRun describes a child Mutex workflow run
type MutexChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *MutexChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *MutexChildRun) Select(sel workflow.Selector, fn func(*MutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *MutexChildRun) SelectStart(sel workflow.Selector, fn func(*MutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *MutexChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// AcquireLock sends a(n) "example.mutex.v1.Example.AcquireLock" signal request to the child workflow
func (r *MutexChildRun) AcquireLock(ctx workflow.Context, input *AcquireLockInput) error {
	return r.AcquireLockAsync(ctx, input).Get(ctx, nil)
}

// AcquireLockAsync sends a(n) "example.mutex.v1.Example.AcquireLock" signal request to the child workflow
func (r *MutexChildRun) AcquireLockAsync(ctx workflow.Context, input *AcquireLockInput) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, AcquireLockSignalName, input)
}

// ReleaseLock sends a(n) "example.mutex.v1.Example.ReleaseLock" signal request to the child workflow
func (r *MutexChildRun) ReleaseLock(ctx workflow.Context, input *ReleaseLockInput) error {
	return r.ReleaseLockAsync(ctx, input).Get(ctx, nil)
}

// ReleaseLockAsync sends a(n) "example.mutex.v1.Example.ReleaseLock" signal request to the child workflow
func (r *MutexChildRun) ReleaseLockAsync(ctx workflow.Context, input *ReleaseLockInput) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, ReleaseLockSignalName, input)
}

// RegisterSampleWorkflowWithMutexWorkflow registers a example.mutex.v1.Example.SampleWorkflowWithMutex workflow with the given worker
func RegisterSampleWorkflowWithMutexWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SampleWorkflowWithMutexWorkflowInput) (SampleWorkflowWithMutexWorkflow, error)) {
	SampleWorkflowWithMutexFunction = buildSampleWorkflowWithMutex(wf)
	r.RegisterWorkflowWithOptions(SampleWorkflowWithMutexFunction, workflow.RegisterOptions{Name: SampleWorkflowWithMutexWorkflowName})
}

// buildSampleWorkflowWithMutex converts a SampleWorkflowWithMutex workflow struct into a valid workflow function
func buildSampleWorkflowWithMutex(ctor func(workflow.Context, *SampleWorkflowWithMutexWorkflowInput) (SampleWorkflowWithMutexWorkflow, error)) func(workflow.Context, *SampleWorkflowWithMutexInput) error {
	return func(ctx workflow.Context, req *SampleWorkflowWithMutexInput) error {
		input := &SampleWorkflowWithMutexWorkflowInput{
			Req: req,
			LockAcquired: &LockAcquiredSignal{
				Channel: workflow.GetSignalChannel(ctx, LockAcquiredSignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// SampleWorkflowWithMutexWorkflowInput describes the input to a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow constructor
type SampleWorkflowWithMutexWorkflowInput struct {
	Req          *SampleWorkflowWithMutexInput
	LockAcquired *LockAcquiredSignal
}

// SampleWorkflowWithMutexWorkflow describes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow implementation
//
// workflow details: (id: "SampleWorkflow1WithMutex_${! uuid_v4() }")
type SampleWorkflowWithMutexWorkflow interface {
	// Execute defines the entrypoint to a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow
	Execute(ctx workflow.Context) error
}

// SampleWorkflowWithMutexChild executes a child example.mutex.v1.Example.SampleWorkflowWithMutex workflow and blocks until error or response received
func SampleWorkflowWithMutexChild(ctx workflow.Context, req *SampleWorkflowWithMutexInput, options ...*SampleWorkflowWithMutexChildOptions) error {
	childRun, err := SampleWorkflowWithMutexChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// SampleWorkflowWithMutexChildAsync starts a child example.mutex.v1.Example.SampleWorkflowWithMutex workflow and returns a handle to the child workflow run
func SampleWorkflowWithMutexChildAsync(ctx workflow.Context, req *SampleWorkflowWithMutexInput, options ...*SampleWorkflowWithMutexChildOptions) (*SampleWorkflowWithMutexChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(SampleWorkflowWithMutexIdexpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &SampleWorkflowWithMutexChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SampleWorkflowWithMutexWorkflowName, req)}, nil
}

// SampleWorkflowWithMutexChildOptions provides configuration for a example.mutex.v1.Example.SampleWorkflowWithMutex workflow operation
type SampleWorkflowWithMutexChildOptions struct {
	opts *workflow.ChildWorkflowOptions
}

// NewSampleWorkflowWithMutexChildOptions initializes a new SampleWorkflowWithMutexChildOptions value
func NewSampleWorkflowWithMutexChildOptions() *SampleWorkflowWithMutexChildOptions {
	return &SampleWorkflowWithMutexChildOptions{}
}

// WithChildWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SampleWorkflowWithMutexChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SampleWorkflowWithMutexChildOptions {
	opts.opts = &options
	return opts
}

// SampleWorkflowWithMutexChildRun describes a child SampleWorkflowWithMutex workflow run
type SampleWorkflowWithMutexChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SampleWorkflowWithMutexChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SampleWorkflowWithMutexChildRun) Select(sel workflow.Selector, fn func(*SampleWorkflowWithMutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SampleWorkflowWithMutexChildRun) SelectStart(sel workflow.Selector, fn func(*SampleWorkflowWithMutexChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SampleWorkflowWithMutexChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// LockAcquired sends a(n) "example.mutex.v1.Example.LockAcquired" signal request to the child workflow
func (r *SampleWorkflowWithMutexChildRun) LockAcquired(ctx workflow.Context, input *LockAcquiredInput) error {
	return r.LockAcquiredAsync(ctx, input).Get(ctx, nil)
}

// LockAcquiredAsync sends a(n) "example.mutex.v1.Example.LockAcquired" signal request to the child workflow
func (r *SampleWorkflowWithMutexChildRun) LockAcquiredAsync(ctx workflow.Context, input *LockAcquiredInput) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, LockAcquiredSignalName, input)
}

// AcquireLockSignal describes a(n) example.mutex.v1.Example.AcquireLock signal
type AcquireLockSignal struct {
	Channel workflow.ReceiveChannel
}

// NewAcquireLockSignal initializes a new example.mutex.v1.Example.AcquireLock signal wrapper
func NewAcquireLockSignal(ctx workflow.Context) *AcquireLockSignal {
	return &AcquireLockSignal{Channel: workflow.GetSignalChannel(ctx, AcquireLockSignalName)}
}

// Receive blocks until a(n) example.mutex.v1.Example.AcquireLock signal is received
func (s *AcquireLockSignal) Receive(ctx workflow.Context) (*AcquireLockInput, bool) {
	var resp AcquireLockInput
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a example.mutex.v1.Example.AcquireLock signal without blocking
func (s *AcquireLockSignal) ReceiveAsync() *AcquireLockInput {
	var resp AcquireLockInput
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) example.mutex.v1.Example.AcquireLock signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *AcquireLockSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *AcquireLockInput, ok bool, more bool) {
	resp = &AcquireLockInput{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) example.mutex.v1.Example.AcquireLock signal without blocking
func (s *AcquireLockSignal) Select(sel workflow.Selector, fn func(*AcquireLockInput)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// AcquireLockExternal sends a(n) example.mutex.v1.Example.AcquireLock signal to an existing workflow
func AcquireLockExternal(ctx workflow.Context, workflowID string, runID string, req *AcquireLockInput) error {
	return AcquireLockExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// AcquireLockExternalAsync sends a(n) example.mutex.v1.Example.AcquireLock signal to an existing workflow
func AcquireLockExternalAsync(ctx workflow.Context, workflowID string, runID string, req *AcquireLockInput) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, AcquireLockSignalName, req)
}

// LockAcquiredSignal describes a(n) example.mutex.v1.Example.LockAcquired signal
type LockAcquiredSignal struct {
	Channel workflow.ReceiveChannel
}

// NewLockAcquiredSignal initializes a new example.mutex.v1.Example.LockAcquired signal wrapper
func NewLockAcquiredSignal(ctx workflow.Context) *LockAcquiredSignal {
	return &LockAcquiredSignal{Channel: workflow.GetSignalChannel(ctx, LockAcquiredSignalName)}
}

// Receive blocks until a(n) example.mutex.v1.Example.LockAcquired signal is received
func (s *LockAcquiredSignal) Receive(ctx workflow.Context) (*LockAcquiredInput, bool) {
	var resp LockAcquiredInput
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a example.mutex.v1.Example.LockAcquired signal without blocking
func (s *LockAcquiredSignal) ReceiveAsync() *LockAcquiredInput {
	var resp LockAcquiredInput
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) example.mutex.v1.Example.LockAcquired signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *LockAcquiredSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *LockAcquiredInput, ok bool, more bool) {
	resp = &LockAcquiredInput{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) example.mutex.v1.Example.LockAcquired signal without blocking
func (s *LockAcquiredSignal) Select(sel workflow.Selector, fn func(*LockAcquiredInput)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// LockAcquiredExternal sends a(n) example.mutex.v1.Example.LockAcquired signal to an existing workflow
func LockAcquiredExternal(ctx workflow.Context, workflowID string, runID string, req *LockAcquiredInput) error {
	return LockAcquiredExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// LockAcquiredExternalAsync sends a(n) example.mutex.v1.Example.LockAcquired signal to an existing workflow
func LockAcquiredExternalAsync(ctx workflow.Context, workflowID string, runID string, req *LockAcquiredInput) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, LockAcquiredSignalName, req)
}

// ReleaseLockSignal describes a(n) example.mutex.v1.Example.ReleaseLock signal
type ReleaseLockSignal struct {
	Channel workflow.ReceiveChannel
}

// NewReleaseLockSignal initializes a new example.mutex.v1.Example.ReleaseLock signal wrapper
func NewReleaseLockSignal(ctx workflow.Context) *ReleaseLockSignal {
	return &ReleaseLockSignal{Channel: workflow.GetSignalChannel(ctx, ReleaseLockSignalName)}
}

// Receive blocks until a(n) example.mutex.v1.Example.ReleaseLock signal is received
func (s *ReleaseLockSignal) Receive(ctx workflow.Context) (*ReleaseLockInput, bool) {
	var resp ReleaseLockInput
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a example.mutex.v1.Example.ReleaseLock signal without blocking
func (s *ReleaseLockSignal) ReceiveAsync() *ReleaseLockInput {
	var resp ReleaseLockInput
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) example.mutex.v1.Example.ReleaseLock signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *ReleaseLockSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *ReleaseLockInput, ok bool, more bool) {
	resp = &ReleaseLockInput{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) example.mutex.v1.Example.ReleaseLock signal without blocking
func (s *ReleaseLockSignal) Select(sel workflow.Selector, fn func(*ReleaseLockInput)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// ReleaseLockExternal sends a(n) example.mutex.v1.Example.ReleaseLock signal to an existing workflow
func ReleaseLockExternal(ctx workflow.Context, workflowID string, runID string, req *ReleaseLockInput) error {
	return ReleaseLockExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// ReleaseLockExternalAsync sends a(n) example.mutex.v1.Example.ReleaseLock signal to an existing workflow
func ReleaseLockExternalAsync(ctx workflow.Context, workflowID string, runID string, req *ReleaseLockInput) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, ReleaseLockSignalName, req)
}

// ExampleActivities describes available worker activities
type ExampleActivities interface {
	// example.mutex.v1.Example.Mutex implements a(n) example.mutex.v1.Example.Mutex activity definition
	Mutex(ctx context.Context, req *MutexInput) error
}

// RegisterExampleActivities registers activities with a worker
func RegisterExampleActivities(r worker.ActivityRegistry, activities ExampleActivities) {
	RegisterMutexActivity(r, activities.Mutex)
}

// RegisterMutexActivity registers a example.mutex.v1.Example.Mutex activity
func RegisterMutexActivity(r worker.ActivityRegistry, fn func(context.Context, *MutexInput) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: MutexActivityName,
	})
}

// MutexFuture describes a(n) example.mutex.v1.Example.Mutex activity execution
type MutexFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *MutexFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *MutexFuture) Select(sel workflow.Selector, fn func(*MutexFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Mutex executes a(n) example.mutex.v1.Example.Mutex activity
func Mutex(ctx workflow.Context, req *MutexInput, options ...*MutexActivityOptions) error {
	var opts *MutexActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewMutexActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = MutexActivityName
	future := &MutexFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// MutexAsync executes a(n) example.mutex.v1.Example.Mutex activity (asynchronously)
func MutexAsync(ctx workflow.Context, req *MutexInput, options ...*MutexActivityOptions) *MutexFuture {
	var opts *MutexActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewMutexActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = MutexActivityName
	future := &MutexFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// MutexLocal executes a(n) example.mutex.v1.Example.Mutex activity (locally)
func MutexLocal(ctx workflow.Context, req *MutexInput, options ...*MutexLocalActivityOptions) error {
	var opts *MutexLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewMutexLocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = MutexActivityName
	}
	future := &MutexFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// MutexLocalAsync executes a(n) example.mutex.v1.Example.Mutex activity (asynchronously, locally)
func MutexLocalAsync(ctx workflow.Context, req *MutexInput, options ...*MutexLocalActivityOptions) *MutexFuture {
	var opts *MutexLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewMutexLocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = MutexActivityName
	}
	future := &MutexFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// MutexLocalActivityOptions provides configuration for a local example.mutex.v1.Example.Mutex activity
type MutexLocalActivityOptions struct {
	fn   func(context.Context, *MutexInput) error
	opts *workflow.LocalActivityOptions
}

// NewMutexLocalActivityOptions sets default LocalActivityOptions
func NewMutexLocalActivityOptions() *MutexLocalActivityOptions {
	return &MutexLocalActivityOptions{}
}

// Local provides a local example.mutex.v1.Example.Mutex activity implementation
func (opts *MutexLocalActivityOptions) Local(fn func(context.Context, *MutexInput) error) *MutexLocalActivityOptions {
	opts.fn = fn
	return opts
}

// WithLocalActivityOptions sets default LocalActivityOptions
func (opts *MutexLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *MutexLocalActivityOptions {
	opts.opts = &options
	return opts
}

// MutexActivityOptions provides configuration for a(n) example.mutex.v1.Example.Mutex activity
type MutexActivityOptions struct {
	opts *workflow.ActivityOptions
}

// NewMutexActivityOptions sets default ActivityOptions
func NewMutexActivityOptions() *MutexActivityOptions {
	return &MutexActivityOptions{}
}

// WithActivityOptions sets default ActivityOptions
func (opts *MutexActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *MutexActivityOptions {
	opts.opts = &options
	return opts
}

// TestClient provides a testsuite-compatible Client
type TestExampleClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ExampleWorkflows
}

var _ ExampleClient = &TestExampleClient{}

// NewTestExampleClient initializes a new TestExampleClient value
func NewTestExampleClient(env *testsuite.TestWorkflowEnvironment, workflows ExampleWorkflows, activities ExampleActivities) *TestExampleClient {
	if workflows != nil {
		RegisterExampleWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterExampleActivities(env, activities)
	}
	return &TestExampleClient{env, workflows}
}

// Mutex executes a(n) example.mutex.v1.Example.Mutex workflow in the test environment
func (c *TestExampleClient) Mutex(ctx context.Context, req *MutexInput, opts ...*MutexOptions) error {
	run, err := c.MutexAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// MutexAsync executes a(n) example.mutex.v1.Example.Mutex workflow in the test environment
func (c *TestExampleClient) MutexAsync(ctx context.Context, req *MutexInput, options ...*MutexOptions) (MutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(MutexIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for \"Mutex\" workflow: %w", err)
		}
		opts.ID = id
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{
			InitialInterval:    1000000000,
			MaximumInterval:    60000000000,
			BackoffCoefficient: 2.0,
			MaximumAttempts:    int32(5),
		}
	}
	return &testMutexRun{client: c, env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetMutex is a noop
func (c *TestExampleClient) GetMutex(ctx context.Context, workflowID string, runID string) MutexRun {
	return &testMutexRun{env: c.env, workflows: c.workflows}
}

// MutexWithAcquireLock sends a(n) example.mutex.v1.Example.AcquireLock signal to a(n) example.mutex.v1.Example.Mutex workflow, starting it if necessary
func (c *TestExampleClient) MutexWithAcquireLock(ctx context.Context, req *MutexInput, signal *AcquireLockInput, opts ...*MutexOptions) error {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(AcquireLockSignalName, signal)
	}, 0)
	return c.Mutex(ctx, req, opts...)
}

// MutexWithAcquireLockAsync sends a(n) example.mutex.v1.Example.AcquireLock signal to a(n) example.mutex.v1.Example.Mutex workflow, starting it if necessary
func (c *TestExampleClient) MutexWithAcquireLockAsync(ctx context.Context, req *MutexInput, signal *AcquireLockInput, opts ...*MutexOptions) (MutexRun, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.AcquireLock(ctx, "", "", signal)
	}, 0)
	return c.MutexAsync(ctx, req, opts...)
}

// SampleWorkflowWithMutex executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow in the test environment
func (c *TestExampleClient) SampleWorkflowWithMutex(ctx context.Context, req *SampleWorkflowWithMutexInput, opts ...*SampleWorkflowWithMutexOptions) error {
	run, err := c.SampleWorkflowWithMutexAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SampleWorkflowWithMutexAsync executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow in the test environment
func (c *TestExampleClient) SampleWorkflowWithMutexAsync(ctx context.Context, req *SampleWorkflowWithMutexInput, options ...*SampleWorkflowWithMutexOptions) (SampleWorkflowWithMutexRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SampleWorkflowWithMutexIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for \"SampleWorkflowWithMutex\" workflow: %w", err)
		}
		opts.ID = id
	}
	return &testSampleWorkflowWithMutexRun{client: c, env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetSampleWorkflowWithMutex is a noop
func (c *TestExampleClient) GetSampleWorkflowWithMutex(ctx context.Context, workflowID string, runID string) SampleWorkflowWithMutexRun {
	return &testSampleWorkflowWithMutexRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestExampleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestExampleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// AcquireLock executes a example.mutex.v1.Example.AcquireLock signal
func (c *TestExampleClient) AcquireLock(ctx context.Context, workflowID string, runID string, req *AcquireLockInput) error {
	c.env.SignalWorkflow(AcquireLockSignalName, req)
	return nil
}

// LockAcquired executes a example.mutex.v1.Example.LockAcquired signal
func (c *TestExampleClient) LockAcquired(ctx context.Context, workflowID string, runID string, req *LockAcquiredInput) error {
	c.env.SignalWorkflow(LockAcquiredSignalName, req)
	return nil
}

// ReleaseLock executes a example.mutex.v1.Example.ReleaseLock signal
func (c *TestExampleClient) ReleaseLock(ctx context.Context, workflowID string, runID string, req *ReleaseLockInput) error {
	c.env.SignalWorkflow(ReleaseLockSignalName, req)
	return nil
}

var _ MutexRun = &testMutexRun{}

// testMutexRun provides convenience methods for interacting with a(n) example.mutex.v1.Example.Mutex workflow in the test environment
type testMutexRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *MutexInput
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testMutexRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.mutex.v1.Example.Mutex workflow result
func (r *testMutexRun) Get(context.Context) error {
	r.env.ExecuteWorkflow(MutexWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test example.mutex.v1.Example.Mutex workflow run's workflow ID
func (r *testMutexRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testMutexRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testMutexRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testMutexRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// AcquireLock executes a example.mutex.v1.Example.AcquireLock signal against a test example.mutex.v1.Example.Mutex workflow
func (r *testMutexRun) AcquireLock(ctx context.Context, req *AcquireLockInput) error {
	return r.client.AcquireLock(ctx, r.ID(), r.RunID(), req)
}

// ReleaseLock executes a example.mutex.v1.Example.ReleaseLock signal against a test example.mutex.v1.Example.Mutex workflow
func (r *testMutexRun) ReleaseLock(ctx context.Context, req *ReleaseLockInput) error {
	return r.client.ReleaseLock(ctx, r.ID(), r.RunID(), req)
}

var _ SampleWorkflowWithMutexRun = &testSampleWorkflowWithMutexRun{}

// testSampleWorkflowWithMutexRun provides convenience methods for interacting with a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow in the test environment
type testSampleWorkflowWithMutexRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SampleWorkflowWithMutexInput
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSampleWorkflowWithMutexRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.mutex.v1.Example.SampleWorkflowWithMutex workflow result
func (r *testSampleWorkflowWithMutexRun) Get(context.Context) error {
	r.env.ExecuteWorkflow(SampleWorkflowWithMutexWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test example.mutex.v1.Example.SampleWorkflowWithMutex workflow run's workflow ID
func (r *testSampleWorkflowWithMutexRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testSampleWorkflowWithMutexRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testSampleWorkflowWithMutexRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSampleWorkflowWithMutexRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// LockAcquired executes a example.mutex.v1.Example.LockAcquired signal against a test example.mutex.v1.Example.SampleWorkflowWithMutex workflow
func (r *testSampleWorkflowWithMutexRun) LockAcquired(ctx context.Context, req *LockAcquiredInput) error {
	return r.client.LockAcquired(ctx, r.ID(), r.RunID(), req)
}

// ExampleCliOptions describes runtime configuration for example.mutex.v1.Example cli
type ExampleCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewExampleCliOptions initializes a new ExampleCliOptions value
func NewExampleCliOptions() *ExampleCliOptions {
	return &ExampleCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ExampleCliOptions) WithAfter(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ExampleCliOptions) WithBefore(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ExampleCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ExampleCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ExampleCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ExampleCliOptions {
	opts.worker = fn
	return opts
}

// NewExampleCli initializes a cli for a(n) example.mutex.v1.Example service
func NewExampleCli(options ...*ExampleCliOptions) (*v2.App, error) {
	commands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "example",
		Commands: commands,
	}, nil
}

// NewExampleCliCommand initializes a cli command for a example.mutex.v1.Example service with subcommands for each query, signal, update, and workflow
func NewExampleCliCommand(options ...*ExampleCliOptions) (*v2.Command, error) {
	subcommands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "example",
		Subcommands: subcommands,
	}, nil
}

// newExampleCommands initializes (sub)commands for a example.mutex.v1.Example cli or command
func newExampleCommands(options ...*ExampleCliOptions) ([]*v2.Command, error) {
	opts := &ExampleCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		// executes a example.mutex.v1.Example.AcquireLock signal,
		{
			Name:                   "acquire-lock",
			Usage:                  "executes a example.mutex.v1.Example.AcquireLock signal",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "set the value of the operation's \"WorkflowId\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "timeout",
					Usage:    "set the value of the operation's \"Timeout\" parameter (e.g. \"3.000000001s\")",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToAcquireLockInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.AcquireLock(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", AcquireLockSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// executes a example.mutex.v1.Example.LockAcquired signal,
		{
			Name:                   "lock-acquired",
			Usage:                  "executes a example.mutex.v1.Example.LockAcquired signal",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "lease-id",
					Usage:    "set the value of the operation's \"LeaseId\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToLockAcquiredInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.LockAcquired(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", LockAcquiredSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// executes a example.mutex.v1.Example.ReleaseLock signal,
		{
			Name:                   "release-lock",
			Usage:                  "executes a example.mutex.v1.Example.ReleaseLock signal",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "lease-id",
					Usage:    "set the value of the operation's \"LeaseId\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToReleaseLockInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.ReleaseLock(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", ReleaseLockSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// example.mutex.v1.Example.Mutex executes a(n) example.mutex.v1.Example.Mutex workflow,
		{
			Name:                   "mutex",
			Usage:                  "example.mutex.v1.Example.Mutex executes a(n) example.mutex.v1.Example.Mutex workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "mutex",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "resource-id",
					Usage:    "set the value of the operation's \"ResourceId\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToMutexInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.MutexAsync(cmd.Context, req, NewMutexOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", MutexWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// sends a example.mutex.v1.Example.AcquireLock signal to a example.mutex.v1.Example.Mutex workflow, starting it if necessary,
		{
			Name:                   "mutex-with-acquire-lock",
			Usage:                  "sends a example.mutex.v1.Example.AcquireLock signal to a example.mutex.v1.Example.Mutex workflow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "resource-id",
					Usage:    "set the value of the operation's \"ResourceId\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "set the value of the operation's \"WorkflowId\" parameter",
					Category: "SIGNAL",
				},
				&v2.StringFlag{
					Name:     "timeout",
					Usage:    "set the value of the operation's \"Timeout\" parameter (e.g. \"3.000000001s\")",
					Category: "SIGNAL",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToMutexInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := UnmarshalCliFlagsToAcquireLockInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.MutexWithAcquireLockAsync(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", MutexWorkflowName, AcquireLockSignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// example.mutex.v1.Example.SampleWorkflowWithMutex executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow,
		{
			Name:                   "sample-workflow-with-mutex",
			Usage:                  "example.mutex.v1.Example.SampleWorkflowWithMutex executes a(n) example.mutex.v1.Example.SampleWorkflowWithMutex workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "mutex",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "resource-id",
					Usage:    "set the value of the operation's \"ResourceId\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "sleep",
					Usage:    "set the value of the operation's \"Sleep\" parameter (e.g. \"3.000000001s\")",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToSampleWorkflowWithMutexInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.SampleWorkflowWithMutexAsync(cmd.Context, req, NewSampleWorkflowWithMutexOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SampleWorkflowWithMutexWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.mutex.v1.Example worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToAcquireLockInput unmarshals a AcquireLockInput from command line flags
func UnmarshalCliFlagsToAcquireLockInput(cmd *v2.Context) (*AcquireLockInput, error) {
	var result AcquireLockInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("workflow-id") {
		hasValues = true
		result.WorkflowId = cmd.String("workflow-id")
	}
	if cmd.IsSet("timeout") {
		hasValues = true
		v, err := time.ParseDuration(cmd.String("timeout"))
		if err != nil {
			return nil, fmt.Errorf("error unmarshalling \"timeout\" duration flag: %w", err)
		}
		result.Timeout = durationpb.New(v)
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToLockAcquiredInput unmarshals a LockAcquiredInput from command line flags
func UnmarshalCliFlagsToLockAcquiredInput(cmd *v2.Context) (*LockAcquiredInput, error) {
	var result LockAcquiredInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("lease-id") {
		hasValues = true
		result.LeaseId = cmd.String("lease-id")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToReleaseLockInput unmarshals a ReleaseLockInput from command line flags
func UnmarshalCliFlagsToReleaseLockInput(cmd *v2.Context) (*ReleaseLockInput, error) {
	var result ReleaseLockInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("lease-id") {
		hasValues = true
		result.LeaseId = cmd.String("lease-id")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToMutexInput unmarshals a MutexInput from command line flags
func UnmarshalCliFlagsToMutexInput(cmd *v2.Context) (*MutexInput, error) {
	var result MutexInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("resource-id") {
		hasValues = true
		result.ResourceId = cmd.String("resource-id")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToSampleWorkflowWithMutexInput unmarshals a SampleWorkflowWithMutexInput from command line flags
func UnmarshalCliFlagsToSampleWorkflowWithMutexInput(cmd *v2.Context) (*SampleWorkflowWithMutexInput, error) {
	var result SampleWorkflowWithMutexInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("resource-id") {
		hasValues = true
		result.ResourceId = cmd.String("resource-id")
	}
	if cmd.IsSet("sleep") {
		hasValues = true
		v, err := time.ParseDuration(cmd.String("sleep"))
		if err != nil {
			return nil, fmt.Errorf("error unmarshalling \"sleep\" duration flag: %w", err)
		}
		result.Sleep = durationpb.New(v)
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithExampleSchemeTypes registers all Example protobuf types with the given scheme
func WithExampleSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_mutex_v1_mutex_proto.Messages().ByName("MutexInput"))
		s.RegisterType(File_example_mutex_v1_mutex_proto.Messages().ByName("AcquireLockInput"))
		s.RegisterType(File_example_mutex_v1_mutex_proto.Messages().ByName("LockAcquiredInput"))
		s.RegisterType(File_example_mutex_v1_mutex_proto.Messages().ByName("ReleaseLockInput"))
		s.RegisterType(File_example_mutex_v1_mutex_proto.Messages().ByName("SampleWorkflowWithMutexInput"))
	}
}
