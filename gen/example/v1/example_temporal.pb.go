// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 0.8.1-next (6abcc9f5052d50b09abafa2bb4f96faa6f51632d)
//	go go1.20.4
//	protoc (unknown)
//
// source: example/v1/example.proto
package examplev1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	v2 "github.com/urfave/cli/v2"
	v1 "go.temporal.io/api/enums/v1"
	v11 "go.temporal.io/api/update/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	"sort"
)

// ExampleTaskQueue= is the default task-queue for a example.v1.Example worker
const ExampleTaskQueue = "example-v1"

// example.v1.Example workflow names
const (
	CreateFooWorkflowName = "example.v1.Example.CreateFoo"
)

// example.v1.Example workflow id expressions
var (
	CreateFooIDExpression = expression.MustParseExpression("create-foo/${!name.slug()}")
)

// example.v1.Example activity names
const (
	NotifyActivityName = "example.v1.Example.Notify"
)

// example.v1.Example query names
const (
	GetFooProgressQueryName = "example.v1.Example.GetFooProgress"
)

// example.v1.Example signal names
const (
	SetFooProgressSignalName = "example.v1.Example.SetFooProgress"
)

// example.v1.Example update names
const (
	UpdateFooProgressUpdateName = "example.v1.Example.UpdateFooProgress"
)

// example.v1.Example update id expressions
var (
	UpdateFooProgressIDExpression = expression.MustParseExpression("update-progress/${! progress.string() }")
)

// ExampleClient describes a client for a(n) example.v1.Example worker
type ExampleClient interface {
	// CreateFoo creates a new foo operation
	CreateFoo(ctx context.Context, req *CreateFooRequest, opts ...*client.StartWorkflowOptions) (*CreateFooResponse, error)
	// CreateFooAsync executes a(n) example.v1.Example.CreateFoo workflow asynchronously
	CreateFooAsync(ctx context.Context, req *CreateFooRequest, opts ...*client.StartWorkflowOptions) (CreateFooRun, error)
	// GetCreateFoo retrieves a handle to an existing example.v1.Example.CreateFoo workflow execution
	GetCreateFoo(ctx context.Context, workflowID string, runID string) CreateFooRun
	/*
	   SetFooProgress sets the current status of a CreateFoo operation
	*/
	CreateFooWithSetFooProgress(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, opts ...*client.StartWorkflowOptions) (*CreateFooResponse, error)
	/*
	   SetFooProgress sets the current status of a CreateFoo operation
	*/
	CreateFooWithSetFooProgressAsync(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, opts ...*client.StartWorkflowOptions) (CreateFooRun, error)
	/*
	   GetFooProgress returns the status of a CreateFoo operation
	*/
	GetFooProgress(ctx context.Context, workflowID string, runID string) (*GetFooProgressResponse, error)
	/*
	   SetFooProgress sets the current status of a CreateFoo operation
	*/
	SetFooProgress(ctx context.Context, workflowID string, runID string, signal *SetFooProgressRequest) error
	/*
	   UpdateFooProgress sets the current status of a CreateFoo operation
	*/
	UpdateFooProgress(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (*GetFooProgressResponse, error)
	/*
	   UpdateFooProgress sets the current status of a CreateFoo operation
	*/
	UpdateFooProgressAsync(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (UpdateFooProgressHandle, error)
}

// exampleClient implements a temporal client for a example.v1.Example service
type exampleClient struct {
	client client.Client
}

// NewExampleClient initializes a new example.v1.Example client
func NewExampleClient(c client.Client) ExampleClient {
	return &exampleClient{client: c}
}

// NewExampleClientWithOptions initializes a new Example client with the given options
func NewExampleClientWithOptions(c client.Client, opts client.Options) (ExampleClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	return &exampleClient{client: c}, nil
}

// CreateFoo executes a example.v1.Example.CreateFoo workflow and blocks until error or response received
func (c *exampleClient) CreateFoo(ctx context.Context, req *CreateFooRequest, options ...*client.StartWorkflowOptions) (*CreateFooResponse, error) {
	run, err := c.CreateFooAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateFooAsync starts a(n) example.v1.Example.CreateFoo workflow
func (c *exampleClient) CreateFooAsync(ctx context.Context, req *CreateFooRequest, options ...*client.StartWorkflowOptions) (CreateFooRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(CreateFooIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, CreateFooWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &createFooRun{
		client: c,
		run:    run,
	}, nil
}

// GetCreateFoo fetches an existing example.v1.Example.CreateFoo execution
func (c *exampleClient) GetCreateFoo(ctx context.Context, workflowID string, runID string) CreateFooRun {
	return &createFooRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CreateFooWithSetFooProgress starts a(n) example.v1.Example.CreateFoo workflow and sends a(n) example.v1.Example.SetFooProgress signal in a transaction
func (c *exampleClient) CreateFooWithSetFooProgress(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, options ...*client.StartWorkflowOptions) (*CreateFooResponse, error) {
	run, err := c.CreateFooWithSetFooProgressAsync(ctx, req, signal, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateFooWithSetFooProgressAsync starts a(n) example.v1.Example.CreateFoo workflow and sends a(n) example.v1.Example.SetFooProgress signal in a transaction
func (c *exampleClient) CreateFooWithSetFooProgressAsync(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, options ...*client.StartWorkflowOptions) (CreateFooRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(CreateFooIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SetFooProgressSignalName, signal, *opts, CreateFooWorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &createFooRun{
		client: c,
		run:    run,
	}, nil
}

// GetFooProgress sends a(n) example.v1.Example.GetFooProgress query to an existing workflow
func (c *exampleClient) GetFooProgress(ctx context.Context, workflowID string, runID string) (*GetFooProgressResponse, error) {
	var resp GetFooProgressResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, GetFooProgressQueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SetFooProgress sends a(n) example.v1.Example.SetFooProgress signal to an existing workflow
func (c *exampleClient) SetFooProgress(ctx context.Context, workflowID string, runID string, signal *SetFooProgressRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SetFooProgressSignalName, signal)
}

// UpdateFooProgress sends a(n) example.v1.Example.UpdateFooProgress update to an existing workflow
func (c *exampleClient) UpdateFooProgress(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (*GetFooProgressResponse, error) {
	options := &client.UpdateWorkflowWithOptionsRequest{}
	if len(opts) > 0 {
		options = opts[0]
	}
	options.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	handle, err := c.UpdateFooProgressAsync(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// UpdateFooProgressAsync sends a(n) example.v1.Example.UpdateFooProgress update to an existing workflow
func (c *exampleClient) UpdateFooProgressAsync(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (UpdateFooProgressHandle, error) {
	options := &client.UpdateWorkflowWithOptionsRequest{}
	if len(opts) > 0 {
		options = opts[0]
	}
	options.Args = []any{req}
	options.RunID = runID
	options.UpdateName = UpdateFooProgressUpdateName
	options.WorkflowID = workflowID
	if options.UpdateID == "" {
		id, err := expression.EvalExpression(UpdateFooProgressIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating %s id expression: %w", UpdateFooProgressUpdateName, err)
		}
		options.UpdateID = id
	}
	handle, err := c.client.UpdateWorkflowWithOptions(ctx, options)
	if err != nil {
		return nil, err
	}
	return &updateFooProgressHandle{client: c, handle: handle}, nil
}

// CreateFooRun describes a(n) example.v1.Example.CreateFoo workflow run
type CreateFooRun interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*CreateFooResponse, error)
	/*
	   GetFooProgress returns the status of a CreateFoo operation
	*/
	GetFooProgress(ctx context.Context) (*GetFooProgressResponse, error)
	/*
	   SetFooProgress sets the current status of a CreateFoo operation
	*/
	SetFooProgress(ctx context.Context, req *SetFooProgressRequest) error
	/*
	   UpdateFooProgress sets the current status of a CreateFoo operation
	*/
	UpdateFooProgress(ctx context.Context, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (*GetFooProgressResponse, error)
	// UpdateFooProgressAsync sends a(n) example.v1.Example.UpdateFooProgress update to the workflow
	UpdateFooProgressAsync(ctx context.Context, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (UpdateFooProgressHandle, error)
}

// createFooRun provides an internal implementation of a(n) CreateFooRunRun
type createFooRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *createFooRun) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *createFooRun) RunID() string {
	return r.run.GetRunID()
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *createFooRun) Get(ctx context.Context) (*CreateFooResponse, error) {
	var resp CreateFooResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// GetFooProgress executes a(n) example.v1.Example.GetFooProgress query
func (r *createFooRun) GetFooProgress(ctx context.Context) (*GetFooProgressResponse, error) {
	return r.client.GetFooProgress(ctx, r.ID(), "")
}

// SetFooProgress sends a(n) example.v1.Example.SetFooProgress signal
func (r *createFooRun) SetFooProgress(ctx context.Context, req *SetFooProgressRequest) error {
	return r.client.SetFooProgress(ctx, r.ID(), "", req)
}

// UpdateFooProgress executes a(n) example.v1.Example.UpdateFooProgress update
func (r *createFooRun) UpdateFooProgress(ctx context.Context, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (*GetFooProgressResponse, error) {
	return r.client.UpdateFooProgress(ctx, r.ID(), r.RunID(), req, opts...)
}

// UpdateFooProgressAsync sends a(n) example.v1.Example.UpdateFooProgress update to the workflow
func (r *createFooRun) UpdateFooProgressAsync(ctx context.Context, req *SetFooProgressRequest, opts ...*client.UpdateWorkflowWithOptionsRequest) (UpdateFooProgressHandle, error) {
	return r.client.UpdateFooProgressAsync(ctx, r.ID(), r.RunID(), req, opts...)
}

// UpdateFooProgressHandle describes a(n) example.v1.Example.UpdateFooProgress update handle
type UpdateFooProgressHandle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*GetFooProgressResponse, error)
}

// updateFooProgressHandle provides an internal implementation of a(n) UpdateFooProgressHandle
type updateFooProgressHandle struct {
	client *exampleClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *updateFooProgressHandle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *updateFooProgressHandle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *updateFooProgressHandle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *updateFooProgressHandle) Get(ctx context.Context) (*GetFooProgressResponse, error) {
	var resp GetFooProgressResponse
	if err := h.handle.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// ExampleWorkflows provides methods for initializing new example.v1.Example workflow values
type ExampleWorkflows interface {
	CreateFoo(ctx workflow.Context, input *CreateFooInput) (CreateFooWorkflow, error)
}

// CreateFoo creates a new foo operation
// RegisterExampleWorkflows registers example.v1.Example workflows with the given worker
func RegisterExampleWorkflows(r worker.Registry, workflows ExampleWorkflows) {
	RegisterCreateFooWorkflow(r, workflows.CreateFoo)
}

// RegisterCreateFooWorkflow registers a example.v1.Example.CreateFoo workflow with the given worker
func RegisterCreateFooWorkflow(r worker.Registry, wf func(workflow.Context, *CreateFooInput) (CreateFooWorkflow, error)) {
	r.RegisterWorkflowWithOptions(buildCreateFoo(wf), workflow.RegisterOptions{Name: CreateFooWorkflowName})
}

// buildCreateFoo converts a CreateFoo workflow struct into a valid workflow function
func buildCreateFoo(ctor func(workflow.Context, *CreateFooInput) (CreateFooWorkflow, error)) func(workflow.Context, *CreateFooRequest) (*CreateFooResponse, error) {
	return func(ctx workflow.Context, req *CreateFooRequest) (*CreateFooResponse, error) {
		input := &CreateFooInput{
			Req: req,
			SetFooProgress: &SetFooProgressSignal{
				Channel: workflow.GetSignalChannel(ctx, SetFooProgressSignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if err := workflow.SetQueryHandler(ctx, GetFooProgressQueryName, wf.GetFooProgress); err != nil {
			return nil, err
		}
		opts := workflow.UpdateHandlerOptions{}
		if err := workflow.SetUpdateHandlerWithOptions(ctx, UpdateFooProgressUpdateName, wf.UpdateFooProgress, opts); err != nil {
			return nil, err
		}
		{
		}
		return wf.Execute(ctx)
	}
}

// CreateFooInput describes the input to a(n) example.v1.Example.CreateFoo workflow constructor
type CreateFooInput struct {
	Req            *CreateFooRequest
	SetFooProgress *SetFooProgressSignal
}

// CreateFoo creates a new foo operation
type CreateFooWorkflow interface {
	Execute(ctx workflow.Context) (*CreateFooResponse, error)
	GetFooProgress() (*GetFooProgressResponse, error)
	UpdateFooProgress(workflow.Context, *SetFooProgressRequest) (*GetFooProgressResponse, error)
}

// CreateFoo creates a new foo operation
// GetFooProgress returns the status of a CreateFoo operation
// UpdateFooProgress sets the current status of a CreateFoo operation
// CreateFooChild executes a child example.v1.Example.CreateFoo workflow
func CreateFooChild(ctx workflow.Context, req *CreateFooRequest, options ...*workflow.ChildWorkflowOptions) (*CreateFooResponse, error) {
	childRun, err := CreateFooChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// CreateFooChildAsync executes a child example.v1.Example.CreateFoo workflow
func CreateFooChildAsync(ctx workflow.Context, req *CreateFooRequest, options ...*workflow.ChildWorkflowOptions) (*CreateFooChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 {
		opts = options[0]
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(CreateFooIDExpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &CreateFooChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CreateFooWorkflowName, req)}, nil
}

// CreateFooChildRun describes a child example.v1.Example.CreateFoo workflow run
type CreateFooChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CreateFooChildRun) Get(ctx workflow.Context) (*CreateFooResponse, error) {
	var resp CreateFooResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CreateFooChildRun) Select(sel workflow.Selector, fn func(CreateFooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CreateFooChildRun) SelectStart(sel workflow.Selector, fn func(CreateFooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CreateFooChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SetFooProgress sends a(n) "example.v1.Example.SetFooProgress" signal request to the child workflow
func (r *CreateFooChildRun) SetFooProgress(ctx workflow.Context, input *SetFooProgressRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SetFooProgressSignalName, input)
}

// SetFooProgressSignal describes a(n) example.v1.Example.SetFooProgress signal
type SetFooProgressSignal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a(n) example.v1.Example.SetFooProgress signal is received
func (s *SetFooProgressSignal) Receive(ctx workflow.Context) (*SetFooProgressRequest, bool) {
	var resp SetFooProgressRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a example.v1.Example.SetFooProgress signal without blocking
func (s *SetFooProgressSignal) ReceiveAsync() *SetFooProgressRequest {
	var resp SetFooProgressRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a(n) example.v1.Example.SetFooProgress signal without blocking
func (s *SetFooProgressSignal) Select(sel workflow.Selector, fn func(*SetFooProgressRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SetFooProgressExternal sends a(n) example.v1.Example.SetFooProgress signal to an existing workflow
func SetFooProgressExternal(ctx workflow.Context, workflowID string, runID string, req *SetFooProgressRequest) error {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SetFooProgressSignalName, req).Get(ctx, nil)
}

// ExampleActivities describes available worker activites
type ExampleActivities interface {
	// Notify sends a notification
	Notify(ctx context.Context, req *NotifyRequest) error
}

// RegisterExampleActivities registers activities with a worker
func RegisterExampleActivities(r worker.Registry, activities ExampleActivities) {
	RegisterNotifyActivity(r, activities.Notify)
}

// RegisterNotifyActivity registers a example.v1.Example.Notify activity
func RegisterNotifyActivity(r worker.Registry, fn func(context.Context, *NotifyRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: NotifyActivityName,
	})
}

// NotifyFuture describes a(n) example.v1.Example.Notify activity execution
type NotifyFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *NotifyFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *NotifyFuture) Select(sel workflow.Selector, fn func(*NotifyFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Notify sends a notification
func Notify(ctx workflow.Context, req *NotifyRequest, options ...*workflow.ActivityOptions) error {
	var opts *workflow.ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts = &activityOpts
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	var activity any
	activity = NotifyActivityName
	future := &NotifyFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// Notify sends a notification (asynchronously)
func NotifyAsync(ctx workflow.Context, req *NotifyRequest, options ...*workflow.ActivityOptions) *NotifyFuture {
	var opts *workflow.ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts = &activityOpts
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts)
	var activity any
	activity = NotifyActivityName
	future := &NotifyFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// Notify sends a notification (locally)
func NotifyLocal(ctx workflow.Context, fn func(context.Context, *NotifyRequest) error, req *NotifyRequest, options ...*workflow.LocalActivityOptions) error {
	var opts *workflow.LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &activityOpts
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	var activity any
	if fn == nil {
		activity = NotifyActivityName
	} else {
		activity = fn
	}
	future := &NotifyFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// Notify sends a notification (asynchronously, locally)
func NotifyLocalAsync(ctx workflow.Context, fn func(context.Context, *NotifyRequest) error, req *NotifyRequest, options ...*workflow.LocalActivityOptions) *NotifyFuture {
	var opts *workflow.LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts = &activityOpts
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts)
	var activity any
	if fn == nil {
		activity = NotifyActivityName
	} else {
		activity = fn
	}
	future := &NotifyFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// ExampleCliOptions describes runtime configuration for example.v1.Example cli
type ExampleCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewExampleCliOptions initializes a new ExampleCliOptions value
func NewExampleCliOptions() *ExampleCliOptions {
	return &ExampleCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ExampleCliOptions) WithAfter(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ExampleCliOptions) WithBefore(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ExampleCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ExampleCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ExampleCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ExampleCliOptions {
	opts.worker = fn
	return opts
}

// NewExampleCli initializes a cli for a(n) example.v1.Example service
func NewExampleCli(options ...*ExampleCliOptions) (*v2.App, error) {
	commands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "example",
		Commands: commands,
	}, nil
}

// NewExampleCliCommand initializes a cli command for a example.v1.Example service with subcommands for each query, signal, update, and workflow
func NewExampleCliCommand(options ...*ExampleCliOptions) (*v2.Command, error) {
	subcommands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "example",
		Subcommands: subcommands,
	}, nil
}

// newExampleCommands initializes (sub)commands for a example.v1.Example cli or command
func newExampleCommands(options ...*ExampleCliOptions) ([]*v2.Command, error) {
	opts := &ExampleCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		// GetFooProgress returns the status of a CreateFoo operation,
		{
			Name:                   "get-foo-progress",
			Usage:                  "GetFooProgress returns the status of a CreateFoo operation",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				if resp, err := client.GetFooProgress(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", GetFooProgressQueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// SetFooProgress sets the current status of a CreateFoo operation,
		{
			Name:                   "set-foo-progress",
			Usage:                  "SetFooProgress sets the current status of a CreateFoo operation",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.Float64Flag{
					Name:     "progress",
					Usage:    "value of current workflow progress",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := unmarshalCliFlagsToSetFooProgressRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SetFooProgress(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SetFooProgressSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// UpdateFooProgress sets the current status of a CreateFoo operation,
		{
			Name:                   "update-foo-progress",
			Usage:                  "UpdateFooProgress sets the current status of a CreateFoo operation",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.Float64Flag{
					Name:     "progress",
					Usage:    "value of current workflow progress",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := unmarshalCliFlagsToSetFooProgressRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.UpdateFooProgressAsync(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", UpdateFooProgressUpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// CreateFoo creates a new foo operation,
		{
			Name:                   "create-foo",
			Usage:                  "CreateFoo creates a new foo operation",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "unique foo name",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := unmarshalCliFlagsToCreateFooRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				run, err := client.CreateFooAsync(cmd.Context, req)
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CreateFooWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// sends a SetFooProgress signal to a CreateFoo worklow, starting it if necessary,
		{
			Name:                   "create-foo-with-set-foo-progress",
			Usage:                  "sends a SetFooProgress signal to a CreateFoo worklow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "unique foo name",
					Category: "INPUT",
				},
				&v2.Float64Flag{
					Name:     "progress",
					Usage:    "value of current workflow progress",
					Category: "SIGNAL",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := unmarshalCliFlagsToCreateFooRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := unmarshalCliFlagsToSetFooProgressRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.CreateFooWithSetFooProgressAsync(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", CreateFooWorkflowName, SetFooProgressSignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.v1.Example worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// unmarshalCliFlagsToSetFooProgressRequest unmarshals a SetFooProgressRequest from command line flags
func unmarshalCliFlagsToSetFooProgressRequest(cmd *v2.Context) (*SetFooProgressRequest, error) {
	var result SetFooProgressRequest
	var hasValues bool
	if cmd.IsSet("progress") {
		hasValues = true
		result.Progress = float32(cmd.Float64("progress"))
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToCreateFooRequest unmarshals a CreateFooRequest from command line flags
func unmarshalCliFlagsToCreateFooRequest(cmd *v2.Context) (*CreateFooRequest, error) {
	var result CreateFooRequest
	var hasValues bool
	if cmd.IsSet("name") {
		hasValues = true
		result.Name = cmd.String("name")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}
