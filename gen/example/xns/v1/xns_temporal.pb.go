// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.15.1-next (f1e76430351366c0f5ba139a759e99d0ffa098d7)
//	go go1.23.5
//	protoc (unknown)
//
// source: example/xns/v1/xns.proto
package xnsv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	testutil "github.com/cludden/protoc-gen-go-temporal/pkg/testutil"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	serviceerror "go.temporal.io/api/serviceerror"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"strings"
	"time"
)

// XnsTaskQueue is the default task-queue for a example.xns.v1.Xns worker
const XnsTaskQueue = "xns-v1"

// example.xns.v1.Xns workflow names
const (
	ProvisionFooWorkflowName = "example.xns.v1.Xns.ProvisionFoo"
)

// example.xns.v1.Xns workflow id expressions
var (
	ProvisionFooIdexpression = expression.MustParseExpression("provision-foo/${! name.slug() }")
)

// XnsClient describes a client for a(n) example.xns.v1.Xns worker
type XnsClient interface {
	// ProvisionFoo executes a(n) example.xns.v1.Xns.ProvisionFoo workflow and blocks until error or response received
	ProvisionFoo(ctx context.Context, req *ProvisionFooRequest, opts ...*ProvisionFooOptions) (*ProvisionFooResponse, error)

	// ProvisionFooAsync starts a(n) example.xns.v1.Xns.ProvisionFoo workflow and returns a handle to the workflow run
	ProvisionFooAsync(ctx context.Context, req *ProvisionFooRequest, opts ...*ProvisionFooOptions) (ProvisionFooRun, error)

	// GetProvisionFoo retrieves a handle to an existing example.xns.v1.Xns.ProvisionFoo workflow execution
	GetProvisionFoo(ctx context.Context, workflowID string, runID string) ProvisionFooRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// xnsClient implements a temporal client for a example.xns.v1.Xns service
type xnsClient struct {
	client client.Client
	log    *slog.Logger
}

// NewXnsClient initializes a new example.xns.v1.Xns client
func NewXnsClient(c client.Client, options ...*xnsClientOptions) XnsClient {
	var cfg *xnsClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewXnsClientOptions()
	}
	return &xnsClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewXnsClientWithOptions initializes a new Xns client with the given options
func NewXnsClientWithOptions(c client.Client, opts client.Options, options ...*xnsClientOptions) (XnsClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *xnsClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewXnsClientOptions()
	}
	return &xnsClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// xnsClientOptions describes optional runtime configuration for a XnsClient
type xnsClientOptions struct {
	log *slog.Logger
}

// NewXnsClientOptions initializes a new xnsClientOptions value
func NewXnsClientOptions() *xnsClientOptions {
	return &xnsClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *xnsClientOptions) WithLogger(l *slog.Logger) *xnsClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *xnsClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.xns.v1.Xns.ProvisionFoo executes a example.xns.v1.Xns.ProvisionFoo workflow and blocks until error or response received
func (c *xnsClient) ProvisionFoo(ctx context.Context, req *ProvisionFooRequest, options ...*ProvisionFooOptions) (*ProvisionFooResponse, error) {
	run, err := c.ProvisionFooAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ProvisionFooAsync starts a(n) example.xns.v1.Xns.ProvisionFoo workflow and returns a handle to the workflow run
func (c *xnsClient) ProvisionFooAsync(ctx context.Context, req *ProvisionFooRequest, options ...*ProvisionFooOptions) (ProvisionFooRun, error) {
	var o *ProvisionFooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewProvisionFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ProvisionFooWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &provisionFooRun{
		client: c,
		run:    run,
	}, nil
}

// GetProvisionFoo fetches an existing example.xns.v1.Xns.ProvisionFoo execution
func (c *xnsClient) GetProvisionFoo(ctx context.Context, workflowID string, runID string) ProvisionFooRun {
	return &provisionFooRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *xnsClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *xnsClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// ProvisionFooOptions provides configuration for a example.xns.v1.Xns.ProvisionFoo workflow operation
type ProvisionFooOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewProvisionFooOptions initializes a new ProvisionFooOptions value
func NewProvisionFooOptions() *ProvisionFooOptions {
	return &ProvisionFooOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ProvisionFooOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(ProvisionFooIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ProvisionFooWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = XnsTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ProvisionFooOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ProvisionFooOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ProvisionFooOptions) WithExecutionTimeout(d time.Duration) *ProvisionFooOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ProvisionFooOptions) WithID(id string) *ProvisionFooOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ProvisionFooOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ProvisionFooOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ProvisionFooOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ProvisionFooOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ProvisionFooOptions) WithRunTimeout(d time.Duration) *ProvisionFooOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ProvisionFooOptions) WithSearchAttributes(sa map[string]any) *ProvisionFooOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ProvisionFooOptions) WithTaskTimeout(d time.Duration) *ProvisionFooOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ProvisionFooOptions) WithTaskQueue(tq string) *ProvisionFooOptions {
	o.taskQueue = &tq
	return o
}

// ProvisionFooRun describes a(n) example.xns.v1.Xns.ProvisionFoo workflow run
type ProvisionFooRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ProvisionFooResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// provisionFooRun provides an internal implementation of a(n) ProvisionFooRunRun
type provisionFooRun struct {
	client *xnsClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *provisionFooRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *provisionFooRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *provisionFooRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *provisionFooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *provisionFooRun) Get(ctx context.Context) (*ProvisionFooResponse, error) {
	var resp ProvisionFooResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *provisionFooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// ProvisionFooFunction implements a "example.xns.v1.Xns.ProvisionFoo" workflow
	ProvisionFooFunction func(workflow.Context, *ProvisionFooRequest) (*ProvisionFooResponse, error)
)

// XnsWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// XnsWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	XnsWorkflowFunctions interface {
		// ProvisionFoo executes a "example.xns.v1.Xns.ProvisionFoo" workflow inline
		ProvisionFoo(workflow.Context, *ProvisionFooRequest) (*ProvisionFooResponse, error)
	}
	// xnsWorkflowFunctions provides an internal XnsWorkflowFunctions implementation
	xnsWorkflowFunctions struct{}
)

func NewXnsWorkflowFunctions() XnsWorkflowFunctions {
	return &xnsWorkflowFunctions{}
}

// ProvisionFoo executes a "example.xns.v1.Xns.ProvisionFoo" workflow inline
func (f *xnsWorkflowFunctions) ProvisionFoo(ctx workflow.Context, req *ProvisionFooRequest) (*ProvisionFooResponse, error) {
	if ProvisionFooFunction == nil {
		return nil, errors.New("ProvisionFoo requires workflow registration via RegisterXnsWorkflows or RegisterProvisionFooWorkflow")
	}
	return ProvisionFooFunction(ctx, req)
}

// XnsWorkflows provides methods for initializing new example.xns.v1.Xns workflow values
type XnsWorkflows interface {
	// ProvisionFoo initializes a new a(n) ProvisionFooWorkflow implementation
	ProvisionFoo(ctx workflow.Context, input *ProvisionFooWorkflowInput) (ProvisionFooWorkflow, error)
}

// RegisterXnsWorkflows registers example.xns.v1.Xns workflows with the given worker
func RegisterXnsWorkflows(r worker.WorkflowRegistry, workflows XnsWorkflows) {
	RegisterProvisionFooWorkflow(r, workflows.ProvisionFoo)
}

// RegisterProvisionFooWorkflow registers a example.xns.v1.Xns.ProvisionFoo workflow with the given worker
func RegisterProvisionFooWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ProvisionFooWorkflowInput) (ProvisionFooWorkflow, error)) {
	ProvisionFooFunction = buildProvisionFoo(wf)
	r.RegisterWorkflowWithOptions(ProvisionFooFunction, workflow.RegisterOptions{Name: ProvisionFooWorkflowName})
}

// buildProvisionFoo converts a ProvisionFoo workflow struct into a valid workflow function
func buildProvisionFoo(ctor func(workflow.Context, *ProvisionFooWorkflowInput) (ProvisionFooWorkflow, error)) func(workflow.Context, *ProvisionFooRequest) (*ProvisionFooResponse, error) {
	return func(ctx workflow.Context, req *ProvisionFooRequest) (*ProvisionFooResponse, error) {
		input := &ProvisionFooWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ProvisionFooWorkflowInput describes the input to a(n) example.xns.v1.Xns.ProvisionFoo workflow constructor
type ProvisionFooWorkflowInput struct {
	Req *ProvisionFooRequest
}

// ProvisionFooWorkflow describes a(n) example.xns.v1.Xns.ProvisionFoo workflow implementation
//
// workflow details: (id: "provision-foo/${! name.slug() }")
type ProvisionFooWorkflow interface {
	// Execute defines the entrypoint to a(n) example.xns.v1.Xns.ProvisionFoo workflow
	Execute(ctx workflow.Context) (*ProvisionFooResponse, error)
}

// ProvisionFooChild executes a child example.xns.v1.Xns.ProvisionFoo workflow and blocks until error or response received
func ProvisionFooChild(ctx workflow.Context, req *ProvisionFooRequest, options ...*ProvisionFooChildOptions) (*ProvisionFooResponse, error) {
	childRun, err := ProvisionFooChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ProvisionFooChildAsync starts a child example.xns.v1.Xns.ProvisionFoo workflow and returns a handle to the child workflow run
func ProvisionFooChildAsync(ctx workflow.Context, req *ProvisionFooRequest, options ...*ProvisionFooChildOptions) (*ProvisionFooChildRun, error) {
	var o *ProvisionFooChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewProvisionFooChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &ProvisionFooChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ProvisionFooWorkflowName, req)}, nil
}

// ProvisionFooChildOptions provides configuration for a child example.xns.v1.Xns.ProvisionFoo workflow operation
type ProvisionFooChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewProvisionFooChildOptions initializes a new ProvisionFooChildOptions value
func NewProvisionFooChildOptions() *ProvisionFooChildOptions {
	return &ProvisionFooChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ProvisionFooChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(ProvisionFooIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", ProvisionFooWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ProvisionFooWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(ProvisionFooIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", ProvisionFooWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = XnsTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ProvisionFooChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ProvisionFooChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ProvisionFooChildOptions) WithExecutionTimeout(d time.Duration) *ProvisionFooChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ProvisionFooChildOptions) WithID(id string) *ProvisionFooChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ProvisionFooChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ProvisionFooChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ProvisionFooChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ProvisionFooChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ProvisionFooChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ProvisionFooChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ProvisionFooChildOptions) WithRunTimeout(d time.Duration) *ProvisionFooChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ProvisionFooChildOptions) WithSearchAttributes(sa map[string]any) *ProvisionFooChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ProvisionFooChildOptions) WithTaskTimeout(d time.Duration) *ProvisionFooChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ProvisionFooChildOptions) WithTaskQueue(tq string) *ProvisionFooChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ProvisionFooChildOptions) WithWaitForCancellation(wait bool) *ProvisionFooChildOptions {
	o.waitForCancellation = &wait
	return o
}

// ProvisionFooChildRun describes a child ProvisionFoo workflow run
type ProvisionFooChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ProvisionFooChildRun) Get(ctx workflow.Context) (*ProvisionFooResponse, error) {
	var resp ProvisionFooResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ProvisionFooChildRun) Select(sel workflow.Selector, fn func(*ProvisionFooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ProvisionFooChildRun) SelectStart(sel workflow.Selector, fn func(*ProvisionFooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ProvisionFooChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// XnsActivities describes available worker activities
type XnsActivities interface{}

// RegisterXnsActivities registers activities with a worker
func RegisterXnsActivities(r worker.ActivityRegistry, activities XnsActivities) {}

// TestClient provides a testsuite-compatible Client
type TestXnsClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows XnsWorkflows
}

var _ XnsClient = &TestXnsClient{}

// NewTestXnsClient initializes a new TestXnsClient value
func NewTestXnsClient(env *testsuite.TestWorkflowEnvironment, workflows XnsWorkflows, activities XnsActivities) *TestXnsClient {
	if workflows != nil {
		RegisterXnsWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterXnsActivities(env, activities)
	}
	return &TestXnsClient{env, workflows}
}

// ProvisionFoo executes a(n) example.xns.v1.Xns.ProvisionFoo workflow in the test environment
func (c *TestXnsClient) ProvisionFoo(ctx context.Context, req *ProvisionFooRequest, opts ...*ProvisionFooOptions) (*ProvisionFooResponse, error) {
	run, err := c.ProvisionFooAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ProvisionFooAsync executes a(n) example.xns.v1.Xns.ProvisionFoo workflow in the test environment
func (c *TestXnsClient) ProvisionFooAsync(ctx context.Context, req *ProvisionFooRequest, options ...*ProvisionFooOptions) (ProvisionFooRun, error) {
	var o *ProvisionFooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewProvisionFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testProvisionFooRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetProvisionFoo is a noop
func (c *TestXnsClient) GetProvisionFoo(ctx context.Context, workflowID string, runID string) ProvisionFooRun {
	return &testProvisionFooRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestXnsClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestXnsClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ ProvisionFooRun = &testProvisionFooRun{}

// testProvisionFooRun provides convenience methods for interacting with a(n) example.xns.v1.Xns.ProvisionFoo workflow in the test environment
type testProvisionFooRun struct {
	client    *TestXnsClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *ProvisionFooRequest
	workflows XnsWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testProvisionFooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.xns.v1.Xns.ProvisionFoo workflow result
func (r *testProvisionFooRun) Get(context.Context) (*ProvisionFooResponse, error) {
	r.env.ExecuteWorkflow(ProvisionFooWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ProvisionFooResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.xns.v1.Xns.ProvisionFoo workflow run's workflow ID
func (r *testProvisionFooRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testProvisionFooRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testProvisionFooRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testProvisionFooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// XnsCliOptions describes runtime configuration for example.xns.v1.Xns cli
type XnsCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewXnsCliOptions initializes a new XnsCliOptions value
func NewXnsCliOptions() *XnsCliOptions {
	return &XnsCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *XnsCliOptions) WithAfter(fn func(*v2.Context) error) *XnsCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *XnsCliOptions) WithBefore(fn func(*v2.Context) error) *XnsCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *XnsCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *XnsCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *XnsCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *XnsCliOptions {
	opts.worker = fn
	return opts
}

// NewXnsCli initializes a cli for a(n) example.xns.v1.Xns service
func NewXnsCli(options ...*XnsCliOptions) (*v2.App, error) {
	commands, err := newXnsCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "xns",
		Commands: commands,
	}, nil
}

// NewXnsCliCommand initializes a cli command for a example.xns.v1.Xns service with subcommands for each query, signal, update, and workflow
func NewXnsCliCommand(options ...*XnsCliOptions) (*v2.Command, error) {
	subcommands, err := newXnsCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "xns",
		Subcommands: subcommands,
	}, nil
}

// newXnsCommands initializes (sub)commands for a example.xns.v1.Xns cli or command
func newXnsCommands(options ...*XnsCliOptions) ([]*v2.Command, error) {
	opts := &XnsCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "provision-foo",
			Usage:                  "executes a(n) example.xns.v1.Xns.ProvisionFoo workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "xns-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "unique foo name",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewXnsClient(tc)
				req, err := UnmarshalCliFlagsToProvisionFooRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ProvisionFooAsync(cmd.Context, req, NewProvisionFooOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ProvisionFooWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.xns.v1.Xns worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToProvisionFooRequest unmarshals a ProvisionFooRequest from command line flags
func UnmarshalCliFlagsToProvisionFooRequest(cmd *v2.Context) (*ProvisionFooRequest, error) {
	var result ProvisionFooRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("name") {
		hasValues = true
		result.Name = cmd.String("name")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithXnsSchemeTypes registers all Xns protobuf types with the given scheme
func WithXnsSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("ProvisionFooRequest"))
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("ProvisionFooResponse"))
	}
}

// ExampleTaskQueue is the default task-queue for a example.xns.v1.Example worker
const ExampleTaskQueue = "example-v1"

// example.xns.v1.Example workflow names
const (
	CreateFooWorkflowName = "example.xns.v1.Example.CreateFoo"
)

// example.xns.v1.Example workflow id expressions
var (
	CreateFooIdexpression = expression.MustParseExpression("create-foo/${! name.slug() }")
)

// example.xns.v1.Example activity names
const (
	NotifyActivityName = "example.xns.v1.Example.Notify"
)

// example.xns.v1.Example query names
const (
	GetFooProgressQueryName = "example.xns.v1.Example.GetFooProgress"
)

// example.xns.v1.Example signal names
const (
	SetFooProgressSignalName = "example.xns.v1.Example.SetFooProgress"
)

// example.xns.v1.Example update names
const (
	UpdateFooProgressUpdateName = "example.xns.v1.Example.UpdateFooProgress"
)

// example.xns.v1.Example update id expressions
var (
	UpdateFooProgressIdexpression = expression.MustParseExpression("update-progress/${! progress.string() }")
)

// ExampleClient describes a client for a(n) example.xns.v1.Example worker
type ExampleClient interface {
	// CreateFoo creates a new foo operation
	CreateFoo(ctx context.Context, req *CreateFooRequest, opts ...*CreateFooOptions) (*CreateFooResponse, error)

	// CreateFooAsync starts a(n) example.xns.v1.Example.CreateFoo workflow and returns a handle to the workflow run
	CreateFooAsync(ctx context.Context, req *CreateFooRequest, opts ...*CreateFooOptions) (CreateFooRun, error)

	// GetCreateFoo retrieves a handle to an existing example.xns.v1.Example.CreateFoo workflow execution
	GetCreateFoo(ctx context.Context, workflowID string, runID string) CreateFooRun

	// CreateFooWithSetFooProgress sends a(n) example.xns.v1.Example.SetFooProgress signal to a(n) example.xns.v1.Example.CreateFoo workflow, starting it if necessary, and blocks until workflow completion
	CreateFooWithSetFooProgress(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, opts ...*CreateFooOptions) (*CreateFooResponse, error)

	// CreateFooWithSetFooProgressAsync sends a(n) example.xns.v1.Example.SetFooProgress signal to a(n) example.xns.v1.Example.CreateFoo workflow, starting it if necessary, and returns a handle to the workflow execution
	CreateFooWithSetFooProgressAsync(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, opts ...*CreateFooOptions) (CreateFooRun, error)

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error

	// GetFooProgress returns the status of a CreateFoo operation
	GetFooProgress(ctx context.Context, workflowID string, runID string) (*GetFooProgressResponse, error)

	// SetFooProgress sets the current status of a CreateFoo operation
	SetFooProgress(ctx context.Context, workflowID string, runID string, signal *SetFooProgressRequest) error

	// UpdateFooProgress sets the current status of a CreateFoo operation
	UpdateFooProgress(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (*GetFooProgressResponse, error)

	// UpdateFooProgressAsync starts a(n) example.xns.v1.Example.UpdateFooProgress update and returns a handle to the workflow update
	UpdateFooProgressAsync(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (UpdateFooProgressHandle, error)

	// GetUpdateFooProgress retrieves a handle to an existing example.xns.v1.Example.UpdateFooProgress update
	GetUpdateFooProgress(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (UpdateFooProgressHandle, error)
}

// exampleClient implements a temporal client for a example.xns.v1.Example service
type exampleClient struct {
	client client.Client
	log    *slog.Logger
}

// NewExampleClient initializes a new example.xns.v1.Example client
func NewExampleClient(c client.Client, options ...*exampleClientOptions) ExampleClient {
	var cfg *exampleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewExampleClientOptions()
	}
	return &exampleClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewExampleClientWithOptions initializes a new Example client with the given options
func NewExampleClientWithOptions(c client.Client, opts client.Options, options ...*exampleClientOptions) (ExampleClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *exampleClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewExampleClientOptions()
	}
	return &exampleClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// exampleClientOptions describes optional runtime configuration for a ExampleClient
type exampleClientOptions struct {
	log *slog.Logger
}

// NewExampleClientOptions initializes a new exampleClientOptions value
func NewExampleClientOptions() *exampleClientOptions {
	return &exampleClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *exampleClientOptions) WithLogger(l *slog.Logger) *exampleClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *exampleClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// CreateFoo creates a new foo operation
func (c *exampleClient) CreateFoo(ctx context.Context, req *CreateFooRequest, options ...*CreateFooOptions) (*CreateFooResponse, error) {
	run, err := c.CreateFooAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateFoo creates a new foo operation
func (c *exampleClient) CreateFooAsync(ctx context.Context, req *CreateFooRequest, options ...*CreateFooOptions) (CreateFooRun, error) {
	var o *CreateFooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, CreateFooWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &createFooRun{
		client: c,
		run:    run,
	}, nil
}

// GetCreateFoo fetches an existing example.xns.v1.Example.CreateFoo execution
func (c *exampleClient) GetCreateFoo(ctx context.Context, workflowID string, runID string) CreateFooRun {
	return &createFooRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CreateFooWithSetFooProgress starts a(n) example.xns.v1.Example.CreateFoo workflow and sends a(n) example.xns.v1.Example.SetFooProgress signal in a transaction
func (c *exampleClient) CreateFooWithSetFooProgress(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, options ...*CreateFooOptions) (*CreateFooResponse, error) {
	run, err := c.CreateFooWithSetFooProgressAsync(ctx, req, signal, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateFooWithSetFooProgressAsync starts a(n) example.xns.v1.Example.CreateFoo workflow and sends a(n) example.xns.v1.Example.SetFooProgress signal in a transaction
func (c *exampleClient) CreateFooWithSetFooProgressAsync(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, options ...*CreateFooOptions) (CreateFooRun, error) {
	var o *CreateFooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SetFooProgressSignalName, signal, opts, CreateFooWorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &createFooRun{
		client: c,
		run:    run,
	}, nil
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *exampleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *exampleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// GetFooProgress returns the status of a CreateFoo operation
func (c *exampleClient) GetFooProgress(ctx context.Context, workflowID string, runID string) (*GetFooProgressResponse, error) {
	var resp GetFooProgressResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, GetFooProgressQueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SetFooProgress sets the current status of a CreateFoo operation
func (c *exampleClient) SetFooProgress(ctx context.Context, workflowID string, runID string, signal *SetFooProgressRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SetFooProgressSignalName, signal)
}

// UpdateFooProgress sets the current status of a CreateFoo operation
func (c *exampleClient) UpdateFooProgress(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (*GetFooProgressResponse, error) {
	// initialize update options
	o := NewUpdateFooProgressOptions()
	if len(opts) > 0 && opts[0].Options != nil {
		o = opts[0]
	}

	// call sync update with WorkflowUpdateStageCompleted wait policy
	handle, err := c.UpdateFooProgressAsync(ctx, workflowID, runID, req, o.WithWaitPolicy(client.WorkflowUpdateStageCompleted))
	if err != nil {
		return nil, err
	}

	// block on update completion
	return handle.Get(ctx)
}

// UpdateFooProgress sets the current status of a CreateFoo operation
func (c *exampleClient) UpdateFooProgressAsync(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (UpdateFooProgressHandle, error) {
	// initialize update options
	var o *UpdateFooProgressOptions
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewUpdateFooProgressOptions()
	}

	// build UpdateWorkflowOptions
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	// update workflow
	handle, err := c.client.UpdateWorkflow(ctx, *options)
	if err != nil {
		return nil, err
	}
	return &updateFooProgressHandle{client: c, handle: handle}, nil
}

// GetUpdateFooProgress retrieves a handle to an existing example.xns.v1.Example.UpdateFooProgress update
func (c *exampleClient) GetUpdateFooProgress(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (UpdateFooProgressHandle, error) {
	return &updateFooProgressHandle{
		client: c,
		handle: c.client.GetWorkflowUpdateHandle(req),
	}, nil
}

// CreateFooOptions provides configuration for a example.xns.v1.Example.CreateFoo workflow operation
type CreateFooOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewCreateFooOptions initializes a new CreateFooOptions value
func NewCreateFooOptions() *CreateFooOptions {
	return &CreateFooOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *CreateFooOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(CreateFooIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CreateFooWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *CreateFooOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *CreateFooOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CreateFooOptions) WithExecutionTimeout(d time.Duration) *CreateFooOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *CreateFooOptions) WithID(id string) *CreateFooOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CreateFooOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CreateFooOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CreateFooOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CreateFooOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CreateFooOptions) WithRunTimeout(d time.Duration) *CreateFooOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CreateFooOptions) WithSearchAttributes(sa map[string]any) *CreateFooOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CreateFooOptions) WithTaskTimeout(d time.Duration) *CreateFooOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CreateFooOptions) WithTaskQueue(tq string) *CreateFooOptions {
	o.taskQueue = &tq
	return o
}

// CreateFooRun describes a(n) example.xns.v1.Example.CreateFoo workflow run
type CreateFooRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*CreateFooResponse, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error

	// GetFooProgress returns the status of a CreateFoo operation
	GetFooProgress(ctx context.Context) (*GetFooProgressResponse, error)

	// SetFooProgress sets the current status of a CreateFoo operation
	SetFooProgress(ctx context.Context, req *SetFooProgressRequest) error

	// UpdateFooProgress sets the current status of a CreateFoo operation
	UpdateFooProgress(ctx context.Context, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (*GetFooProgressResponse, error)

	// UpdateFooProgress sets the current status of a CreateFoo operation
	UpdateFooProgressAsync(ctx context.Context, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (UpdateFooProgressHandle, error)
}

// createFooRun provides an internal implementation of a(n) CreateFooRunRun
type createFooRun struct {
	client *exampleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *createFooRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *createFooRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *createFooRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *createFooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *createFooRun) Get(ctx context.Context) (*CreateFooResponse, error) {
	var resp CreateFooResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *createFooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// GetFooProgress returns the status of a CreateFoo operation
func (r *createFooRun) GetFooProgress(ctx context.Context) (*GetFooProgressResponse, error) {
	return r.client.GetFooProgress(ctx, r.ID(), "")
}

// SetFooProgress sets the current status of a CreateFoo operation
func (r *createFooRun) SetFooProgress(ctx context.Context, req *SetFooProgressRequest) error {
	return r.client.SetFooProgress(ctx, r.ID(), "", req)
}

// UpdateFooProgress sets the current status of a CreateFoo operation
func (r *createFooRun) UpdateFooProgress(ctx context.Context, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (*GetFooProgressResponse, error) {
	return r.client.UpdateFooProgress(ctx, r.ID(), r.RunID(), req, opts...)
}

// UpdateFooProgress sets the current status of a CreateFoo operation
func (r *createFooRun) UpdateFooProgressAsync(ctx context.Context, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (UpdateFooProgressHandle, error) {
	return r.client.UpdateFooProgressAsync(ctx, r.ID(), r.RunID(), req, opts...)
}

// UpdateFooProgressHandle describes a(n) example.xns.v1.Example.UpdateFooProgress update handle
type UpdateFooProgressHandle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*GetFooProgressResponse, error)
}

// updateFooProgressHandle provides an internal implementation of a(n) UpdateFooProgressHandle
type updateFooProgressHandle struct {
	client *exampleClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *updateFooProgressHandle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *updateFooProgressHandle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *updateFooProgressHandle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *updateFooProgressHandle) Get(ctx context.Context) (*GetFooProgressResponse, error) {
	var resp GetFooProgressResponse
	var err error
	doneCh := make(chan struct{})
	gctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		for {
			var deadlineExceeded *serviceerror.DeadlineExceeded
			if err = h.handle.Get(gctx, &resp); err != nil && ctx.Err() == nil && (errors.As(err, &deadlineExceeded) || strings.Contains(err.Error(), context.DeadlineExceeded.Error())) {
				continue
			}
			break
		}
		close(doneCh)
	}()

	select {
	case <-ctx.Done():
		return nil, ctx.Err()
	case <-doneCh:
		if err != nil {
			return nil, err
		}
		return &resp, nil
	}
}

// UpdateFooProgressOptions provides configuration for a example.xns.v1.Example.UpdateFooProgress update operation
type UpdateFooProgressOptions struct {
	Options    *client.UpdateWorkflowOptions
	id         *string
	waitPolicy client.WorkflowUpdateStage
}

// NewUpdateFooProgressOptions initializes a new UpdateFooProgressOptions value
func NewUpdateFooProgressOptions() *UpdateFooProgressOptions {
	return &UpdateFooProgressOptions{Options: &client.UpdateWorkflowOptions{}}
}

// Build initializes a new client.UpdateWorkflowOptions with defaults and overrides applied
func (o *UpdateFooProgressOptions) Build(workflowID string, runID string, req *SetFooProgressRequest) (opts *client.UpdateWorkflowOptions, err error) {
	// use user-provided UpdateWorkflowOptions if exists
	if o.Options != nil {
		opts = o.Options
	} else {
		opts = &client.UpdateWorkflowOptions{}
	}

	// set constants
	opts.Args = []any{req}
	opts.RunID = runID
	opts.UpdateName = UpdateFooProgressUpdateName
	opts.WorkflowID = workflowID

	// set UpdateID
	if v := o.id; v != nil {
		opts.UpdateID = *v
	} else if opts.UpdateID == "" {
		id, err := expression.EvalExpression(UpdateFooProgressIdexpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating id expression for %q update: %w", UpdateFooProgressUpdateName, err)
		}
		opts.UpdateID = id
	}

	// set WaitPolicy
	if v := o.waitPolicy; v != client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = v
	} else if opts.WaitForStage == client.WorkflowUpdateStageUnspecified {
		opts.WaitForStage = client.WorkflowUpdateStageCompleted
	}
	return opts, nil
}

// WithUpdateID sets the UpdateID
func (o *UpdateFooProgressOptions) WithUpdateID(id string) *UpdateFooProgressOptions {
	o.id = &id
	return o
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowOptions
func (o *UpdateFooProgressOptions) WithUpdateWorkflowOptions(options client.UpdateWorkflowOptions) *UpdateFooProgressOptions {
	o.Options = &options
	return o
}

// WithWaitPolicy sets the WaitPolicy
func (o *UpdateFooProgressOptions) WithWaitPolicy(policy client.WorkflowUpdateStage) *UpdateFooProgressOptions {
	o.waitPolicy = policy
	return o
}

// Reference to generated workflow functions
var (
	// CreateFoo creates a new foo operation
	CreateFooFunction func(workflow.Context, *CreateFooRequest) (*CreateFooResponse, error)
)

// ExampleWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// ExampleWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	ExampleWorkflowFunctions interface {
		// CreateFoo creates a new foo operation
		CreateFoo(workflow.Context, *CreateFooRequest) (*CreateFooResponse, error)
	}
	// exampleWorkflowFunctions provides an internal ExampleWorkflowFunctions implementation
	exampleWorkflowFunctions struct{}
)

func NewExampleWorkflowFunctions() ExampleWorkflowFunctions {
	return &exampleWorkflowFunctions{}
}

// CreateFoo creates a new foo operation
func (f *exampleWorkflowFunctions) CreateFoo(ctx workflow.Context, req *CreateFooRequest) (*CreateFooResponse, error) {
	if CreateFooFunction == nil {
		return nil, errors.New("CreateFoo requires workflow registration via RegisterExampleWorkflows or RegisterCreateFooWorkflow")
	}
	return CreateFooFunction(ctx, req)
}

// ExampleWorkflows provides methods for initializing new example.xns.v1.Example workflow values
type ExampleWorkflows interface {
	// CreateFoo creates a new foo operation
	CreateFoo(ctx workflow.Context, input *CreateFooWorkflowInput) (CreateFooWorkflow, error)
}

// RegisterExampleWorkflows registers example.xns.v1.Example workflows with the given worker
func RegisterExampleWorkflows(r worker.WorkflowRegistry, workflows ExampleWorkflows) {
	RegisterCreateFooWorkflow(r, workflows.CreateFoo)
}

// RegisterCreateFooWorkflow registers a example.xns.v1.Example.CreateFoo workflow with the given worker
func RegisterCreateFooWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *CreateFooWorkflowInput) (CreateFooWorkflow, error)) {
	CreateFooFunction = buildCreateFoo(wf)
	r.RegisterWorkflowWithOptions(CreateFooFunction, workflow.RegisterOptions{Name: CreateFooWorkflowName})
}

// buildCreateFoo converts a CreateFoo workflow struct into a valid workflow function
func buildCreateFoo(ctor func(workflow.Context, *CreateFooWorkflowInput) (CreateFooWorkflow, error)) func(workflow.Context, *CreateFooRequest) (*CreateFooResponse, error) {
	return func(ctx workflow.Context, req *CreateFooRequest) (*CreateFooResponse, error) {
		input := &CreateFooWorkflowInput{
			Req: req,
			SetFooProgress: &SetFooProgressSignal{
				Channel: workflow.GetSignalChannel(ctx, SetFooProgressSignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		if err := workflow.SetQueryHandler(ctx, GetFooProgressQueryName, wf.GetFooProgress); err != nil {
			return nil, err
		}
		{
			opts := workflow.UpdateHandlerOptions{}
			if err := workflow.SetUpdateHandlerWithOptions(ctx, UpdateFooProgressUpdateName, wf.UpdateFooProgress, opts); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// CreateFooWorkflowInput describes the input to a(n) example.xns.v1.Example.CreateFoo workflow constructor
type CreateFooWorkflowInput struct {
	Req            *CreateFooRequest
	SetFooProgress *SetFooProgressSignal
}

// CreateFoo creates a new foo operation
//
// workflow details: (name: "example.xns.v1.Example.CreateFoo", id: "create-foo/${! name.slug() }")
type CreateFooWorkflow interface {
	// Execute defines the entrypoint to a(n) example.xns.v1.Example.CreateFoo workflow
	Execute(ctx workflow.Context) (*CreateFooResponse, error)

	// GetFooProgress returns the status of a CreateFoo operation
	GetFooProgress() (*GetFooProgressResponse, error)

	// UpdateFooProgress sets the current status of a CreateFoo operation
	UpdateFooProgress(workflow.Context, *SetFooProgressRequest) (*GetFooProgressResponse, error)
}

// CreateFoo creates a new foo operation
func CreateFooChild(ctx workflow.Context, req *CreateFooRequest, options ...*CreateFooChildOptions) (*CreateFooResponse, error) {
	childRun, err := CreateFooChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// CreateFoo creates a new foo operation
func CreateFooChildAsync(ctx workflow.Context, req *CreateFooRequest, options ...*CreateFooChildOptions) (*CreateFooChildRun, error) {
	var o *CreateFooChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateFooChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &CreateFooChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CreateFooWorkflowName, req)}, nil
}

// CreateFooChildOptions provides configuration for a child example.xns.v1.Example.CreateFoo workflow operation
type CreateFooChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewCreateFooChildOptions initializes a new CreateFooChildOptions value
func NewCreateFooChildOptions() *CreateFooChildOptions {
	return &CreateFooChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *CreateFooChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(CreateFooIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", CreateFooWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CreateFooWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(CreateFooIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CreateFooWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	} else if opts.WorkflowIDReusePolicy == enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = enumsv1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *CreateFooChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *CreateFooChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CreateFooChildOptions) WithExecutionTimeout(d time.Duration) *CreateFooChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *CreateFooChildOptions) WithID(id string) *CreateFooChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CreateFooChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CreateFooChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *CreateFooChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *CreateFooChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CreateFooChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CreateFooChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CreateFooChildOptions) WithRunTimeout(d time.Duration) *CreateFooChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CreateFooChildOptions) WithSearchAttributes(sa map[string]any) *CreateFooChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CreateFooChildOptions) WithTaskTimeout(d time.Duration) *CreateFooChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CreateFooChildOptions) WithTaskQueue(tq string) *CreateFooChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CreateFooChildOptions) WithWaitForCancellation(wait bool) *CreateFooChildOptions {
	o.waitForCancellation = &wait
	return o
}

// CreateFooChildRun describes a child CreateFoo workflow run
type CreateFooChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CreateFooChildRun) Get(ctx workflow.Context) (*CreateFooResponse, error) {
	var resp CreateFooResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CreateFooChildRun) Select(sel workflow.Selector, fn func(*CreateFooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CreateFooChildRun) SelectStart(sel workflow.Selector, fn func(*CreateFooChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CreateFooChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SetFooProgress sends a(n) "example.xns.v1.Example.SetFooProgress" signal request to the child workflow
func (r *CreateFooChildRun) SetFooProgress(ctx workflow.Context, input *SetFooProgressRequest) error {
	return r.SetFooProgressAsync(ctx, input).Get(ctx, nil)
}

// SetFooProgressAsync sends a(n) "example.xns.v1.Example.SetFooProgress" signal request to the child workflow
func (r *CreateFooChildRun) SetFooProgressAsync(ctx workflow.Context, input *SetFooProgressRequest) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SetFooProgressSignalName, input)
}

// SetFooProgressSignal describes a(n) example.xns.v1.Example.SetFooProgress signal
type SetFooProgressSignal struct {
	Channel workflow.ReceiveChannel
}

// NewSetFooProgressSignal initializes a new example.xns.v1.Example.SetFooProgress signal wrapper
func NewSetFooProgressSignal(ctx workflow.Context) *SetFooProgressSignal {
	return &SetFooProgressSignal{Channel: workflow.GetSignalChannel(ctx, SetFooProgressSignalName)}
}

// Receive blocks until a(n) example.xns.v1.Example.SetFooProgress signal is received
func (s *SetFooProgressSignal) Receive(ctx workflow.Context) (*SetFooProgressRequest, bool) {
	var resp SetFooProgressRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a example.xns.v1.Example.SetFooProgress signal without blocking
func (s *SetFooProgressSignal) ReceiveAsync() *SetFooProgressRequest {
	var resp SetFooProgressRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// ReceiveWithTimeout blocks until a(n) example.xns.v1.Example.SetFooProgress signal is received or timeout expires.
// Returns more value of false when Channel is closed.
// Returns ok value of false when no value was found in the channel for the duration of timeout or the ctx was canceled.
// resp will be nil if ok is false.
func (s *SetFooProgressSignal) ReceiveWithTimeout(ctx workflow.Context, timeout time.Duration) (resp *SetFooProgressRequest, ok bool, more bool) {
	resp = &SetFooProgressRequest{}
	if ok, more = s.Channel.ReceiveWithTimeout(ctx, timeout, &resp); !ok {
		return nil, false, more
	}
	return
}

// Select checks for a(n) example.xns.v1.Example.SetFooProgress signal without blocking
func (s *SetFooProgressSignal) Select(sel workflow.Selector, fn func(*SetFooProgressRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SetFooProgress sets the current status of a CreateFoo operation
func SetFooProgressExternal(ctx workflow.Context, workflowID string, runID string, req *SetFooProgressRequest) error {
	return SetFooProgressExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// SetFooProgress sets the current status of a CreateFoo operation
func SetFooProgressExternalAsync(ctx workflow.Context, workflowID string, runID string, req *SetFooProgressRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SetFooProgressSignalName, req)
}

// ExampleActivities describes available worker activities
type ExampleActivities interface {
	// Notify sends a notification
	Notify(ctx context.Context, req *NotifyRequest) error
}

// RegisterExampleActivities registers activities with a worker
func RegisterExampleActivities(r worker.ActivityRegistry, activities ExampleActivities) {
	RegisterNotifyActivity(r, activities.Notify)
}

// RegisterNotifyActivity registers a example.xns.v1.Example.Notify activity
func RegisterNotifyActivity(r worker.ActivityRegistry, fn func(context.Context, *NotifyRequest) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: NotifyActivityName,
	})
}

// NotifyFuture describes a(n) example.xns.v1.Example.Notify activity execution
type NotifyFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *NotifyFuture) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *NotifyFuture) Select(sel workflow.Selector, fn func(*NotifyFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// Notify sends a notification
func Notify(ctx workflow.Context, req *NotifyRequest, options ...*NotifyActivityOptions) error {
	return NotifyAsync(ctx, req, options...).Get(ctx)
}

// Notify sends a notification
func NotifyAsync(ctx workflow.Context, req *NotifyRequest, options ...*NotifyActivityOptions) *NotifyFuture {
	var o *NotifyActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewNotifyActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &NotifyFuture{Future: errF}
	}
	activity := NotifyActivityName
	future := &NotifyFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// Notify sends a notification
func NotifyLocal(ctx workflow.Context, req *NotifyRequest, options ...*NotifyLocalActivityOptions) error {
	return NotifyLocalAsync(ctx, req, options...).Get(ctx)
}

// Notify sends a notification
func NotifyLocalAsync(ctx workflow.Context, req *NotifyRequest, options ...*NotifyLocalActivityOptions) *NotifyFuture {
	var o *NotifyLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewNotifyLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &NotifyFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = NotifyActivityName
	}
	future := &NotifyFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// NotifyActivityOptions provides configuration for a(n) example.xns.v1.Example.Notify activity
type NotifyActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewNotifyActivityOptions initializes a new NotifyActivityOptions value
func NewNotifyActivityOptions() *NotifyActivityOptions {
	return &NotifyActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *NotifyActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ExampleTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *NotifyActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *NotifyActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *NotifyActivityOptions) WithHeartbeatTimeout(d time.Duration) *NotifyActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *NotifyActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *NotifyActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *NotifyActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *NotifyActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *NotifyActivityOptions) WithScheduleToStartTimeout(d time.Duration) *NotifyActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *NotifyActivityOptions) WithStartToCloseTimeout(d time.Duration) *NotifyActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *NotifyActivityOptions) WithTaskQueue(tq string) *NotifyActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *NotifyActivityOptions) WithWaitForCancellation(wait bool) *NotifyActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// NotifyLocalActivityOptions provides configuration for a(n) example.xns.v1.Example.Notify activity
type NotifyLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *NotifyRequest) error
}

// NewNotifyLocalActivityOptions initializes a new NotifyLocalActivityOptions value
func NewNotifyLocalActivityOptions() *NotifyLocalActivityOptions {
	return &NotifyLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *NotifyLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	} else if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(3)}
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 30000000000 // 30 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom example.xns.v1.Example.Notify implementation
func (o *NotifyLocalActivityOptions) Local(fn func(context.Context, *NotifyRequest) error) *NotifyLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *NotifyLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *NotifyLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *NotifyLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *NotifyLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *NotifyLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *NotifyLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *NotifyLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *NotifyLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestExampleClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ExampleWorkflows
}

var _ ExampleClient = &TestExampleClient{}

// NewTestExampleClient initializes a new TestExampleClient value
func NewTestExampleClient(env *testsuite.TestWorkflowEnvironment, workflows ExampleWorkflows, activities ExampleActivities) *TestExampleClient {
	if workflows != nil {
		RegisterExampleWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterExampleActivities(env, activities)
	}
	return &TestExampleClient{env, workflows}
}

// CreateFoo executes a(n) example.xns.v1.Example.CreateFoo workflow in the test environment
func (c *TestExampleClient) CreateFoo(ctx context.Context, req *CreateFooRequest, opts ...*CreateFooOptions) (*CreateFooResponse, error) {
	run, err := c.CreateFooAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateFooAsync executes a(n) example.xns.v1.Example.CreateFoo workflow in the test environment
func (c *TestExampleClient) CreateFooAsync(ctx context.Context, req *CreateFooRequest, options ...*CreateFooOptions) (CreateFooRun, error) {
	var o *CreateFooOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateFooOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testCreateFooRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCreateFoo is a noop
func (c *TestExampleClient) GetCreateFoo(ctx context.Context, workflowID string, runID string) CreateFooRun {
	return &testCreateFooRun{env: c.env, workflows: c.workflows}
}

// CreateFooWithSetFooProgress sends a(n) example.xns.v1.Example.SetFooProgress signal to a(n) example.xns.v1.Example.CreateFoo workflow, starting it if necessary
func (c *TestExampleClient) CreateFooWithSetFooProgress(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, opts ...*CreateFooOptions) (*CreateFooResponse, error) {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SetFooProgressSignalName, signal)
	}, 0)
	return c.CreateFoo(ctx, req, opts...)
}

// CreateFooWithSetFooProgressAsync sends a(n) example.xns.v1.Example.SetFooProgress signal to a(n) example.xns.v1.Example.CreateFoo workflow, starting it if necessary
func (c *TestExampleClient) CreateFooWithSetFooProgressAsync(ctx context.Context, req *CreateFooRequest, signal *SetFooProgressRequest, opts ...*CreateFooOptions) (CreateFooRun, error) {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SetFooProgressSignalName, signal)
	}, 0)
	return c.CreateFooAsync(ctx, req, opts...)
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestExampleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestExampleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// GetFooProgress executes a example.xns.v1.Example.GetFooProgress query
func (c *TestExampleClient) GetFooProgress(ctx context.Context, workflowID string, runID string) (*GetFooProgressResponse, error) {
	val, err := c.env.QueryWorkflow(GetFooProgressQueryName)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result GetFooProgressResponse
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SetFooProgress executes a example.xns.v1.Example.SetFooProgress signal
func (c *TestExampleClient) SetFooProgress(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest) error {
	c.env.SignalWorkflow(SetFooProgressSignalName, req)
	return nil
}

// UpdateFooProgress executes a(n) example.xns.v1.Example.UpdateFooProgress update in the test environment
func (c *TestExampleClient) UpdateFooProgress(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (*GetFooProgressResponse, error) {
	options := NewUpdateFooProgressOptions()
	if len(opts) > 0 && opts[0].Options != nil {
		options = opts[0]
	}
	options.Options.WaitForStage = client.WorkflowUpdateStageCompleted
	handle, err := c.UpdateFooProgressAsync(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// UpdateFooProgressAsync executes a(n) example.xns.v1.Example.UpdateFooProgress update in the test environment
func (c *TestExampleClient) UpdateFooProgressAsync(ctx context.Context, workflowID string, runID string, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (UpdateFooProgressHandle, error) {
	var o *UpdateFooProgressOptions
	if len(opts) > 0 && opts[0] != nil {
		o = opts[0]
	} else {
		o = NewUpdateFooProgressOptions()
	}
	options, err := o.Build(workflowID, runID, req)
	if err != nil {
		return nil, fmt.Errorf("error initializing UpdateWorkflowWithOptions: %w", err)
	}

	if options.UpdateID == "" {
		options.UpdateID = workflowID
	}

	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(UpdateFooProgressUpdateName, options.UpdateID, uc, req)
	return &testUpdateFooProgressHandle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

// GetUpdateFooProgress retrieves a handle to an existing example.xns.v1.Example.UpdateFooProgress update
func (c *TestExampleClient) GetUpdateFooProgress(ctx context.Context, req client.GetWorkflowUpdateHandleOptions) (UpdateFooProgressHandle, error) {
	return nil, errors.New("unimplemented")
}

var _ UpdateFooProgressHandle = &testUpdateFooProgressHandle{}

// testUpdateFooProgressHandle provides an internal implementation of a(n) UpdateFooProgressHandle
type testUpdateFooProgressHandle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowOptions
	req        *SetFooProgressRequest
	runID      string
	workflowID string
}

// Get retrieves a test example.xns.v1.Example.UpdateFooProgress update result
func (h *testUpdateFooProgressHandle) Get(ctx context.Context) (*GetFooProgressResponse, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*GetFooProgressResponse), nil
	}
}

// RunID implementation
func (h *testUpdateFooProgressHandle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testUpdateFooProgressHandle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testUpdateFooProgressHandle) WorkflowID() string {
	return h.workflowID
}

var _ CreateFooRun = &testCreateFooRun{}

// testCreateFooRun provides convenience methods for interacting with a(n) example.xns.v1.Example.CreateFoo workflow in the test environment
type testCreateFooRun struct {
	client    *TestExampleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *CreateFooRequest
	workflows ExampleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testCreateFooRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.xns.v1.Example.CreateFoo workflow result
func (r *testCreateFooRun) Get(context.Context) (*CreateFooResponse, error) {
	r.env.ExecuteWorkflow(CreateFooWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result CreateFooResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.xns.v1.Example.CreateFoo workflow run's workflow ID
func (r *testCreateFooRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testCreateFooRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testCreateFooRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testCreateFooRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// GetFooProgress executes a example.xns.v1.Example.GetFooProgress query against a test example.xns.v1.Example.CreateFoo workflow
func (r *testCreateFooRun) GetFooProgress(ctx context.Context) (*GetFooProgressResponse, error) {
	return r.client.GetFooProgress(ctx, r.ID(), r.RunID())
}

// SetFooProgress executes a example.xns.v1.Example.SetFooProgress signal against a test example.xns.v1.Example.CreateFoo workflow
func (r *testCreateFooRun) SetFooProgress(ctx context.Context, req *SetFooProgressRequest) error {
	return r.client.SetFooProgress(ctx, r.ID(), r.RunID(), req)
}

// UpdateFooProgress executes a(n) example.xns.v1.Example.UpdateFooProgress update against a test example.xns.v1.Example.CreateFoo workflow
func (r *testCreateFooRun) UpdateFooProgress(ctx context.Context, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (*GetFooProgressResponse, error) {
	return r.client.UpdateFooProgress(ctx, r.ID(), r.RunID(), req, opts...)
}

// UpdateFooProgressAsync executes a(n) example.xns.v1.Example.UpdateFooProgress update against a test example.xns.v1.Example.CreateFoo workflow
func (r *testCreateFooRun) UpdateFooProgressAsync(ctx context.Context, req *SetFooProgressRequest, opts ...*UpdateFooProgressOptions) (UpdateFooProgressHandle, error) {
	return r.client.UpdateFooProgressAsync(ctx, r.ID(), r.RunID(), req, opts...)
}

// ExampleCliOptions describes runtime configuration for example.xns.v1.Example cli
type ExampleCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewExampleCliOptions initializes a new ExampleCliOptions value
func NewExampleCliOptions() *ExampleCliOptions {
	return &ExampleCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ExampleCliOptions) WithAfter(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ExampleCliOptions) WithBefore(fn func(*v2.Context) error) *ExampleCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ExampleCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ExampleCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ExampleCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ExampleCliOptions {
	opts.worker = fn
	return opts
}

// NewExampleCli initializes a cli for a(n) example.xns.v1.Example service
func NewExampleCli(options ...*ExampleCliOptions) (*v2.App, error) {
	commands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "example",
		Commands: commands,
	}, nil
}

// NewExampleCliCommand initializes a cli command for a example.xns.v1.Example service with subcommands for each query, signal, update, and workflow
func NewExampleCliCommand(options ...*ExampleCliOptions) (*v2.Command, error) {
	subcommands, err := newExampleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "example",
		Subcommands: subcommands,
	}, nil
}

// newExampleCommands initializes (sub)commands for a example.xns.v1.Example cli or command
func newExampleCommands(options ...*ExampleCliOptions) ([]*v2.Command, error) {
	opts := &ExampleCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "get-foo-progress",
			Usage:                  "GetFooProgress returns the status of a CreateFoo operation",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				if resp, err := client.GetFooProgress(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", GetFooProgressQueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "set-foo-progress",
			Usage:                  "SetFooProgress sets the current status of a CreateFoo operation",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.Float64Flag{
					Name:     "progress",
					Usage:    "value of current workflow progress",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToSetFooProgressRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SetFooProgress(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SetFooProgressSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		{
			Name:                   "update-foo-progress",
			Usage:                  "UpdateFooProgress sets the current status of a CreateFoo operation",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow update in the background and print workflow, execution, and udpate id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.Float64Flag{
					Name:     "progress",
					Usage:    "value of current workflow progress",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToSetFooProgressRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.UpdateFooProgressAsync(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", UpdateFooProgressUpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		{
			Name:                   "create-foo",
			Usage:                  "CreateFoo creates a new foo operation",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "example-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "unique foo name",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewExampleClient(tc)
				req, err := UnmarshalCliFlagsToCreateFooRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.CreateFooAsync(cmd.Context, req, NewCreateFooOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CreateFooWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// sends a example.xns.v1.Example.SetFooProgress signal to a example.xns.v1.Example.CreateFoo workflow, starting it if necessary,
		{
			Name:                   "create-foo-with-set-foo-progress",
			Usage:                  "sends a example.xns.v1.Example.SetFooProgress signal to a example.xns.v1.Example.CreateFoo workflow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "unique foo name",
					Category: "INPUT",
				},
				&v2.Float64Flag{
					Name:     "progress",
					Usage:    "value of current workflow progress",
					Category: "SIGNAL",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewExampleClient(c)
				req, err := UnmarshalCliFlagsToCreateFooRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := UnmarshalCliFlagsToSetFooProgressRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.CreateFooWithSetFooProgressAsync(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", CreateFooWorkflowName, SetFooProgressSignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.xns.v1.Example worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToSetFooProgressRequest unmarshals a SetFooProgressRequest from command line flags
func UnmarshalCliFlagsToSetFooProgressRequest(cmd *v2.Context) (*SetFooProgressRequest, error) {
	var result SetFooProgressRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("progress") {
		hasValues = true
		result.Progress = float32(cmd.Float64("progress"))
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// UnmarshalCliFlagsToCreateFooRequest unmarshals a CreateFooRequest from command line flags
func UnmarshalCliFlagsToCreateFooRequest(cmd *v2.Context) (*CreateFooRequest, error) {
	var result CreateFooRequest
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("name") {
		hasValues = true
		result.Name = cmd.String("name")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithExampleSchemeTypes registers all Example protobuf types with the given scheme
func WithExampleSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("NotifyRequest"))
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("GetFooProgressResponse"))
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("SetFooProgressRequest"))
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("CreateFooRequest"))
		s.RegisterType(File_example_xns_v1_xns_proto.Messages().ByName("CreateFooResponse"))
	}
}
