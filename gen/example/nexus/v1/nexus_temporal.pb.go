// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal dev (latest)
//	protoc (unknown)
//
// source: example/nexus/v1/nexus.proto
package nexusv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	gohomedir "github.com/mitchellh/go-homedir"
	cliv3 "github.com/urfave/cli/v3"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	converter "go.temporal.io/sdk/converter"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"sync/atomic"
	"time"
)

// GreetingServiceTaskQueue is the default task-queue for a example.nexus.v1.GreetingService worker
var GreetingServiceTaskQueue = "greeting-v1"

// example.nexus.v1.GreetingService workflow names
const (
	HelloWorkflowName = "example.nexus.v1.GreetingService.Hello"
)

// example.nexus.v1.GreetingService workflow id expressions
var (
	HelloIdexpression = expression.MustParseExpression("example.nexus.v1.Hello/${! language.or(throw(\"language required\")) }/${! name.slug() }")
)

// example.nexus.v1.GreetingService activity names
const (
	HelloActivityName = "example.nexus.v1.GreetingService.Hello"
)

// GreetingServiceClient describes a client for a(n) example.nexus.v1.GreetingService worker
type GreetingServiceClient interface {
	// generates a friendly greeting based on the input name and language
	Hello(ctx context.Context, req *HelloInput, opts ...*HelloOptions) (*HelloOutput, error)

	// HelloAsync starts a(n) example.nexus.v1.GreetingService.Hello workflow and returns a handle to the workflow run
	HelloAsync(ctx context.Context, req *HelloInput, opts ...*HelloOptions) (HelloRun, error)

	// GetHello retrieves a handle to an existing example.nexus.v1.GreetingService.Hello workflow execution
	GetHello(ctx context.Context, workflowID string, runID string) HelloRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// greetingServiceClient implements a temporal client for a example.nexus.v1.GreetingService service
type greetingServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewGreetingServiceClient initializes a new example.nexus.v1.GreetingService client
func NewGreetingServiceClient(c client.Client, options ...*greetingServiceClientOptions) GreetingServiceClient {
	var cfg *greetingServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewGreetingServiceClientOptions()
	}
	return &greetingServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewGreetingServiceClientWithOptions initializes a new GreetingService client with the given options
func NewGreetingServiceClientWithOptions(c client.Client, opts client.Options, options ...*greetingServiceClientOptions) (GreetingServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *greetingServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewGreetingServiceClientOptions()
	}
	return &greetingServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// greetingServiceClientOptions describes optional runtime configuration for a GreetingServiceClient
type greetingServiceClientOptions struct {
	log *slog.Logger
}

// NewGreetingServiceClientOptions initializes a new greetingServiceClientOptions value
func NewGreetingServiceClientOptions() *greetingServiceClientOptions {
	return &greetingServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *greetingServiceClientOptions) WithLogger(l *slog.Logger) *greetingServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *greetingServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// generates a friendly greeting based on the input name and language
func (c *greetingServiceClient) Hello(ctx context.Context, req *HelloInput, options ...*HelloOptions) (*HelloOutput, error) {
	run, err := c.HelloAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// generates a friendly greeting based on the input name and language
func (c *greetingServiceClient) HelloAsync(ctx context.Context, req *HelloInput, options ...*HelloOptions) (HelloRun, error) {
	var o *HelloOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewHelloOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, HelloWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &helloRun{
		client: c,
		run:    run,
	}, nil
}

// GetHello fetches an existing example.nexus.v1.GreetingService.Hello execution
func (c *greetingServiceClient) GetHello(ctx context.Context, workflowID string, runID string) HelloRun {
	return &helloRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *greetingServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *greetingServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// HelloOptions provides configuration for a example.nexus.v1.GreetingService.Hello workflow operation
type HelloOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewHelloOptions initializes a new HelloOptions value
func NewHelloOptions() *HelloOptions {
	return &HelloOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *HelloOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(HelloIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", HelloWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = GreetingServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *HelloOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *HelloOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *HelloOptions) WithExecutionTimeout(d time.Duration) *HelloOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *HelloOptions) WithID(id string) *HelloOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *HelloOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *HelloOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *HelloOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *HelloOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *HelloOptions) WithRunTimeout(d time.Duration) *HelloOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *HelloOptions) WithSearchAttributes(sa map[string]any) *HelloOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *HelloOptions) WithTaskTimeout(d time.Duration) *HelloOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *HelloOptions) WithTaskQueue(tq string) *HelloOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *HelloOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *HelloOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// HelloRun describes a(n) example.nexus.v1.GreetingService.Hello workflow run
type HelloRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*HelloOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// helloRun provides an internal implementation of a(n) HelloRunRun
type helloRun struct {
	client *greetingServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *helloRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *helloRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *helloRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *helloRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *helloRun) Get(ctx context.Context) (*HelloOutput, error) {
	var resp HelloOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *helloRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// generates a friendly greeting based on the input name and language
	HelloFunction func(workflow.Context, *HelloInput) (*HelloOutput, error)
)

// GreetingServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// GreetingServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	GreetingServiceWorkflowFunctions interface {
		// generates a friendly greeting based on the input name and language
		Hello(workflow.Context, *HelloInput) (*HelloOutput, error)
	}
	// greetingServiceWorkflowFunctions provides an internal GreetingServiceWorkflowFunctions implementation
	greetingServiceWorkflowFunctions struct{}
)

func NewGreetingServiceWorkflowFunctions() GreetingServiceWorkflowFunctions {
	return &greetingServiceWorkflowFunctions{}
}

// generates a friendly greeting based on the input name and language
func (f *greetingServiceWorkflowFunctions) Hello(ctx workflow.Context, req *HelloInput) (*HelloOutput, error) {
	if HelloFunction == nil {
		return nil, errors.New("Hello requires workflow registration via RegisterGreetingServiceWorkflows or RegisterHelloWorkflow")
	}
	return HelloFunction(ctx, req)
}

// GreetingServiceWorkflows provides methods for initializing new example.nexus.v1.GreetingService workflow values
type GreetingServiceWorkflows interface {
	// generates a friendly greeting based on the input name and language
	Hello(ctx workflow.Context, input *HelloWorkflowInput) (HelloWorkflow, error)
}

// RegisterGreetingServiceWorkflows registers example.nexus.v1.GreetingService workflows with the given worker
func RegisterGreetingServiceWorkflows(r worker.WorkflowRegistry, workflows GreetingServiceWorkflows) {
	RegisterHelloWorkflow(r, workflows.Hello)
}

// RegisterHelloWorkflow registers a example.nexus.v1.GreetingService.Hello workflow with the given worker
func RegisterHelloWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *HelloWorkflowInput) (HelloWorkflow, error)) {
	HelloFunction = buildHello(wf)
	r.RegisterWorkflowWithOptions(HelloFunction, workflow.RegisterOptions{Name: HelloWorkflowName})
}

// buildHello converts a Hello workflow struct into a valid workflow function
func buildHello(ctor func(workflow.Context, *HelloWorkflowInput) (HelloWorkflow, error)) func(workflow.Context, *HelloInput) (*HelloOutput, error) {
	return func(ctx workflow.Context, req *HelloInput) (*HelloOutput, error) {
		input := &HelloWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// HelloWorkflowInput describes the input to a(n) example.nexus.v1.GreetingService.Hello workflow constructor
type HelloWorkflowInput struct {
	Req *HelloInput
}

// generates a friendly greeting based on the input name and language
//
// workflow details: (name: "example.nexus.v1.GreetingService.Hello", id: "example.nexus.v1.Hello/${! language.or(throw("language required")) }/${! name.slug() }")
type HelloWorkflow interface {
	// Execute defines the entrypoint to a(n) example.nexus.v1.GreetingService.Hello workflow
	Execute(ctx workflow.Context) (*HelloOutput, error)
}

// generates a friendly greeting based on the input name and language
func HelloChild(ctx workflow.Context, req *HelloInput, options ...*HelloChildOptions) (*HelloOutput, error) {
	childRun, err := HelloChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// generates a friendly greeting based on the input name and language
func HelloChildAsync(ctx workflow.Context, req *HelloInput, options ...*HelloChildOptions) (*HelloChildRun, error) {
	var o *HelloChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewHelloChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &HelloChildRun{Future: workflow.ExecuteChildWorkflow(ctx, HelloWorkflowName, req)}, nil
}

// HelloChildOptions provides configuration for a child example.nexus.v1.GreetingService.Hello workflow operation
type HelloChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewHelloChildOptions initializes a new HelloChildOptions value
func NewHelloChildOptions() *HelloChildOptions {
	return &HelloChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *HelloChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(HelloIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", HelloWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", HelloWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(HelloIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", HelloWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = GreetingServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *HelloChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *HelloChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *HelloChildOptions) WithDataConverter(dc converter.DataConverter) *HelloChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *HelloChildOptions) WithExecutionTimeout(d time.Duration) *HelloChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *HelloChildOptions) WithID(id string) *HelloChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *HelloChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *HelloChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *HelloChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *HelloChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *HelloChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *HelloChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *HelloChildOptions) WithRunTimeout(d time.Duration) *HelloChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *HelloChildOptions) WithSearchAttributes(sa map[string]any) *HelloChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *HelloChildOptions) WithTaskTimeout(d time.Duration) *HelloChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *HelloChildOptions) WithTaskQueue(tq string) *HelloChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *HelloChildOptions) WithWaitForCancellation(wait bool) *HelloChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *HelloChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *HelloChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// HelloChildRun describes a child Hello workflow run
type HelloChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *HelloChildRun) Get(ctx workflow.Context) (*HelloOutput, error) {
	var resp HelloOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *HelloChildRun) Select(sel workflow.Selector, fn func(*HelloChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *HelloChildRun) SelectStart(sel workflow.Selector, fn func(*HelloChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *HelloChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// GreetingServiceActivities describes available worker activities
type GreetingServiceActivities interface {
	// generates a friendly greeting based on the input name and language
	Hello(ctx context.Context, req *HelloInput) (*HelloOutput, error)
}

// RegisterGreetingServiceActivities registers activities with a worker
func RegisterGreetingServiceActivities(r worker.ActivityRegistry, activities GreetingServiceActivities) {
	RegisterHelloActivity(r, activities.Hello)
}

// RegisterHelloActivity registers a example.nexus.v1.GreetingService.Hello activity
func RegisterHelloActivity(r worker.ActivityRegistry, fn func(context.Context, *HelloInput) (*HelloOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: HelloActivityName,
	})
}

// HelloFuture describes a(n) example.nexus.v1.GreetingService.Hello activity execution
type HelloFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *HelloFuture) Get(ctx workflow.Context) (*HelloOutput, error) {
	var resp HelloOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *HelloFuture) Select(sel workflow.Selector, fn func(*HelloFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// generates a friendly greeting based on the input name and language
func Hello(ctx workflow.Context, req *HelloInput, options ...*HelloActivityOptions) (*HelloOutput, error) {
	return HelloAsync(ctx, req, options...).Get(ctx)
}

// generates a friendly greeting based on the input name and language
func HelloAsync(ctx workflow.Context, req *HelloInput, options ...*HelloActivityOptions) *HelloFuture {
	var o *HelloActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewHelloActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &HelloFuture{Future: errF}
	}
	activity := HelloActivityName
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &HelloFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// generates a friendly greeting based on the input name and language
func HelloLocal(ctx workflow.Context, req *HelloInput, options ...*HelloLocalActivityOptions) (*HelloOutput, error) {
	return HelloLocalAsync(ctx, req, options...).Get(ctx)
}

// generates a friendly greeting based on the input name and language
func HelloLocalAsync(ctx workflow.Context, req *HelloInput, options ...*HelloLocalActivityOptions) *HelloFuture {
	var o *HelloLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewHelloLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &HelloFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = HelloActivityName
	}
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	future := &HelloFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// HelloActivityOptions provides configuration for a(n) example.nexus.v1.GreetingService.Hello activity
type HelloActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewHelloActivityOptions initializes a new HelloActivityOptions value
func NewHelloActivityOptions() *HelloActivityOptions {
	return &HelloActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *HelloActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = GreetingServiceTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *HelloActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *HelloActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *HelloActivityOptions) WithDataConverter(dc converter.DataConverter) *HelloActivityOptions {
	o.dc = dc
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *HelloActivityOptions) WithHeartbeatTimeout(d time.Duration) *HelloActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *HelloActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *HelloActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *HelloActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *HelloActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *HelloActivityOptions) WithScheduleToStartTimeout(d time.Duration) *HelloActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *HelloActivityOptions) WithStartToCloseTimeout(d time.Duration) *HelloActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *HelloActivityOptions) WithTaskQueue(tq string) *HelloActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *HelloActivityOptions) WithWaitForCancellation(wait bool) *HelloActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// HelloLocalActivityOptions provides configuration for a(n) example.nexus.v1.GreetingService.Hello activity
type HelloLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	dc                     converter.DataConverter
	fn                     func(context.Context, *HelloInput) (*HelloOutput, error)
}

// NewHelloLocalActivityOptions initializes a new HelloLocalActivityOptions value
func NewHelloLocalActivityOptions() *HelloLocalActivityOptions {
	return &HelloLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *HelloLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 5000000000 // 5 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom example.nexus.v1.GreetingService.Hello implementation
func (o *HelloLocalActivityOptions) Local(fn func(context.Context, *HelloInput) (*HelloOutput, error)) *HelloLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *HelloLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *HelloLocalActivityOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the (local) activity
func (o *HelloLocalActivityOptions) WithDataConverter(dc converter.DataConverter) *HelloLocalActivityOptions {
	o.dc = dc
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *HelloLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *HelloLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *HelloLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *HelloLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *HelloLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *HelloLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestGreetingServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows GreetingServiceWorkflows
}

var _ GreetingServiceClient = &TestGreetingServiceClient{}

// NewTestGreetingServiceClient initializes a new TestGreetingServiceClient value
func NewTestGreetingServiceClient(env *testsuite.TestWorkflowEnvironment, workflows GreetingServiceWorkflows, activities GreetingServiceActivities) *TestGreetingServiceClient {
	if workflows != nil {
		RegisterGreetingServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterGreetingServiceActivities(env, activities)
	}
	return &TestGreetingServiceClient{env, workflows}
}

// Hello executes a(n) example.nexus.v1.GreetingService.Hello workflow in the test environment
func (c *TestGreetingServiceClient) Hello(ctx context.Context, req *HelloInput, opts ...*HelloOptions) (*HelloOutput, error) {
	run, err := c.HelloAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// HelloAsync executes a(n) example.nexus.v1.GreetingService.Hello workflow in the test environment
func (c *TestGreetingServiceClient) HelloAsync(ctx context.Context, req *HelloInput, options ...*HelloOptions) (HelloRun, error) {
	var o *HelloOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewHelloOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testHelloRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetHello is a noop
func (c *TestGreetingServiceClient) GetHello(ctx context.Context, workflowID string, runID string) HelloRun {
	return &testHelloRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestGreetingServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestGreetingServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ HelloRun = &testHelloRun{}

// testHelloRun provides convenience methods for interacting with a(n) example.nexus.v1.GreetingService.Hello workflow in the test environment
type testHelloRun struct {
	client    *TestGreetingServiceClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *HelloInput
	workflows GreetingServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testHelloRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.nexus.v1.GreetingService.Hello workflow result
func (r *testHelloRun) Get(context.Context) (*HelloOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(HelloWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result HelloOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.nexus.v1.GreetingService.Hello workflow run's workflow ID
func (r *testHelloRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testHelloRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testHelloRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testHelloRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// GreetingServiceCliOptions describes runtime configuration for example.nexus.v1.GreetingService cli v3
type GreetingServiceCliOptions struct {
	after            func(context.Context, *cliv3.Command) error
	before           func(context.Context, *cliv3.Command) (context.Context, error)
	clientForCommand func(context.Context, *cliv3.Command) (client.Client, error)
	worker           func(context.Context, *cliv3.Command, client.Client) (worker.Worker, error)
}

// NewGreetingServiceCliOptions initializes a new GreetingServiceCliOptions value
func NewGreetingServiceCliOptions() *GreetingServiceCliOptions {
	return &GreetingServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *GreetingServiceCliOptions) WithAfter(fn func(context.Context, *cliv3.Command) error) *GreetingServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *GreetingServiceCliOptions) WithBefore(fn func(context.Context, *cliv3.Command) (context.Context, error)) *GreetingServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *GreetingServiceCliOptions) WithClient(fn func(context.Context, *cliv3.Command) (client.Client, error)) *GreetingServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *GreetingServiceCliOptions) WithWorker(fn func(context.Context, *cliv3.Command, client.Client) (worker.Worker, error)) *GreetingServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewGreetingServiceCli initializes a cli app for a(n) example.nexus.v1.GreetingService service
func NewGreetingServiceCli(options ...*GreetingServiceCliOptions) (*cliv3.Command, error) {
	commands, err := newGreetingServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &cliv3.Command{
		Name:                      "greeting",
		Usage:                     "example.nexus.v1.GreetingService operations",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// newGreetingServiceCommands initializes (sub)commands for a example.nexus.v1.GreetingService cli or command
func newGreetingServiceCommands(options ...*GreetingServiceCliOptions) ([]*cliv3.Command, error) {
	opts := &GreetingServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(ctx context.Context, cmd *cliv3.Command) (client.Client, error) {
			return client.DialContext(ctx, client.Options{})
		}
	}
	commands := []*cliv3.Command{
		{
			Name:                   "hello",
			Usage:                  "generates a friendly greeting based on the input name and language",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []cliv3.Flag{
				&cliv3.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&cliv3.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					Sources: cliv3.NewValueSourceChain(cliv3.EnvVar("TEMPORAL_TASK_QUEUE_NAME"), cliv3.EnvVar("TEMPORAL_TASK_QUEUE"), cliv3.EnvVar("TASK_QUEUE_NAME"), cliv3.EnvVar("TASK_QUEUE")),
					Value:   "greeting-v1",
				},
				&cliv3.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "name",
					Usage:    "set the value of the operation's \"Name\" parameter",
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "language",
					Usage:    "set the value of the operation's \"Language\" parameter (LANGUAGE_UNSPECIFIED, LANGUAGE_ENGLISH, LANGUAGE_SPANISH, LANGUAGE_FRENCH, LANGUAGE_GERMAN, LANGUAGE_TURKISH)",
					Category: "INPUT",
				},
			},
			Action: func(ctx context.Context, cmd *cliv3.Command) error {
				tc, err := opts.clientForCommand(ctx, cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewGreetingServiceClient(tc)
				req, err := UnmarshalCliFlagsToHelloInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.HelloAsync(ctx, req, NewHelloOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", HelloWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(ctx); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*cliv3.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.nexus.v1.GreetingService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(ctx context.Context, cmd *cliv3.Command) error {
					c, err := opts.clientForCommand(ctx, cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(ctx, cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-ctx.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToHelloInput unmarshals a HelloInput from command line flags
func UnmarshalCliFlagsToHelloInput(cmd *cliv3.Command, options ...helpers.UnmarshalCliFlagsOptions) (*HelloInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result HelloInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("name"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Name = value
	}
	if flag := opts.FlagName("language"); cmd.IsSet(flag) {
		enumID, ok := Language_value[cmd.String(flag)]
		if !ok {
			return nil, fmt.Errorf("invalid value for enum field %s", "Language")
		}
		value := Language(enumID)
		result.Language = value
	}
	return &result, nil
}

// EchoServiceTaskQueue is the default task-queue for a example.nexus.v1.EchoService worker
var EchoServiceTaskQueue = "echo-v1"

// example.nexus.v1.EchoService workflow names
const (
	EchoWorkflowName = "example.nexus.v1.EchoService.Echo"
)

// example.nexus.v1.EchoService workflow id expressions
var (
	EchoIdexpression = expression.MustParseExpression("example.nexus.v1.Echo/${! language.or(throw(\"language required\")) }/${! name.slug() }")
)

// EchoServiceClient describes a client for a(n) example.nexus.v1.EchoService worker
type EchoServiceClient interface {
	// echoes back the input string
	Echo(ctx context.Context, req *EchoInput, opts ...*EchoOptions) (*EchoOutput, error)

	// EchoAsync starts a(n) example.nexus.v1.EchoService.Echo workflow and returns a handle to the workflow run
	EchoAsync(ctx context.Context, req *EchoInput, opts ...*EchoOptions) (EchoRun, error)

	// GetEcho retrieves a handle to an existing example.nexus.v1.EchoService.Echo workflow execution
	GetEcho(ctx context.Context, workflowID string, runID string) EchoRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// echoServiceClient implements a temporal client for a example.nexus.v1.EchoService service
type echoServiceClient struct {
	client client.Client
	log    *slog.Logger
}

// NewEchoServiceClient initializes a new example.nexus.v1.EchoService client
func NewEchoServiceClient(c client.Client, options ...*echoServiceClientOptions) EchoServiceClient {
	var cfg *echoServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewEchoServiceClientOptions()
	}
	return &echoServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewEchoServiceClientWithOptions initializes a new EchoService client with the given options
func NewEchoServiceClientWithOptions(c client.Client, opts client.Options, options ...*echoServiceClientOptions) (EchoServiceClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *echoServiceClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewEchoServiceClientOptions()
	}
	return &echoServiceClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// echoServiceClientOptions describes optional runtime configuration for a EchoServiceClient
type echoServiceClientOptions struct {
	log *slog.Logger
}

// NewEchoServiceClientOptions initializes a new echoServiceClientOptions value
func NewEchoServiceClientOptions() *echoServiceClientOptions {
	return &echoServiceClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *echoServiceClientOptions) WithLogger(l *slog.Logger) *echoServiceClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *echoServiceClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// echoes back the input string
func (c *echoServiceClient) Echo(ctx context.Context, req *EchoInput, options ...*EchoOptions) (*EchoOutput, error) {
	run, err := c.EchoAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// echoes back the input string
func (c *echoServiceClient) EchoAsync(ctx context.Context, req *EchoInput, options ...*EchoOptions) (EchoRun, error) {
	var o *EchoOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewEchoOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, EchoWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &echoRun{
		client: c,
		run:    run,
	}, nil
}

// GetEcho fetches an existing example.nexus.v1.EchoService.Echo execution
func (c *echoServiceClient) GetEcho(ctx context.Context, workflowID string, runID string) EchoRun {
	return &echoRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *echoServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *echoServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// EchoOptions provides configuration for a example.nexus.v1.EchoService.Echo workflow operation
type EchoOptions struct {
	options                  client.StartWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
}

// NewEchoOptions initializes a new EchoOptions value
func NewEchoOptions() *EchoOptions {
	return &EchoOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *EchoOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(EchoIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", EchoWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.workflowIdConflictPolicy; v != enumsv1.WORKFLOW_ID_CONFLICT_POLICY_UNSPECIFIED {
		opts.WorkflowIDConflictPolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = EchoServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *EchoOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *EchoOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *EchoOptions) WithExecutionTimeout(d time.Duration) *EchoOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *EchoOptions) WithID(id string) *EchoOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *EchoOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *EchoOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *EchoOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *EchoOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *EchoOptions) WithRunTimeout(d time.Duration) *EchoOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *EchoOptions) WithSearchAttributes(sa map[string]any) *EchoOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *EchoOptions) WithTaskTimeout(d time.Duration) *EchoOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *EchoOptions) WithTaskQueue(tq string) *EchoOptions {
	o.taskQueue = &tq
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *EchoOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *EchoOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// EchoRun describes a(n) example.nexus.v1.EchoService.Echo workflow run
type EchoRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*EchoOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// echoRun provides an internal implementation of a(n) EchoRunRun
type echoRun struct {
	client *echoServiceClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *echoRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *echoRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *echoRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *echoRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *echoRun) Get(ctx context.Context) (*EchoOutput, error) {
	var resp EchoOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *echoRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// echoes back the input string
	EchoFunction func(workflow.Context, *EchoInput) (*EchoOutput, error)
)

// EchoServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// EchoServiceWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	EchoServiceWorkflowFunctions interface {
		// echoes back the input string
		Echo(workflow.Context, *EchoInput) (*EchoOutput, error)
	}
	// echoServiceWorkflowFunctions provides an internal EchoServiceWorkflowFunctions implementation
	echoServiceWorkflowFunctions struct{}
)

func NewEchoServiceWorkflowFunctions() EchoServiceWorkflowFunctions {
	return &echoServiceWorkflowFunctions{}
}

// echoes back the input string
func (f *echoServiceWorkflowFunctions) Echo(ctx workflow.Context, req *EchoInput) (*EchoOutput, error) {
	if EchoFunction == nil {
		return nil, errors.New("Echo requires workflow registration via RegisterEchoServiceWorkflows or RegisterEchoWorkflow")
	}
	return EchoFunction(ctx, req)
}

// EchoServiceWorkflows provides methods for initializing new example.nexus.v1.EchoService workflow values
type EchoServiceWorkflows interface {
	// echoes back the input string
	Echo(ctx workflow.Context, input *EchoWorkflowInput) (EchoWorkflow, error)
}

// RegisterEchoServiceWorkflows registers example.nexus.v1.EchoService workflows with the given worker
func RegisterEchoServiceWorkflows(r worker.WorkflowRegistry, workflows EchoServiceWorkflows) {
	RegisterEchoWorkflow(r, workflows.Echo)
}

// RegisterEchoWorkflow registers a example.nexus.v1.EchoService.Echo workflow with the given worker
func RegisterEchoWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *EchoWorkflowInput) (EchoWorkflow, error)) {
	EchoFunction = buildEcho(wf)
	r.RegisterWorkflowWithOptions(EchoFunction, workflow.RegisterOptions{Name: EchoWorkflowName})
}

// buildEcho converts a Echo workflow struct into a valid workflow function
func buildEcho(ctor func(workflow.Context, *EchoWorkflowInput) (EchoWorkflow, error)) func(workflow.Context, *EchoInput) (*EchoOutput, error) {
	return func(ctx workflow.Context, req *EchoInput) (*EchoOutput, error) {
		input := &EchoWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// EchoWorkflowInput describes the input to a(n) example.nexus.v1.EchoService.Echo workflow constructor
type EchoWorkflowInput struct {
	Req *EchoInput
}

// echoes back the input string
//
// workflow details: (name: "example.nexus.v1.EchoService.Echo", id: "example.nexus.v1.Echo/${! language.or(throw("language required")) }/${! name.slug() }")
type EchoWorkflow interface {
	// Execute defines the entrypoint to a(n) example.nexus.v1.EchoService.Echo workflow
	Execute(ctx workflow.Context) (*EchoOutput, error)
}

// echoes back the input string
func EchoChild(ctx workflow.Context, req *EchoInput, options ...*EchoChildOptions) (*EchoOutput, error) {
	childRun, err := EchoChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// echoes back the input string
func EchoChildAsync(ctx workflow.Context, req *EchoInput, options ...*EchoChildOptions) (*EchoChildRun, error) {
	var o *EchoChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewEchoChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	if o.dc != nil {
		ctx = workflow.WithDataConverter(ctx, o.dc)
	}
	return &EchoChildRun{Future: workflow.ExecuteChildWorkflow(ctx, EchoWorkflowName, req)}, nil
}

// EchoChildOptions provides configuration for a child example.nexus.v1.EchoService.Echo workflow operation
type EchoChildOptions struct {
	options                  workflow.ChildWorkflowOptions
	executionTimeout         *time.Duration
	id                       *string
	idReusePolicy            enumsv1.WorkflowIdReusePolicy
	retryPolicy              *temporal.RetryPolicy
	runTimeout               *time.Duration
	searchAttributes         map[string]any
	taskQueue                *string
	taskTimeout              *time.Duration
	workflowIdConflictPolicy enumsv1.WorkflowIdConflictPolicy
	dc                       converter.DataConverter
	parentClosePolicy        enumsv1.ParentClosePolicy
	waitForCancellation      *bool
}

// NewEchoChildOptions initializes a new EchoChildOptions value
func NewEchoChildOptions() *EchoChildOptions {
	return &EchoChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *EchoChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(EchoIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", EchoWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", EchoWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(EchoIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", EchoWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = EchoServiceTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *EchoChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *EchoChildOptions {
	o.options = options
	return o
}

// WithDataConverter registers a DataConverter for the child workflow
func (o *EchoChildOptions) WithDataConverter(dc converter.DataConverter) *EchoChildOptions {
	o.dc = dc
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *EchoChildOptions) WithExecutionTimeout(d time.Duration) *EchoChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *EchoChildOptions) WithID(id string) *EchoChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *EchoChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *EchoChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *EchoChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *EchoChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *EchoChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *EchoChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *EchoChildOptions) WithRunTimeout(d time.Duration) *EchoChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *EchoChildOptions) WithSearchAttributes(sa map[string]any) *EchoChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *EchoChildOptions) WithTaskTimeout(d time.Duration) *EchoChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *EchoChildOptions) WithTaskQueue(tq string) *EchoChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *EchoChildOptions) WithWaitForCancellation(wait bool) *EchoChildOptions {
	o.waitForCancellation = &wait
	return o
}

// WithWorkflowIdConflictPolicy sets the WorkflowIdConflictPolicy value
func (o *EchoChildOptions) WithWorkflowIdConflictPolicy(policy enumsv1.WorkflowIdConflictPolicy) *EchoChildOptions {
	o.workflowIdConflictPolicy = policy
	return o
}

// EchoChildRun describes a child Echo workflow run
type EchoChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *EchoChildRun) Get(ctx workflow.Context) (*EchoOutput, error) {
	var resp EchoOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *EchoChildRun) Select(sel workflow.Selector, fn func(*EchoChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *EchoChildRun) SelectStart(sel workflow.Selector, fn func(*EchoChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *EchoChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// EchoServiceActivities describes available worker activities
type EchoServiceActivities interface{}

// RegisterEchoServiceActivities registers activities with a worker
func RegisterEchoServiceActivities(r worker.ActivityRegistry, activities EchoServiceActivities) {}

// TestClient provides a testsuite-compatible Client
type TestEchoServiceClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows EchoServiceWorkflows
}

var _ EchoServiceClient = &TestEchoServiceClient{}

// NewTestEchoServiceClient initializes a new TestEchoServiceClient value
func NewTestEchoServiceClient(env *testsuite.TestWorkflowEnvironment, workflows EchoServiceWorkflows, activities EchoServiceActivities) *TestEchoServiceClient {
	if workflows != nil {
		RegisterEchoServiceWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterEchoServiceActivities(env, activities)
	}
	return &TestEchoServiceClient{env, workflows}
}

// Echo executes a(n) example.nexus.v1.EchoService.Echo workflow in the test environment
func (c *TestEchoServiceClient) Echo(ctx context.Context, req *EchoInput, opts ...*EchoOptions) (*EchoOutput, error) {
	run, err := c.EchoAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// EchoAsync executes a(n) example.nexus.v1.EchoService.Echo workflow in the test environment
func (c *TestEchoServiceClient) EchoAsync(ctx context.Context, req *EchoInput, options ...*EchoOptions) (EchoRun, error) {
	var o *EchoOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewEchoOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testEchoRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetEcho is a noop
func (c *TestEchoServiceClient) GetEcho(ctx context.Context, workflowID string, runID string) EchoRun {
	return &testEchoRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestEchoServiceClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestEchoServiceClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ EchoRun = &testEchoRun{}

// testEchoRun provides convenience methods for interacting with a(n) example.nexus.v1.EchoService.Echo workflow in the test environment
type testEchoRun struct {
	client    *TestEchoServiceClient
	env       *testsuite.TestWorkflowEnvironment
	isStarted atomic.Bool
	opts      *client.StartWorkflowOptions
	req       *EchoInput
	workflows EchoServiceWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testEchoRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.nexus.v1.EchoService.Echo workflow result
func (r *testEchoRun) Get(context.Context) (*EchoOutput, error) {
	if r.isStarted.CompareAndSwap(false, true) {
		r.env.ExecuteWorkflow(EchoWorkflowName, r.req)
	}
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result EchoOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.nexus.v1.EchoService.Echo workflow run's workflow ID
func (r *testEchoRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testEchoRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testEchoRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testEchoRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// EchoServiceCliOptions describes runtime configuration for example.nexus.v1.EchoService cli v3
type EchoServiceCliOptions struct {
	after            func(context.Context, *cliv3.Command) error
	before           func(context.Context, *cliv3.Command) (context.Context, error)
	clientForCommand func(context.Context, *cliv3.Command) (client.Client, error)
	worker           func(context.Context, *cliv3.Command, client.Client) (worker.Worker, error)
}

// NewEchoServiceCliOptions initializes a new EchoServiceCliOptions value
func NewEchoServiceCliOptions() *EchoServiceCliOptions {
	return &EchoServiceCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *EchoServiceCliOptions) WithAfter(fn func(context.Context, *cliv3.Command) error) *EchoServiceCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *EchoServiceCliOptions) WithBefore(fn func(context.Context, *cliv3.Command) (context.Context, error)) *EchoServiceCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *EchoServiceCliOptions) WithClient(fn func(context.Context, *cliv3.Command) (client.Client, error)) *EchoServiceCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *EchoServiceCliOptions) WithWorker(fn func(context.Context, *cliv3.Command, client.Client) (worker.Worker, error)) *EchoServiceCliOptions {
	opts.worker = fn
	return opts
}

// NewEchoServiceCli initializes a cli app for a(n) example.nexus.v1.EchoService service
func NewEchoServiceCli(options ...*EchoServiceCliOptions) (*cliv3.Command, error) {
	commands, err := newEchoServiceCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &cliv3.Command{
		Name:                      "echo",
		Usage:                     "example.nexus.v1.EchoService operations",
		Commands:                  commands,
		DisableSliceFlagSeparator: true,
	}, nil
}

// newEchoServiceCommands initializes (sub)commands for a example.nexus.v1.EchoService cli or command
func newEchoServiceCommands(options ...*EchoServiceCliOptions) ([]*cliv3.Command, error) {
	opts := &EchoServiceCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(ctx context.Context, cmd *cliv3.Command) (client.Client, error) {
			return client.DialContext(ctx, client.Options{})
		}
	}
	commands := []*cliv3.Command{
		{
			Name:                   "echo",
			Usage:                  "echoes back the input string",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []cliv3.Flag{
				&cliv3.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&cliv3.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					Sources: cliv3.NewValueSourceChain(cliv3.EnvVar("TEMPORAL_TASK_QUEUE_NAME"), cliv3.EnvVar("TEMPORAL_TASK_QUEUE"), cliv3.EnvVar("TASK_QUEUE_NAME"), cliv3.EnvVar("TASK_QUEUE")),
					Value:   "echo-v1",
				},
				&cliv3.StringFlag{
					Name:     "input-file",
					Usage:    "path to json-formatted input file",
					Aliases:  []string{"f"},
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "name",
					Usage:    "set the value of the operation's \"Name\" parameter",
					Category: "INPUT",
				},
				&cliv3.StringFlag{
					Name:     "language",
					Usage:    "set the value of the operation's \"Language\" parameter (LANGUAGE_UNSPECIFIED, LANGUAGE_ENGLISH, LANGUAGE_SPANISH, LANGUAGE_FRENCH, LANGUAGE_GERMAN, LANGUAGE_TURKISH)",
					Category: "INPUT",
				},
			},
			Action: func(ctx context.Context, cmd *cliv3.Command) error {
				tc, err := opts.clientForCommand(ctx, cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewEchoServiceClient(tc)
				req, err := UnmarshalCliFlagsToEchoInput(cmd, helpers.UnmarshalCliFlagsOptions{FromFile: "input-file"})
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.EchoAsync(ctx, req, NewEchoOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", EchoWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(ctx); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*cliv3.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.nexus.v1.EchoService worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(ctx context.Context, cmd *cliv3.Command) error {
					c, err := opts.clientForCommand(ctx, cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(ctx, cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-ctx.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToEchoInput unmarshals a EchoInput from command line flags
func UnmarshalCliFlagsToEchoInput(cmd *cliv3.Command, options ...helpers.UnmarshalCliFlagsOptions) (*EchoInput, error) {
	opts := helpers.FlattenUnmarshalCliFlagsOptions(options...)
	var result EchoInput
	if opts.FromFile != "" && cmd.IsSet(opts.FromFile) {
		f, err := gohomedir.Expand(cmd.String(opts.FromFile))
		if err != nil {
			f = cmd.String(opts.FromFile)
		}
		b, err := os.ReadFile(f)
		if err != nil {
			return nil, fmt.Errorf("error reading %s: %w", opts.FromFile, err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing %s json: %w", opts.FromFile, err)
		}
	}
	if flag := opts.FlagName("name"); cmd.IsSet(flag) {
		value := cmd.String(flag)
		result.Name = value
	}
	if flag := opts.FlagName("language"); cmd.IsSet(flag) {
		enumID, ok := Language_value[cmd.String(flag)]
		if !ok {
			return nil, fmt.Errorf("invalid value for enum field %s", "Language")
		}
		value := Language(enumID)
		result.Language = value
	}
	return &result, nil
}
