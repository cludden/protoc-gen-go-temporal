// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.14.4-next (d2f9bfc0a16171313109a7b80bc10fabc41196e0)
//	go go1.22.6
//	protoc (unknown)
//
// source: example/nexus/v1/nexus.proto
package nexusv1

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	errs "github.com/cludden/protoc-gen-go-temporal/pkg/errs"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	nexus "github.com/nexus-rpc/sdk-go/nexus"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	temporalnexus "go.temporal.io/sdk/temporalnexus"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	"log/slog"
	"os"
	"sort"
	"time"
)

// =============================================================================
// Constants (example.nexus.v1.Orders)
// =============================================================================

// OrdersTaskQueue is the default task-queue for a example.nexus.v1.Orders worker
const OrdersTaskQueue = "orders-v1"

// example.nexus.v1.Orders workflow names
const (
	CreateOrderWorkflowName = "example.nexus.v1.Orders.CreateOrder"
)

// =============================================================================
// Client (example.nexus.v1.Orders)
// =============================================================================

// OrdersClient describes a client for a(n) example.nexus.v1.Orders worker
type OrdersClient interface {
	// CreateOrder executes a(n) example.nexus.v1.Orders.CreateOrder workflow and blocks until error or response received
	CreateOrder(ctx context.Context, req *CreateOrderInput, opts ...*CreateOrderOptions) (*CreateOrderOutput, error)

	// CreateOrderAsync starts a(n) example.nexus.v1.Orders.CreateOrder workflow and returns a handle to the workflow run
	CreateOrderAsync(ctx context.Context, req *CreateOrderInput, opts ...*CreateOrderOptions) (CreateOrderRun, error)

	// GetCreateOrder retrieves a handle to an existing example.nexus.v1.Orders.CreateOrder workflow execution
	GetCreateOrder(ctx context.Context, workflowID string, runID string) CreateOrderRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// ordersClient implements a temporal client for a example.nexus.v1.Orders service
type ordersClient struct {
	client client.Client
	log    *slog.Logger
}

// NewOrdersClient initializes a new example.nexus.v1.Orders client
func NewOrdersClient(c client.Client, options ...*ordersClientOptions) OrdersClient {
	var cfg *ordersClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewOrdersClientOptions()
	}
	return &ordersClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewOrdersClientWithOptions initializes a new Orders client with the given options
func NewOrdersClientWithOptions(c client.Client, opts client.Options, options ...*ordersClientOptions) (OrdersClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *ordersClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewOrdersClientOptions()
	}
	return &ordersClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// ordersClientOptions describes optional runtime configuration for a OrdersClient
type ordersClientOptions struct {
	log *slog.Logger
}

// NewOrdersClientOptions initializes a new ordersClientOptions value
func NewOrdersClientOptions() *ordersClientOptions {
	return &ordersClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *ordersClientOptions) WithLogger(l *slog.Logger) *ordersClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *ordersClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.nexus.v1.Orders.CreateOrder executes a example.nexus.v1.Orders.CreateOrder workflow and blocks until error or response received
func (c *ordersClient) CreateOrder(ctx context.Context, req *CreateOrderInput, options ...*CreateOrderOptions) (*CreateOrderOutput, error) {
	run, err := c.CreateOrderAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateOrderAsync starts a(n) example.nexus.v1.Orders.CreateOrder workflow and returns a handle to the workflow run
func (c *ordersClient) CreateOrderAsync(ctx context.Context, req *CreateOrderInput, options ...*CreateOrderOptions) (CreateOrderRun, error) {
	var o *CreateOrderOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateOrderOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, CreateOrderWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &createOrderRun{
		client: c,
		run:    run,
	}, nil
}

// GetCreateOrder fetches an existing example.nexus.v1.Orders.CreateOrder execution
func (c *ordersClient) GetCreateOrder(ctx context.Context, workflowID string, runID string) CreateOrderRun {
	return &createOrderRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *ordersClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *ordersClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// CreateOrderOptions provides configuration for a example.nexus.v1.Orders.CreateOrder workflow operation
type CreateOrderOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewCreateOrderOptions initializes a new CreateOrderOptions value
func NewCreateOrderOptions() *CreateOrderOptions {
	return &CreateOrderOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *CreateOrderOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = OrdersTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 30000000000 // 30 seconds
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *CreateOrderOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *CreateOrderOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CreateOrderOptions) WithExecutionTimeout(d time.Duration) *CreateOrderOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *CreateOrderOptions) WithID(id string) *CreateOrderOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CreateOrderOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CreateOrderOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CreateOrderOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CreateOrderOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CreateOrderOptions) WithRunTimeout(d time.Duration) *CreateOrderOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CreateOrderOptions) WithSearchAttributes(sa map[string]any) *CreateOrderOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CreateOrderOptions) WithTaskTimeout(d time.Duration) *CreateOrderOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CreateOrderOptions) WithTaskQueue(tq string) *CreateOrderOptions {
	o.taskQueue = &tq
	return o
}

// CreateOrderRun describes a(n) example.nexus.v1.Orders.CreateOrder workflow run
type CreateOrderRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*CreateOrderOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// createOrderRun provides an internal implementation of a(n) CreateOrderRunRun
type createOrderRun struct {
	client *ordersClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *createOrderRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *createOrderRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *createOrderRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *createOrderRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *createOrderRun) Get(ctx context.Context) (*CreateOrderOutput, error) {
	var resp CreateOrderOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *createOrderRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// CreateOrderFunction implements a "example.nexus.v1.Orders.CreateOrder" workflow
	CreateOrderFunction func(workflow.Context, *CreateOrderInput) (*CreateOrderOutput, error)
)

// OrdersWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// OrdersWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	OrdersWorkflowFunctions interface {
		// CreateOrder executes a "example.nexus.v1.Orders.CreateOrder" workflow inline
		CreateOrder(workflow.Context, *CreateOrderInput) (*CreateOrderOutput, error)
	}
	// ordersWorkflowFunctions provides an internal OrdersWorkflowFunctions implementation
	ordersWorkflowFunctions struct{}
)

func NewOrdersWorkflowFunctions() OrdersWorkflowFunctions {
	return &ordersWorkflowFunctions{}
}

// CreateOrder executes a "example.nexus.v1.Orders.CreateOrder" workflow inline
func (f *ordersWorkflowFunctions) CreateOrder(ctx workflow.Context, req *CreateOrderInput) (*CreateOrderOutput, error) {
	if CreateOrderFunction == nil {
		return nil, errors.New("CreateOrder requires workflow registration via RegisterOrdersWorkflows or RegisterCreateOrderWorkflow")
	}
	return CreateOrderFunction(ctx, req)
}

// OrdersWorkflows provides methods for initializing new example.nexus.v1.Orders workflow values
type OrdersWorkflows interface {
	// CreateOrder initializes a new a(n) CreateOrderWorkflow implementation
	CreateOrder(ctx workflow.Context, input *CreateOrderWorkflowInput) (CreateOrderWorkflow, error)
}

// RegisterOrdersWorkflows registers example.nexus.v1.Orders workflows with the given worker
func RegisterOrdersWorkflows(r worker.WorkflowRegistry, workflows OrdersWorkflows) {
	RegisterCreateOrderWorkflow(r, workflows.CreateOrder)
}

// RegisterCreateOrderWorkflow registers a example.nexus.v1.Orders.CreateOrder workflow with the given worker
func RegisterCreateOrderWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *CreateOrderWorkflowInput) (CreateOrderWorkflow, error)) {
	CreateOrderFunction = buildCreateOrder(wf)
	r.RegisterWorkflowWithOptions(CreateOrderFunction, workflow.RegisterOptions{Name: CreateOrderWorkflowName})
}

// buildCreateOrder converts a CreateOrder workflow struct into a valid workflow function
func buildCreateOrder(ctor func(workflow.Context, *CreateOrderWorkflowInput) (CreateOrderWorkflow, error)) func(workflow.Context, *CreateOrderInput) (*CreateOrderOutput, error) {
	return func(ctx workflow.Context, req *CreateOrderInput) (*CreateOrderOutput, error) {
		input := &CreateOrderWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// CreateOrderWorkflowInput describes the input to a(n) example.nexus.v1.Orders.CreateOrder workflow constructor
type CreateOrderWorkflowInput struct {
	Req *CreateOrderInput
}

// CreateOrderWorkflow describes a(n) example.nexus.v1.Orders.CreateOrder workflow implementation
type CreateOrderWorkflow interface {
	// Execute defines the entrypoint to a(n) example.nexus.v1.Orders.CreateOrder workflow
	Execute(ctx workflow.Context) (*CreateOrderOutput, error)
}

// CreateOrderChild executes a child example.nexus.v1.Orders.CreateOrder workflow and blocks until error or response received
func CreateOrderChild(ctx workflow.Context, req *CreateOrderInput, options ...*CreateOrderChildOptions) (*CreateOrderOutput, error) {
	childRun, err := CreateOrderChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// CreateOrderChildAsync starts a child example.nexus.v1.Orders.CreateOrder workflow and returns a handle to the child workflow run
func CreateOrderChildAsync(ctx workflow.Context, req *CreateOrderInput, options ...*CreateOrderChildOptions) (*CreateOrderChildRun, error) {
	var o *CreateOrderChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateOrderChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &CreateOrderChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CreateOrderWorkflowName, req)}, nil
}

// CreateOrderChildOptions provides configuration for a child example.nexus.v1.Orders.CreateOrder workflow operation
type CreateOrderChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewCreateOrderChildOptions initializes a new CreateOrderChildOptions value
func NewCreateOrderChildOptions() *CreateOrderChildOptions {
	return &CreateOrderChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *CreateOrderChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = OrdersTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 30000000000 // 30 seconds
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *CreateOrderChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *CreateOrderChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CreateOrderChildOptions) WithExecutionTimeout(d time.Duration) *CreateOrderChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *CreateOrderChildOptions) WithID(id string) *CreateOrderChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CreateOrderChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CreateOrderChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *CreateOrderChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *CreateOrderChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CreateOrderChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CreateOrderChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CreateOrderChildOptions) WithRunTimeout(d time.Duration) *CreateOrderChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CreateOrderChildOptions) WithSearchAttributes(sa map[string]any) *CreateOrderChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CreateOrderChildOptions) WithTaskTimeout(d time.Duration) *CreateOrderChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CreateOrderChildOptions) WithTaskQueue(tq string) *CreateOrderChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CreateOrderChildOptions) WithWaitForCancellation(wait bool) *CreateOrderChildOptions {
	o.waitForCancellation = &wait
	return o
}

// CreateOrderChildRun describes a child CreateOrder workflow run
type CreateOrderChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CreateOrderChildRun) Get(ctx workflow.Context) (*CreateOrderOutput, error) {
	var resp CreateOrderOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CreateOrderChildRun) Select(sel workflow.Selector, fn func(*CreateOrderChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CreateOrderChildRun) SelectStart(sel workflow.Selector, fn func(*CreateOrderChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CreateOrderChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// OrdersActivities describes available worker activities
type OrdersActivities interface{}

// RegisterOrdersActivities registers activities with a worker
func RegisterOrdersActivities(r worker.ActivityRegistry, activities OrdersActivities) {}

// =============================================================================
// Test Client (example.nexus.v1.Orders)
// =============================================================================

// TestClient provides a testsuite-compatible Client
type TestOrdersClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows OrdersWorkflows
}

var _ OrdersClient = &TestOrdersClient{}

// NewTestOrdersClient initializes a new TestOrdersClient value
func NewTestOrdersClient(env *testsuite.TestWorkflowEnvironment, workflows OrdersWorkflows, activities OrdersActivities) *TestOrdersClient {
	if workflows != nil {
		RegisterOrdersWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterOrdersActivities(env, activities)
	}
	return &TestOrdersClient{env, workflows}
}

// CreateOrder executes a(n) example.nexus.v1.Orders.CreateOrder workflow in the test environment
func (c *TestOrdersClient) CreateOrder(ctx context.Context, req *CreateOrderInput, opts ...*CreateOrderOptions) (*CreateOrderOutput, error) {
	run, err := c.CreateOrderAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CreateOrderAsync executes a(n) example.nexus.v1.Orders.CreateOrder workflow in the test environment
func (c *TestOrdersClient) CreateOrderAsync(ctx context.Context, req *CreateOrderInput, options ...*CreateOrderOptions) (CreateOrderRun, error) {
	var o *CreateOrderOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCreateOrderOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testCreateOrderRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCreateOrder is a noop
func (c *TestOrdersClient) GetCreateOrder(ctx context.Context, workflowID string, runID string) CreateOrderRun {
	return &testCreateOrderRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestOrdersClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestOrdersClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ CreateOrderRun = &testCreateOrderRun{}

// testCreateOrderRun provides convenience methods for interacting with a(n) example.nexus.v1.Orders.CreateOrder workflow in the test environment
type testCreateOrderRun struct {
	client    *TestOrdersClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *CreateOrderInput
	workflows OrdersWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testCreateOrderRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.nexus.v1.Orders.CreateOrder workflow result
func (r *testCreateOrderRun) Get(context.Context) (*CreateOrderOutput, error) {
	r.env.ExecuteWorkflow(CreateOrderWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result CreateOrderOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.nexus.v1.Orders.CreateOrder workflow run's workflow ID
func (r *testCreateOrderRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testCreateOrderRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testCreateOrderRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testCreateOrderRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// =============================================================================
// CLI (example.nexus.v1.Orders)
// =============================================================================

// OrdersCliOptions describes runtime configuration for example.nexus.v1.Orders cli
type OrdersCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewOrdersCliOptions initializes a new OrdersCliOptions value
func NewOrdersCliOptions() *OrdersCliOptions {
	return &OrdersCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *OrdersCliOptions) WithAfter(fn func(*v2.Context) error) *OrdersCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *OrdersCliOptions) WithBefore(fn func(*v2.Context) error) *OrdersCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *OrdersCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *OrdersCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *OrdersCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *OrdersCliOptions {
	opts.worker = fn
	return opts
}

// NewOrdersCli initializes a cli for a(n) example.nexus.v1.Orders service
func NewOrdersCli(options ...*OrdersCliOptions) (*v2.App, error) {
	commands, err := newOrdersCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "orders",
		Commands: commands,
	}, nil
}

// NewOrdersCliCommand initializes a cli command for a example.nexus.v1.Orders service with subcommands for each query, signal, update, and workflow
func NewOrdersCliCommand(options ...*OrdersCliOptions) (*v2.Command, error) {
	subcommands, err := newOrdersCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "orders",
		Subcommands: subcommands,
	}, nil
}

// newOrdersCommands initializes (sub)commands for a example.nexus.v1.Orders cli or command
func newOrdersCommands(options ...*OrdersCliOptions) ([]*v2.Command, error) {
	opts := &OrdersCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "create-order",
			Usage:                  "executes a(n) example.nexus.v1.Orders.CreateOrder workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "orders-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "customer-id",
					Usage:    "set the value of the operation's \"CustomerId\" parameter",
					Category: "INPUT",
				},
				&v2.StringSliceFlag{
					Name:     "items",
					Usage:    "set the value of the operation's \"Items\" parameter (json-encoded: {sku: <string>, quantity: <uint32>})",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewOrdersClient(tc)
				req, err := UnmarshalCliFlagsToCreateOrderInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.CreateOrderAsync(cmd.Context, req, NewCreateOrderOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CreateOrderWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.nexus.v1.Orders worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToCreateOrderInput unmarshals a CreateOrderInput from command line flags
func UnmarshalCliFlagsToCreateOrderInput(cmd *v2.Context) (*CreateOrderInput, error) {
	var result CreateOrderInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("customer-id") {
		hasValues = true
		result.CustomerId = cmd.String("customer-id")
	}
	if cmd.IsSet("items") {
		hasValues = true
		var tmp CreateOrderInput
		if err := protojson.Unmarshal([]byte(fmt.Sprintf("{\"items\":%s}", cmd.String("items"))), &tmp); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"items\" map flag: %w", err)
		}
		result.Items = tmp.Items
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// =============================================================================
// Codec (example.nexus.v1.Orders)
// =============================================================================

// WithOrdersSchemeTypes registers all Orders protobuf types with the given scheme
func WithOrdersSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_nexus_v1_nexus_proto.Messages().ByName("CreateOrderInput"))
		s.RegisterType(File_example_nexus_v1_nexus_proto.Messages().ByName("CreateOrderOutput"))
	}
}

// =============================================================================
// Nexus (example.nexus.v1.Orders)
// =============================================================================

// OrdersServiceName defines the fully-qualified Orders nexus service name
const OrdersServiceName = "example.nexus.v1.Orders"

// RegisterOrdersOperations registers all example.nexus.v1.Orders nexus operations with the given service
func RegisterOrdersOperations(svc *nexus.Service) error {
	return svc.Register(
		CreateOrderWorkflowOperation,
	)
}

// RegisterOrdersService registers a example.nexus.v1.Orders nexus service with a given worker
func RegisterOrdersService(r worker.NexusServiceRegistry) error {
	svc := nexus.NewService(OrdersServiceName)
	if err := RegisterOrdersOperations(svc); err != nil {
		return err
	}
	r.RegisterNexusService(svc)
	return nil
}

// CreateOrderWorkflowOperationName defines the fully-qualified name for a example.nexus.v1.Orders.CreateOrder nexus workflow operation
const CreateOrderWorkflowOperationName = "CreateOrder"

// CreateOrderWorkflowOperation defines a(n) example.nexus.v1.Orders.CreateOrder nexus workflow operation
var CreateOrderWorkflowOperation = temporalnexus.MustNewWorkflowRunOperationWithOptions(
	temporalnexus.WorkflowRunOperationOptions[*CreateOrderInput, *CreateOrderOutput]{
		Name: CreateOrderWorkflowOperationName,
		Handler: func(ctx context.Context, input *CreateOrderInput, opts nexus.StartOperationOptions) (temporalnexus.WorkflowHandle[*CreateOrderOutput], error) {
			o, err := NewCreateOrderOptions().Build(input.ProtoReflect())
			if err != nil {
				return nil, err
			}
			return temporalnexus.ExecuteUntypedWorkflow[*CreateOrderOutput](ctx, opts, o, CreateOrderWorkflowName, input)
		},
	},
)

// CreateOrderWorkflowOperationFuture describes a handle to an asynchronous example.nexus.v1.Orders.CreateOrder nexus workflow operation
type CreateOrderWorkflowOperationFuture interface {
	// Future returns the underlying NexusOperationFuture
	Future() workflow.NexusOperationFuture
	// Get blocks until the nexus operation is complete, returning the result or error
	Get(ctx workflow.Context) (*CreateOrderOutput, error)
}

// createOrderWorkflowOperationFuture provides an internal CreateOrderWorkflowOperationFuture implementation
type createOrderWorkflowOperationFuture struct {
	f workflow.NexusOperationFuture
}

// Future returns the underlying NexusOperationFuture
func (f *createOrderWorkflowOperationFuture) Future() workflow.NexusOperationFuture {
	return f.f
}

// Get blocks until the nexus operation is complete, returning the result or error
func (f *createOrderWorkflowOperationFuture) Get(ctx workflow.Context) (*CreateOrderOutput, error) {
	var out CreateOrderOutput
	return &out, f.f.Get(ctx, &out)
}

// CreateOrderWorkflowOperationOptions provides methods for configuration a(n) example.nexus.v1.Orders.CreateOrder nexus workflow operation
type CreateOrderWorkflowOperationOptions struct {
	opts                   *workflow.NexusOperationOptions
	scheduleToCloseTimeout *durationpb.Duration
}

// NewCreateOrderWorkflowOperationOptions initializes a new CreateOrderWorkflowOperationOptions value
func NewCreateOrderWorkflowOperationOptions() *CreateOrderWorkflowOperationOptions {
	return &CreateOrderWorkflowOperationOptions{}
}

// Build converts a(n) CreateOrderWorkflowOperationOptions value into a workflow.NexusOperationOptions value
func (o *CreateOrderWorkflowOperationOptions) Build(ctx workflow.Context) (workflow.NexusOperationOptions, error) {
	var opts workflow.NexusOperationOptions
	if o == nil {
		return opts, nil
	}

	if v := o.opts; v != nil {
		opts = *o.opts
	}

	if v := o.scheduleToCloseTimeout; v.IsValid() {
		opts.ScheduleToCloseTimeout = v.AsDuration()
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 30000000000 // 30 seconds
	}

	return opts, nil
}

// WithOptions overrides the initial NexusOperationOptions to which defaults and overrides are then applied
func (o *CreateOrderWorkflowOperationOptions) WithOptions(opts workflow.NexusOperationOptions) *CreateOrderWorkflowOperationOptions {
	o.opts = &opts
	return o
}

// WithScheduleToCloseTimeout overrides the default ScheduleToCloseTimeout
func (o *CreateOrderWorkflowOperationOptions) WithScheduleToCloseTimeout(d time.Duration) *CreateOrderWorkflowOperationOptions {
	o.scheduleToCloseTimeout = durationpb.New(d)
	return o
}

// OrdersNexusClient describes a(n) example.nexus.v1.Orders nexus client
type OrdersNexusClient interface {
	// CreateOrder executes a(n) example.nexus.v1.Orders.CreateOrder nexus workflow operation and blocks until complete
	CreateOrder(ctx workflow.Context, input *CreateOrderInput, options ...*CreateOrderWorkflowOperationOptions) (*CreateOrderOutput, error)
	// CreateOrderAsync starts a(n) example.nexus.v1.Orders.CreateOrder nexus workflow operation and returns a handle to the operation
	CreateOrderAsync(ctx workflow.Context, input *CreateOrderInput, options ...*CreateOrderWorkflowOperationOptions) CreateOrderWorkflowOperationFuture
}

// ordersNexusClient provides an internal OrdersNexusClient implementation
type ordersNexusClient struct {
	client workflow.NexusClient
}

// NewOrdersNexusClient initializes a new example.nexus.v1.Orders nexus client
func NewOrdersNexusClient(endpoint string) OrdersNexusClient {
	return &ordersNexusClient{
		client: workflow.NewNexusClient(endpoint, OrdersServiceName),
	}
}

// CreateOrder executes a(n) example.nexus.v1.Orders.CreateOrder nexus workflow operation and blocks until complete
func (c *ordersNexusClient) CreateOrder(ctx workflow.Context, input *CreateOrderInput, options ...*CreateOrderWorkflowOperationOptions) (*CreateOrderOutput, error) {
	return c.CreateOrderAsync(ctx, input, options...).Get(ctx)
}

// %!s(MISSING) starts a(n) %!s(MISSING) nexus workflow operation, returning a handle to the operation
func (c *ordersNexusClient) CreateOrderAsync(ctx workflow.Context, input *CreateOrderInput, options ...*CreateOrderWorkflowOperationOptions) CreateOrderWorkflowOperationFuture {
	var o *CreateOrderWorkflowOperationOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	}

	opts, err := o.Build(ctx)
	if err != nil {
		return &createOrderWorkflowOperationFuture{
			f: errs.NewNexusOperationFutureError(err),
		}
	}

	return &createOrderWorkflowOperationFuture{
		f: c.client.ExecuteOperation(ctx, CreateOrderWorkflowOperationName, input, opts),
	}
}

// =============================================================================
// Constants (example.nexus.v1.Billing)
// =============================================================================

// BillingTaskQueue is the default task-queue for a example.nexus.v1.Billing worker
const BillingTaskQueue = "billing-v1"

// example.nexus.v1.Billing workflow names
const (
	ChargeWorkflowName = "example.nexus.v1.Billing.Charge"
)

// =============================================================================
// Client (example.nexus.v1.Billing)
// =============================================================================

// BillingClient describes a client for a(n) example.nexus.v1.Billing worker
type BillingClient interface {
	// Charge executes a(n) example.nexus.v1.Billing.Charge workflow and blocks until error or response received
	Charge(ctx context.Context, req *ChargeInput, opts ...*ChargeOptions) (*ChargeOutput, error)

	// ChargeAsync starts a(n) example.nexus.v1.Billing.Charge workflow and returns a handle to the workflow run
	ChargeAsync(ctx context.Context, req *ChargeInput, opts ...*ChargeOptions) (ChargeRun, error)

	// GetCharge retrieves a handle to an existing example.nexus.v1.Billing.Charge workflow execution
	GetCharge(ctx context.Context, workflowID string, runID string) ChargeRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// billingClient implements a temporal client for a example.nexus.v1.Billing service
type billingClient struct {
	client client.Client
	log    *slog.Logger
}

// NewBillingClient initializes a new example.nexus.v1.Billing client
func NewBillingClient(c client.Client, options ...*billingClientOptions) BillingClient {
	var cfg *billingClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewBillingClientOptions()
	}
	return &billingClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewBillingClientWithOptions initializes a new Billing client with the given options
func NewBillingClientWithOptions(c client.Client, opts client.Options, options ...*billingClientOptions) (BillingClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *billingClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewBillingClientOptions()
	}
	return &billingClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// billingClientOptions describes optional runtime configuration for a BillingClient
type billingClientOptions struct {
	log *slog.Logger
}

// NewBillingClientOptions initializes a new billingClientOptions value
func NewBillingClientOptions() *billingClientOptions {
	return &billingClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *billingClientOptions) WithLogger(l *slog.Logger) *billingClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *billingClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.nexus.v1.Billing.Charge executes a example.nexus.v1.Billing.Charge workflow and blocks until error or response received
func (c *billingClient) Charge(ctx context.Context, req *ChargeInput, options ...*ChargeOptions) (*ChargeOutput, error) {
	run, err := c.ChargeAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ChargeAsync starts a(n) example.nexus.v1.Billing.Charge workflow and returns a handle to the workflow run
func (c *billingClient) ChargeAsync(ctx context.Context, req *ChargeInput, options ...*ChargeOptions) (ChargeRun, error) {
	var o *ChargeOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewChargeOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ChargeWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &chargeRun{
		client: c,
		run:    run,
	}, nil
}

// GetCharge fetches an existing example.nexus.v1.Billing.Charge execution
func (c *billingClient) GetCharge(ctx context.Context, workflowID string, runID string) ChargeRun {
	return &chargeRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *billingClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *billingClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// ChargeOptions provides configuration for a example.nexus.v1.Billing.Charge workflow operation
type ChargeOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewChargeOptions initializes a new ChargeOptions value
func NewChargeOptions() *ChargeOptions {
	return &ChargeOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ChargeOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = BillingTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ChargeOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ChargeOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ChargeOptions) WithExecutionTimeout(d time.Duration) *ChargeOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ChargeOptions) WithID(id string) *ChargeOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ChargeOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ChargeOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ChargeOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ChargeOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ChargeOptions) WithRunTimeout(d time.Duration) *ChargeOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ChargeOptions) WithSearchAttributes(sa map[string]any) *ChargeOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ChargeOptions) WithTaskTimeout(d time.Duration) *ChargeOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ChargeOptions) WithTaskQueue(tq string) *ChargeOptions {
	o.taskQueue = &tq
	return o
}

// ChargeRun describes a(n) example.nexus.v1.Billing.Charge workflow run
type ChargeRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*ChargeOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// chargeRun provides an internal implementation of a(n) ChargeRunRun
type chargeRun struct {
	client *billingClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *chargeRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *chargeRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *chargeRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *chargeRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *chargeRun) Get(ctx context.Context) (*ChargeOutput, error) {
	var resp ChargeOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *chargeRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// ChargeFunction implements a "example.nexus.v1.Billing.Charge" workflow
	ChargeFunction func(workflow.Context, *ChargeInput) (*ChargeOutput, error)
)

// BillingWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// BillingWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	BillingWorkflowFunctions interface {
		// Charge executes a "example.nexus.v1.Billing.Charge" workflow inline
		Charge(workflow.Context, *ChargeInput) (*ChargeOutput, error)
	}
	// billingWorkflowFunctions provides an internal BillingWorkflowFunctions implementation
	billingWorkflowFunctions struct{}
)

func NewBillingWorkflowFunctions() BillingWorkflowFunctions {
	return &billingWorkflowFunctions{}
}

// Charge executes a "example.nexus.v1.Billing.Charge" workflow inline
func (f *billingWorkflowFunctions) Charge(ctx workflow.Context, req *ChargeInput) (*ChargeOutput, error) {
	if ChargeFunction == nil {
		return nil, errors.New("Charge requires workflow registration via RegisterBillingWorkflows or RegisterChargeWorkflow")
	}
	return ChargeFunction(ctx, req)
}

// BillingWorkflows provides methods for initializing new example.nexus.v1.Billing workflow values
type BillingWorkflows interface {
	// Charge initializes a new a(n) ChargeWorkflow implementation
	Charge(ctx workflow.Context, input *ChargeWorkflowInput) (ChargeWorkflow, error)
}

// RegisterBillingWorkflows registers example.nexus.v1.Billing workflows with the given worker
func RegisterBillingWorkflows(r worker.WorkflowRegistry, workflows BillingWorkflows) {
	RegisterChargeWorkflow(r, workflows.Charge)
}

// RegisterChargeWorkflow registers a example.nexus.v1.Billing.Charge workflow with the given worker
func RegisterChargeWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ChargeWorkflowInput) (ChargeWorkflow, error)) {
	ChargeFunction = buildCharge(wf)
	r.RegisterWorkflowWithOptions(ChargeFunction, workflow.RegisterOptions{Name: ChargeWorkflowName})
}

// buildCharge converts a Charge workflow struct into a valid workflow function
func buildCharge(ctor func(workflow.Context, *ChargeWorkflowInput) (ChargeWorkflow, error)) func(workflow.Context, *ChargeInput) (*ChargeOutput, error) {
	return func(ctx workflow.Context, req *ChargeInput) (*ChargeOutput, error) {
		input := &ChargeWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// ChargeWorkflowInput describes the input to a(n) example.nexus.v1.Billing.Charge workflow constructor
type ChargeWorkflowInput struct {
	Req *ChargeInput
}

// ChargeWorkflow describes a(n) example.nexus.v1.Billing.Charge workflow implementation
type ChargeWorkflow interface {
	// Execute defines the entrypoint to a(n) example.nexus.v1.Billing.Charge workflow
	Execute(ctx workflow.Context) (*ChargeOutput, error)
}

// ChargeChild executes a child example.nexus.v1.Billing.Charge workflow and blocks until error or response received
func ChargeChild(ctx workflow.Context, req *ChargeInput, options ...*ChargeChildOptions) (*ChargeOutput, error) {
	childRun, err := ChargeChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// ChargeChildAsync starts a child example.nexus.v1.Billing.Charge workflow and returns a handle to the child workflow run
func ChargeChildAsync(ctx workflow.Context, req *ChargeInput, options ...*ChargeChildOptions) (*ChargeChildRun, error) {
	var o *ChargeChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewChargeChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &ChargeChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ChargeWorkflowName, req)}, nil
}

// ChargeChildOptions provides configuration for a child example.nexus.v1.Billing.Charge workflow operation
type ChargeChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewChargeChildOptions initializes a new ChargeChildOptions value
func NewChargeChildOptions() *ChargeChildOptions {
	return &ChargeChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ChargeChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = BillingTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ChargeChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ChargeChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ChargeChildOptions) WithExecutionTimeout(d time.Duration) *ChargeChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ChargeChildOptions) WithID(id string) *ChargeChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ChargeChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ChargeChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ChargeChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ChargeChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ChargeChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ChargeChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ChargeChildOptions) WithRunTimeout(d time.Duration) *ChargeChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ChargeChildOptions) WithSearchAttributes(sa map[string]any) *ChargeChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ChargeChildOptions) WithTaskTimeout(d time.Duration) *ChargeChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ChargeChildOptions) WithTaskQueue(tq string) *ChargeChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ChargeChildOptions) WithWaitForCancellation(wait bool) *ChargeChildOptions {
	o.waitForCancellation = &wait
	return o
}

// ChargeChildRun describes a child Charge workflow run
type ChargeChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ChargeChildRun) Get(ctx workflow.Context) (*ChargeOutput, error) {
	var resp ChargeOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ChargeChildRun) Select(sel workflow.Selector, fn func(*ChargeChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ChargeChildRun) SelectStart(sel workflow.Selector, fn func(*ChargeChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ChargeChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// BillingActivities describes available worker activities
type BillingActivities interface{}

// RegisterBillingActivities registers activities with a worker
func RegisterBillingActivities(r worker.ActivityRegistry, activities BillingActivities) {}

// =============================================================================
// Test Client (example.nexus.v1.Billing)
// =============================================================================

// TestClient provides a testsuite-compatible Client
type TestBillingClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows BillingWorkflows
}

var _ BillingClient = &TestBillingClient{}

// NewTestBillingClient initializes a new TestBillingClient value
func NewTestBillingClient(env *testsuite.TestWorkflowEnvironment, workflows BillingWorkflows, activities BillingActivities) *TestBillingClient {
	if workflows != nil {
		RegisterBillingWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterBillingActivities(env, activities)
	}
	return &TestBillingClient{env, workflows}
}

// Charge executes a(n) example.nexus.v1.Billing.Charge workflow in the test environment
func (c *TestBillingClient) Charge(ctx context.Context, req *ChargeInput, opts ...*ChargeOptions) (*ChargeOutput, error) {
	run, err := c.ChargeAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// ChargeAsync executes a(n) example.nexus.v1.Billing.Charge workflow in the test environment
func (c *TestBillingClient) ChargeAsync(ctx context.Context, req *ChargeInput, options ...*ChargeOptions) (ChargeRun, error) {
	var o *ChargeOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewChargeOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testChargeRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCharge is a noop
func (c *TestBillingClient) GetCharge(ctx context.Context, workflowID string, runID string) ChargeRun {
	return &testChargeRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestBillingClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestBillingClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ ChargeRun = &testChargeRun{}

// testChargeRun provides convenience methods for interacting with a(n) example.nexus.v1.Billing.Charge workflow in the test environment
type testChargeRun struct {
	client    *TestBillingClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *ChargeInput
	workflows BillingWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testChargeRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.nexus.v1.Billing.Charge workflow result
func (r *testChargeRun) Get(context.Context) (*ChargeOutput, error) {
	r.env.ExecuteWorkflow(ChargeWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result ChargeOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.nexus.v1.Billing.Charge workflow run's workflow ID
func (r *testChargeRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testChargeRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testChargeRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testChargeRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// =============================================================================
// CLI (example.nexus.v1.Billing)
// =============================================================================

// BillingCliOptions describes runtime configuration for example.nexus.v1.Billing cli
type BillingCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewBillingCliOptions initializes a new BillingCliOptions value
func NewBillingCliOptions() *BillingCliOptions {
	return &BillingCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *BillingCliOptions) WithAfter(fn func(*v2.Context) error) *BillingCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *BillingCliOptions) WithBefore(fn func(*v2.Context) error) *BillingCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *BillingCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *BillingCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *BillingCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *BillingCliOptions {
	opts.worker = fn
	return opts
}

// NewBillingCli initializes a cli for a(n) example.nexus.v1.Billing service
func NewBillingCli(options ...*BillingCliOptions) (*v2.App, error) {
	commands, err := newBillingCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "billing",
		Commands: commands,
	}, nil
}

// NewBillingCliCommand initializes a cli command for a example.nexus.v1.Billing service with subcommands for each query, signal, update, and workflow
func NewBillingCliCommand(options ...*BillingCliOptions) (*v2.Command, error) {
	subcommands, err := newBillingCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "billing",
		Subcommands: subcommands,
	}, nil
}

// newBillingCommands initializes (sub)commands for a example.nexus.v1.Billing cli or command
func newBillingCommands(options ...*BillingCliOptions) ([]*v2.Command, error) {
	opts := &BillingCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "charge",
			Usage:                  "executes a(n) example.nexus.v1.Billing.Charge workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "billing-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "order",
					Usage:    "set the value of the operation's \"Order\" parameter (json-encoded: {id: <string>, customerId: <string>, items: <example.nexus.v1.Item>, receivedAt: <google.protobuf.Timestamp>, status: <example.nexus.v1.OrderStatus>})",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewBillingClient(tc)
				req, err := UnmarshalCliFlagsToChargeInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ChargeAsync(cmd.Context, req, NewChargeOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ChargeWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.nexus.v1.Billing worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToChargeInput unmarshals a ChargeInput from command line flags
func UnmarshalCliFlagsToChargeInput(cmd *v2.Context) (*ChargeInput, error) {
	var result ChargeInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("order") {
		hasValues = true
		var v Order
		if err := protojson.Unmarshal([]byte(cmd.String("order")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"order\" flag: %w", err)
		}
		result.Order = &v
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// =============================================================================
// Codec (example.nexus.v1.Billing)
// =============================================================================

// WithBillingSchemeTypes registers all Billing protobuf types with the given scheme
func WithBillingSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_nexus_v1_nexus_proto.Messages().ByName("ChargeInput"))
		s.RegisterType(File_example_nexus_v1_nexus_proto.Messages().ByName("ChargeOutput"))
	}
}

// =============================================================================
// Nexus (example.nexus.v1.Billing)
// =============================================================================

// BillingServiceName defines the fully-qualified Billing nexus service name
const BillingServiceName = "example.nexus.v1.Billing"

// RegisterBillingOperations registers all example.nexus.v1.Billing nexus operations with the given service
func RegisterBillingOperations(svc *nexus.Service) error {
	return svc.Register(
		ChargeWorkflowOperation,
	)
}

// RegisterBillingService registers a example.nexus.v1.Billing nexus service with a given worker
func RegisterBillingService(r worker.NexusServiceRegistry) error {
	svc := nexus.NewService(BillingServiceName)
	if err := RegisterBillingOperations(svc); err != nil {
		return err
	}
	r.RegisterNexusService(svc)
	return nil
}

// ChargeWorkflowOperationName defines the fully-qualified name for a example.nexus.v1.Billing.Charge nexus workflow operation
const ChargeWorkflowOperationName = "Charge"

// ChargeWorkflowOperation defines a(n) example.nexus.v1.Billing.Charge nexus workflow operation
var ChargeWorkflowOperation = temporalnexus.MustNewWorkflowRunOperationWithOptions(
	temporalnexus.WorkflowRunOperationOptions[*ChargeInput, *ChargeOutput]{
		Name: ChargeWorkflowOperationName,
		Handler: func(ctx context.Context, input *ChargeInput, opts nexus.StartOperationOptions) (temporalnexus.WorkflowHandle[*ChargeOutput], error) {
			o, err := NewChargeOptions().Build(input.ProtoReflect())
			if err != nil {
				return nil, err
			}
			return temporalnexus.ExecuteUntypedWorkflow[*ChargeOutput](ctx, opts, o, ChargeWorkflowName, input)
		},
	},
)

// ChargeWorkflowOperationFuture describes a handle to an asynchronous example.nexus.v1.Billing.Charge nexus workflow operation
type ChargeWorkflowOperationFuture interface {
	// Future returns the underlying NexusOperationFuture
	Future() workflow.NexusOperationFuture
	// Get blocks until the nexus operation is complete, returning the result or error
	Get(ctx workflow.Context) (*ChargeOutput, error)
}

// chargeWorkflowOperationFuture provides an internal ChargeWorkflowOperationFuture implementation
type chargeWorkflowOperationFuture struct {
	f workflow.NexusOperationFuture
}

// Future returns the underlying NexusOperationFuture
func (f *chargeWorkflowOperationFuture) Future() workflow.NexusOperationFuture {
	return f.f
}

// Get blocks until the nexus operation is complete, returning the result or error
func (f *chargeWorkflowOperationFuture) Get(ctx workflow.Context) (*ChargeOutput, error) {
	var out ChargeOutput
	return &out, f.f.Get(ctx, &out)
}

// ChargeWorkflowOperationOptions provides methods for configuration a(n) example.nexus.v1.Billing.Charge nexus workflow operation
type ChargeWorkflowOperationOptions struct {
	opts                   *workflow.NexusOperationOptions
	scheduleToCloseTimeout *durationpb.Duration
}

// NewChargeWorkflowOperationOptions initializes a new ChargeWorkflowOperationOptions value
func NewChargeWorkflowOperationOptions() *ChargeWorkflowOperationOptions {
	return &ChargeWorkflowOperationOptions{}
}

// Build converts a(n) ChargeWorkflowOperationOptions value into a workflow.NexusOperationOptions value
func (o *ChargeWorkflowOperationOptions) Build(ctx workflow.Context) (workflow.NexusOperationOptions, error) {
	var opts workflow.NexusOperationOptions
	if o == nil {
		return opts, nil
	}

	if v := o.opts; v != nil {
		opts = *o.opts
	}

	if v := o.scheduleToCloseTimeout; v.IsValid() {
		opts.ScheduleToCloseTimeout = v.AsDuration()
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 3600000000000 // 1 hour
	}

	return opts, nil
}

// WithOptions overrides the initial NexusOperationOptions to which defaults and overrides are then applied
func (o *ChargeWorkflowOperationOptions) WithOptions(opts workflow.NexusOperationOptions) *ChargeWorkflowOperationOptions {
	o.opts = &opts
	return o
}

// WithScheduleToCloseTimeout overrides the default ScheduleToCloseTimeout
func (o *ChargeWorkflowOperationOptions) WithScheduleToCloseTimeout(d time.Duration) *ChargeWorkflowOperationOptions {
	o.scheduleToCloseTimeout = durationpb.New(d)
	return o
}

// BillingNexusClient describes a(n) example.nexus.v1.Billing nexus client
type BillingNexusClient interface {
	// Charge executes a(n) example.nexus.v1.Billing.Charge nexus workflow operation and blocks until complete
	Charge(ctx workflow.Context, input *ChargeInput, options ...*ChargeWorkflowOperationOptions) (*ChargeOutput, error)
	// ChargeAsync starts a(n) example.nexus.v1.Billing.Charge nexus workflow operation and returns a handle to the operation
	ChargeAsync(ctx workflow.Context, input *ChargeInput, options ...*ChargeWorkflowOperationOptions) ChargeWorkflowOperationFuture
}

// billingNexusClient provides an internal BillingNexusClient implementation
type billingNexusClient struct {
	client workflow.NexusClient
}

// NewBillingNexusClient initializes a new example.nexus.v1.Billing nexus client
func NewBillingNexusClient(endpoint string) BillingNexusClient {
	return &billingNexusClient{
		client: workflow.NewNexusClient(endpoint, BillingServiceName),
	}
}

// Charge executes a(n) example.nexus.v1.Billing.Charge nexus workflow operation and blocks until complete
func (c *billingNexusClient) Charge(ctx workflow.Context, input *ChargeInput, options ...*ChargeWorkflowOperationOptions) (*ChargeOutput, error) {
	return c.ChargeAsync(ctx, input, options...).Get(ctx)
}

// %!s(MISSING) starts a(n) %!s(MISSING) nexus workflow operation, returning a handle to the operation
func (c *billingNexusClient) ChargeAsync(ctx workflow.Context, input *ChargeInput, options ...*ChargeWorkflowOperationOptions) ChargeWorkflowOperationFuture {
	var o *ChargeWorkflowOperationOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	}

	opts, err := o.Build(ctx)
	if err != nil {
		return &chargeWorkflowOperationFuture{
			f: errs.NewNexusOperationFutureError(err),
		}
	}

	return &chargeWorkflowOperationFuture{
		f: c.client.ExecuteOperation(ctx, ChargeWorkflowOperationName, input, opts),
	}
}

// =============================================================================
// Constants (example.nexus.v1.Shipping)
// =============================================================================

// ShippingTaskQueue is the default task-queue for a example.nexus.v1.Shipping worker
const ShippingTaskQueue = "shipping-v1"

// example.nexus.v1.Shipping workflow names
const (
	ShipmentWorkflowName = "example.nexus.v1.Shipping.Shipment"
)

// =============================================================================
// Client (example.nexus.v1.Shipping)
// =============================================================================

// ShippingClient describes a client for a(n) example.nexus.v1.Shipping worker
type ShippingClient interface {
	// Shipment executes a(n) example.nexus.v1.Shipping.Shipment workflow and blocks until error or response received
	Shipment(ctx context.Context, req *ShipmentInput, opts ...*ShipmentOptions) error

	// ShipmentAsync starts a(n) example.nexus.v1.Shipping.Shipment workflow and returns a handle to the workflow run
	ShipmentAsync(ctx context.Context, req *ShipmentInput, opts ...*ShipmentOptions) (ShipmentRun, error)

	// GetShipment retrieves a handle to an existing example.nexus.v1.Shipping.Shipment workflow execution
	GetShipment(ctx context.Context, workflowID string, runID string) ShipmentRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// shippingClient implements a temporal client for a example.nexus.v1.Shipping service
type shippingClient struct {
	client client.Client
	log    *slog.Logger
}

// NewShippingClient initializes a new example.nexus.v1.Shipping client
func NewShippingClient(c client.Client, options ...*shippingClientOptions) ShippingClient {
	var cfg *shippingClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewShippingClientOptions()
	}
	return &shippingClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewShippingClientWithOptions initializes a new Shipping client with the given options
func NewShippingClientWithOptions(c client.Client, opts client.Options, options ...*shippingClientOptions) (ShippingClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *shippingClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewShippingClientOptions()
	}
	return &shippingClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// shippingClientOptions describes optional runtime configuration for a ShippingClient
type shippingClientOptions struct {
	log *slog.Logger
}

// NewShippingClientOptions initializes a new shippingClientOptions value
func NewShippingClientOptions() *shippingClientOptions {
	return &shippingClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *shippingClientOptions) WithLogger(l *slog.Logger) *shippingClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *shippingClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.nexus.v1.Shipping.Shipment executes a example.nexus.v1.Shipping.Shipment workflow and blocks until error or response received
func (c *shippingClient) Shipment(ctx context.Context, req *ShipmentInput, options ...*ShipmentOptions) error {
	run, err := c.ShipmentAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// ShipmentAsync starts a(n) example.nexus.v1.Shipping.Shipment workflow and returns a handle to the workflow run
func (c *shippingClient) ShipmentAsync(ctx context.Context, req *ShipmentInput, options ...*ShipmentOptions) (ShipmentRun, error) {
	var o *ShipmentOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewShipmentOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, ShipmentWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &shipmentRun{
		client: c,
		run:    run,
	}, nil
}

// GetShipment fetches an existing example.nexus.v1.Shipping.Shipment execution
func (c *shippingClient) GetShipment(ctx context.Context, workflowID string, runID string) ShipmentRun {
	return &shipmentRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *shippingClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *shippingClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// ShipmentOptions provides configuration for a example.nexus.v1.Shipping.Shipment workflow operation
type ShipmentOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewShipmentOptions initializes a new ShipmentOptions value
func NewShipmentOptions() *ShipmentOptions {
	return &ShipmentOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *ShipmentOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ShippingTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *ShipmentOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *ShipmentOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ShipmentOptions) WithExecutionTimeout(d time.Duration) *ShipmentOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *ShipmentOptions) WithID(id string) *ShipmentOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ShipmentOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ShipmentOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ShipmentOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ShipmentOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ShipmentOptions) WithRunTimeout(d time.Duration) *ShipmentOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ShipmentOptions) WithSearchAttributes(sa map[string]any) *ShipmentOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ShipmentOptions) WithTaskTimeout(d time.Duration) *ShipmentOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ShipmentOptions) WithTaskQueue(tq string) *ShipmentOptions {
	o.taskQueue = &tq
	return o
}

// ShipmentRun describes a(n) example.nexus.v1.Shipping.Shipment workflow run
type ShipmentRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// shipmentRun provides an internal implementation of a(n) ShipmentRunRun
type shipmentRun struct {
	client *shippingClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *shipmentRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *shipmentRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *shipmentRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *shipmentRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *shipmentRun) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *shipmentRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// ShipmentFunction implements a "example.nexus.v1.Shipping.Shipment" workflow
	ShipmentFunction func(workflow.Context, *ShipmentInput) error
)

// ShippingWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// ShippingWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	ShippingWorkflowFunctions interface {
		// Shipment executes a "example.nexus.v1.Shipping.Shipment" workflow inline
		Shipment(workflow.Context, *ShipmentInput) error
	}
	// shippingWorkflowFunctions provides an internal ShippingWorkflowFunctions implementation
	shippingWorkflowFunctions struct{}
)

func NewShippingWorkflowFunctions() ShippingWorkflowFunctions {
	return &shippingWorkflowFunctions{}
}

// Shipment executes a "example.nexus.v1.Shipping.Shipment" workflow inline
func (f *shippingWorkflowFunctions) Shipment(ctx workflow.Context, req *ShipmentInput) error {
	if ShipmentFunction == nil {
		return errors.New("Shipment requires workflow registration via RegisterShippingWorkflows or RegisterShipmentWorkflow")
	}
	return ShipmentFunction(ctx, req)
}

// ShippingWorkflows provides methods for initializing new example.nexus.v1.Shipping workflow values
type ShippingWorkflows interface {
	// Shipment initializes a new a(n) ShipmentWorkflow implementation
	Shipment(ctx workflow.Context, input *ShipmentWorkflowInput) (ShipmentWorkflow, error)
}

// RegisterShippingWorkflows registers example.nexus.v1.Shipping workflows with the given worker
func RegisterShippingWorkflows(r worker.WorkflowRegistry, workflows ShippingWorkflows) {
	RegisterShipmentWorkflow(r, workflows.Shipment)
}

// RegisterShipmentWorkflow registers a example.nexus.v1.Shipping.Shipment workflow with the given worker
func RegisterShipmentWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *ShipmentWorkflowInput) (ShipmentWorkflow, error)) {
	ShipmentFunction = buildShipment(wf)
	r.RegisterWorkflowWithOptions(ShipmentFunction, workflow.RegisterOptions{Name: ShipmentWorkflowName})
}

// buildShipment converts a Shipment workflow struct into a valid workflow function
func buildShipment(ctor func(workflow.Context, *ShipmentWorkflowInput) (ShipmentWorkflow, error)) func(workflow.Context, *ShipmentInput) error {
	return func(ctx workflow.Context, req *ShipmentInput) error {
		input := &ShipmentWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// ShipmentWorkflowInput describes the input to a(n) example.nexus.v1.Shipping.Shipment workflow constructor
type ShipmentWorkflowInput struct {
	Req *ShipmentInput
}

// ShipmentWorkflow describes a(n) example.nexus.v1.Shipping.Shipment workflow implementation
type ShipmentWorkflow interface {
	// Execute defines the entrypoint to a(n) example.nexus.v1.Shipping.Shipment workflow
	Execute(ctx workflow.Context) error
}

// ShipmentChild executes a child example.nexus.v1.Shipping.Shipment workflow and blocks until error or response received
func ShipmentChild(ctx workflow.Context, req *ShipmentInput, options ...*ShipmentChildOptions) error {
	childRun, err := ShipmentChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// ShipmentChildAsync starts a child example.nexus.v1.Shipping.Shipment workflow and returns a handle to the child workflow run
func ShipmentChildAsync(ctx workflow.Context, req *ShipmentInput, options ...*ShipmentChildOptions) (*ShipmentChildRun, error) {
	var o *ShipmentChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewShipmentChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &ShipmentChildRun{Future: workflow.ExecuteChildWorkflow(ctx, ShipmentWorkflowName, req)}, nil
}

// ShipmentChildOptions provides configuration for a child example.nexus.v1.Shipping.Shipment workflow operation
type ShipmentChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewShipmentChildOptions initializes a new ShipmentChildOptions value
func NewShipmentChildOptions() *ShipmentChildOptions {
	return &ShipmentChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *ShipmentChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = ShippingTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	} else if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowExecutionTimeout = 3600000000000 // 1 hour
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *ShipmentChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *ShipmentChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *ShipmentChildOptions) WithExecutionTimeout(d time.Duration) *ShipmentChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *ShipmentChildOptions) WithID(id string) *ShipmentChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *ShipmentChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *ShipmentChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *ShipmentChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *ShipmentChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *ShipmentChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *ShipmentChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *ShipmentChildOptions) WithRunTimeout(d time.Duration) *ShipmentChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *ShipmentChildOptions) WithSearchAttributes(sa map[string]any) *ShipmentChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *ShipmentChildOptions) WithTaskTimeout(d time.Duration) *ShipmentChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *ShipmentChildOptions) WithTaskQueue(tq string) *ShipmentChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *ShipmentChildOptions) WithWaitForCancellation(wait bool) *ShipmentChildOptions {
	o.waitForCancellation = &wait
	return o
}

// ShipmentChildRun describes a child Shipment workflow run
type ShipmentChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *ShipmentChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *ShipmentChildRun) Select(sel workflow.Selector, fn func(*ShipmentChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *ShipmentChildRun) SelectStart(sel workflow.Selector, fn func(*ShipmentChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *ShipmentChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// ShippingActivities describes available worker activities
type ShippingActivities interface{}

// RegisterShippingActivities registers activities with a worker
func RegisterShippingActivities(r worker.ActivityRegistry, activities ShippingActivities) {}

// =============================================================================
// Test Client (example.nexus.v1.Shipping)
// =============================================================================

// TestClient provides a testsuite-compatible Client
type TestShippingClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows ShippingWorkflows
}

var _ ShippingClient = &TestShippingClient{}

// NewTestShippingClient initializes a new TestShippingClient value
func NewTestShippingClient(env *testsuite.TestWorkflowEnvironment, workflows ShippingWorkflows, activities ShippingActivities) *TestShippingClient {
	if workflows != nil {
		RegisterShippingWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterShippingActivities(env, activities)
	}
	return &TestShippingClient{env, workflows}
}

// Shipment executes a(n) example.nexus.v1.Shipping.Shipment workflow in the test environment
func (c *TestShippingClient) Shipment(ctx context.Context, req *ShipmentInput, opts ...*ShipmentOptions) error {
	run, err := c.ShipmentAsync(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// ShipmentAsync executes a(n) example.nexus.v1.Shipping.Shipment workflow in the test environment
func (c *TestShippingClient) ShipmentAsync(ctx context.Context, req *ShipmentInput, options ...*ShipmentOptions) (ShipmentRun, error) {
	var o *ShipmentOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewShipmentOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testShipmentRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetShipment is a noop
func (c *TestShippingClient) GetShipment(ctx context.Context, workflowID string, runID string) ShipmentRun {
	return &testShipmentRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestShippingClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestShippingClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ ShipmentRun = &testShipmentRun{}

// testShipmentRun provides convenience methods for interacting with a(n) example.nexus.v1.Shipping.Shipment workflow in the test environment
type testShipmentRun struct {
	client    *TestShippingClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *ShipmentInput
	workflows ShippingWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testShipmentRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.nexus.v1.Shipping.Shipment workflow result
func (r *testShipmentRun) Get(context.Context) error {
	r.env.ExecuteWorkflow(ShipmentWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test example.nexus.v1.Shipping.Shipment workflow run's workflow ID
func (r *testShipmentRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testShipmentRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testShipmentRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testShipmentRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// =============================================================================
// CLI (example.nexus.v1.Shipping)
// =============================================================================

// ShippingCliOptions describes runtime configuration for example.nexus.v1.Shipping cli
type ShippingCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewShippingCliOptions initializes a new ShippingCliOptions value
func NewShippingCliOptions() *ShippingCliOptions {
	return &ShippingCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *ShippingCliOptions) WithAfter(fn func(*v2.Context) error) *ShippingCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *ShippingCliOptions) WithBefore(fn func(*v2.Context) error) *ShippingCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *ShippingCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *ShippingCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *ShippingCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *ShippingCliOptions {
	opts.worker = fn
	return opts
}

// NewShippingCli initializes a cli for a(n) example.nexus.v1.Shipping service
func NewShippingCli(options ...*ShippingCliOptions) (*v2.App, error) {
	commands, err := newShippingCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "shipping",
		Commands: commands,
	}, nil
}

// NewShippingCliCommand initializes a cli command for a example.nexus.v1.Shipping service with subcommands for each query, signal, update, and workflow
func NewShippingCliCommand(options ...*ShippingCliOptions) (*v2.Command, error) {
	subcommands, err := newShippingCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "shipping",
		Subcommands: subcommands,
	}, nil
}

// newShippingCommands initializes (sub)commands for a example.nexus.v1.Shipping cli or command
func newShippingCommands(options ...*ShippingCliOptions) ([]*v2.Command, error) {
	opts := &ShippingCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "shipment",
			Usage:                  "executes a(n) example.nexus.v1.Shipping.Shipment workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "shipping-v1",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "order",
					Usage:    "set the value of the operation's \"Order\" parameter (json-encoded: {id: <string>, customerId: <string>, items: <example.nexus.v1.Item>, receivedAt: <google.protobuf.Timestamp>, status: <example.nexus.v1.OrderStatus>})",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewShippingClient(tc)
				req, err := UnmarshalCliFlagsToShipmentInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.ShipmentAsync(cmd.Context, req, NewShipmentOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", ShipmentWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.nexus.v1.Shipping worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToShipmentInput unmarshals a ShipmentInput from command line flags
func UnmarshalCliFlagsToShipmentInput(cmd *v2.Context) (*ShipmentInput, error) {
	var result ShipmentInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("order") {
		hasValues = true
		var v Order
		if err := protojson.Unmarshal([]byte(cmd.String("order")), &v); err != nil {
			return nil, fmt.Errorf("error unmarshalling \"order\" flag: %w", err)
		}
		result.Order = &v
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// =============================================================================
// Codec (example.nexus.v1.Shipping)
// =============================================================================

// WithShippingSchemeTypes registers all Shipping protobuf types with the given scheme
func WithShippingSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_nexus_v1_nexus_proto.Messages().ByName("ShipmentInput"))
	}
}

// =============================================================================
// Nexus (example.nexus.v1.Shipping)
// =============================================================================

// ShippingServiceName defines the fully-qualified Shipping nexus service name
const ShippingServiceName = "example.nexus.v1.Shipping"

// RegisterShippingOperations registers all example.nexus.v1.Shipping nexus operations with the given service
func RegisterShippingOperations(svc *nexus.Service) error {
	return svc.Register(
		ShipmentWorkflowOperation,
	)
}

// RegisterShippingService registers a example.nexus.v1.Shipping nexus service with a given worker
func RegisterShippingService(r worker.NexusServiceRegistry) error {
	svc := nexus.NewService(ShippingServiceName)
	if err := RegisterShippingOperations(svc); err != nil {
		return err
	}
	r.RegisterNexusService(svc)
	return nil
}

// ShipmentWorkflowOperationName defines the fully-qualified name for a example.nexus.v1.Shipping.Shipment nexus workflow operation
const ShipmentWorkflowOperationName = "Shipment"

// ShipmentWorkflowOperation defines a(n) example.nexus.v1.Shipping.Shipment nexus workflow operation
var ShipmentWorkflowOperation = temporalnexus.MustNewWorkflowRunOperationWithOptions(
	temporalnexus.WorkflowRunOperationOptions[*ShipmentInput, *emptypb.Empty]{
		Name: ShipmentWorkflowOperationName,
		Handler: func(ctx context.Context, input *ShipmentInput, opts nexus.StartOperationOptions) (temporalnexus.WorkflowHandle[*emptypb.Empty], error) {
			o, err := NewShipmentOptions().Build(input.ProtoReflect())
			if err != nil {
				return nil, err
			}
			return temporalnexus.ExecuteUntypedWorkflow[*emptypb.Empty](ctx, opts, o, ShipmentWorkflowName, input)
		},
	},
)

// ShipmentWorkflowOperationFuture describes a handle to an asynchronous example.nexus.v1.Shipping.Shipment nexus workflow operation
type ShipmentWorkflowOperationFuture interface {
	// Future returns the underlying NexusOperationFuture
	Future() workflow.NexusOperationFuture
	// Get blocks until the nexus operation is complete, returning the result or error
	Get(ctx workflow.Context) error
}

// shipmentWorkflowOperationFuture provides an internal ShipmentWorkflowOperationFuture implementation
type shipmentWorkflowOperationFuture struct {
	f workflow.NexusOperationFuture
}

// Future returns the underlying NexusOperationFuture
func (f *shipmentWorkflowOperationFuture) Future() workflow.NexusOperationFuture {
	return f.f
}

// Get blocks until the nexus operation is complete, returning the result or error
func (f *shipmentWorkflowOperationFuture) Get(ctx workflow.Context) error {
	return f.f.Get(ctx, nil)
}

// ShipmentWorkflowOperationOptions provides methods for configuration a(n) example.nexus.v1.Shipping.Shipment nexus workflow operation
type ShipmentWorkflowOperationOptions struct {
	opts                   *workflow.NexusOperationOptions
	scheduleToCloseTimeout *durationpb.Duration
}

// NewShipmentWorkflowOperationOptions initializes a new ShipmentWorkflowOperationOptions value
func NewShipmentWorkflowOperationOptions() *ShipmentWorkflowOperationOptions {
	return &ShipmentWorkflowOperationOptions{}
}

// Build converts a(n) ShipmentWorkflowOperationOptions value into a workflow.NexusOperationOptions value
func (o *ShipmentWorkflowOperationOptions) Build(ctx workflow.Context) (workflow.NexusOperationOptions, error) {
	var opts workflow.NexusOperationOptions
	if o == nil {
		return opts, nil
	}

	if v := o.opts; v != nil {
		opts = *o.opts
	}

	if v := o.scheduleToCloseTimeout; v.IsValid() {
		opts.ScheduleToCloseTimeout = v.AsDuration()
	} else if opts.ScheduleToCloseTimeout == 0 {
		opts.ScheduleToCloseTimeout = 3600000000000 // 1 hour
	}

	return opts, nil
}

// WithOptions overrides the initial NexusOperationOptions to which defaults and overrides are then applied
func (o *ShipmentWorkflowOperationOptions) WithOptions(opts workflow.NexusOperationOptions) *ShipmentWorkflowOperationOptions {
	o.opts = &opts
	return o
}

// WithScheduleToCloseTimeout overrides the default ScheduleToCloseTimeout
func (o *ShipmentWorkflowOperationOptions) WithScheduleToCloseTimeout(d time.Duration) *ShipmentWorkflowOperationOptions {
	o.scheduleToCloseTimeout = durationpb.New(d)
	return o
}

// ShippingNexusClient describes a(n) example.nexus.v1.Shipping nexus client
type ShippingNexusClient interface {
	// Shipment executes a(n) example.nexus.v1.Shipping.Shipment nexus workflow operation and blocks until complete
	Shipment(ctx workflow.Context, input *ShipmentInput, options ...*ShipmentWorkflowOperationOptions) error
	// ShipmentAsync starts a(n) example.nexus.v1.Shipping.Shipment nexus workflow operation and returns a handle to the operation
	ShipmentAsync(ctx workflow.Context, input *ShipmentInput, options ...*ShipmentWorkflowOperationOptions) ShipmentWorkflowOperationFuture
}

// shippingNexusClient provides an internal ShippingNexusClient implementation
type shippingNexusClient struct {
	client workflow.NexusClient
}

// NewShippingNexusClient initializes a new example.nexus.v1.Shipping nexus client
func NewShippingNexusClient(endpoint string) ShippingNexusClient {
	return &shippingNexusClient{
		client: workflow.NewNexusClient(endpoint, ShippingServiceName),
	}
}

// Shipment executes a(n) example.nexus.v1.Shipping.Shipment nexus workflow operation and blocks until complete
func (c *shippingNexusClient) Shipment(ctx workflow.Context, input *ShipmentInput, options ...*ShipmentWorkflowOperationOptions) error {
	return c.ShipmentAsync(ctx, input, options...).Get(ctx)
}

// %!s(MISSING) starts a(n) %!s(MISSING) nexus workflow operation, returning a handle to the operation
func (c *shippingNexusClient) ShipmentAsync(ctx workflow.Context, input *ShipmentInput, options ...*ShipmentWorkflowOperationOptions) ShipmentWorkflowOperationFuture {
	var o *ShipmentWorkflowOperationOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	}

	opts, err := o.Build(ctx)
	if err != nil {
		return &shipmentWorkflowOperationFuture{
			f: errs.NewNexusOperationFutureError(err),
		}
	}

	return &shipmentWorkflowOperationFuture{
		f: c.client.ExecuteOperation(ctx, ShipmentWorkflowOperationName, input, opts),
	}
}
