// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.15.1-next (f1e76430351366c0f5ba139a759e99d0ffa098d7)
//	go go1.23.5
//	protoc (unknown)
//
// source: example/protocgengonexus/example.proto
package protocgengonexus

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	helpers "github.com/cludden/protoc-gen-go-temporal/pkg/helpers"
	scheme "github.com/cludden/protoc-gen-go-temporal/pkg/scheme"
	gohomedir "github.com/mitchellh/go-homedir"
	v2 "github.com/urfave/cli/v2"
	enumsv1 "go.temporal.io/api/enums/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	"log/slog"
	"os"
	"sort"
	"time"
)

// GreetingTaskQueue is the default task-queue for a example.protocgengonexus.Greeting worker
const GreetingTaskQueue = "example"

// example.protocgengonexus.Greeting workflow names
const (
	GreetWorkflowName = "example.protocgengonexus.Greeting.Greet"
)

// example.protocgengonexus.Greeting workflow id expressions
var (
	GreetIdexpression = expression.MustParseExpression("Greet/${! name.or(\"World\") }")
)

// example.protocgengonexus.Greeting activity names
const (
	GenerateGreetingActivityName = "example.protocgengonexus.Greeting.GenerateGreeting"
)

// GreetingClient describes a client for a(n) example.protocgengonexus.Greeting worker
type GreetingClient interface {
	// Greet executes a(n) example.protocgengonexus.Greeting.Greet workflow and blocks until error or response received
	Greet(ctx context.Context, req *GreetInput, opts ...*GreetOptions) (*GreetOutput, error)

	// GreetAsync starts a(n) example.protocgengonexus.Greeting.Greet workflow and returns a handle to the workflow run
	GreetAsync(ctx context.Context, req *GreetInput, opts ...*GreetOptions) (GreetRun, error)

	// GetGreet retrieves a handle to an existing example.protocgengonexus.Greeting.Greet workflow execution
	GetGreet(ctx context.Context, workflowID string, runID string) GreetRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// greetingClient implements a temporal client for a example.protocgengonexus.Greeting service
type greetingClient struct {
	client client.Client
	log    *slog.Logger
}

// NewGreetingClient initializes a new example.protocgengonexus.Greeting client
func NewGreetingClient(c client.Client, options ...*greetingClientOptions) GreetingClient {
	var cfg *greetingClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewGreetingClientOptions()
	}
	return &greetingClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewGreetingClientWithOptions initializes a new Greeting client with the given options
func NewGreetingClientWithOptions(c client.Client, opts client.Options, options ...*greetingClientOptions) (GreetingClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *greetingClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewGreetingClientOptions()
	}
	return &greetingClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// greetingClientOptions describes optional runtime configuration for a GreetingClient
type greetingClientOptions struct {
	log *slog.Logger
}

// NewGreetingClientOptions initializes a new greetingClientOptions value
func NewGreetingClientOptions() *greetingClientOptions {
	return &greetingClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *greetingClientOptions) WithLogger(l *slog.Logger) *greetingClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *greetingClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.protocgengonexus.Greeting.Greet executes a example.protocgengonexus.Greeting.Greet workflow and blocks until error or response received
func (c *greetingClient) Greet(ctx context.Context, req *GreetInput, options ...*GreetOptions) (*GreetOutput, error) {
	run, err := c.GreetAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// GreetAsync starts a(n) example.protocgengonexus.Greeting.Greet workflow and returns a handle to the workflow run
func (c *greetingClient) GreetAsync(ctx context.Context, req *GreetInput, options ...*GreetOptions) (GreetRun, error) {
	var o *GreetOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGreetOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, GreetWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &greetRun{
		client: c,
		run:    run,
	}, nil
}

// GetGreet fetches an existing example.protocgengonexus.Greeting.Greet execution
func (c *greetingClient) GetGreet(ctx context.Context, workflowID string, runID string) GreetRun {
	return &greetRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *greetingClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *greetingClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// GreetOptions provides configuration for a example.protocgengonexus.Greeting.Greet workflow operation
type GreetOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewGreetOptions initializes a new GreetOptions value
func NewGreetOptions() *GreetOptions {
	return &GreetOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *GreetOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(GreetIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", GreetWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = GreetingTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *GreetOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *GreetOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *GreetOptions) WithExecutionTimeout(d time.Duration) *GreetOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *GreetOptions) WithID(id string) *GreetOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *GreetOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *GreetOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *GreetOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *GreetOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *GreetOptions) WithRunTimeout(d time.Duration) *GreetOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *GreetOptions) WithSearchAttributes(sa map[string]any) *GreetOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *GreetOptions) WithTaskTimeout(d time.Duration) *GreetOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *GreetOptions) WithTaskQueue(tq string) *GreetOptions {
	o.taskQueue = &tq
	return o
}

// GreetRun describes a(n) example.protocgengonexus.Greeting.Greet workflow run
type GreetRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*GreetOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// greetRun provides an internal implementation of a(n) GreetRunRun
type greetRun struct {
	client *greetingClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *greetRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *greetRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *greetRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *greetRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *greetRun) Get(ctx context.Context) (*GreetOutput, error) {
	var resp GreetOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *greetRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// GreetFunction implements a "example.protocgengonexus.Greeting.Greet" workflow
	GreetFunction func(workflow.Context, *GreetInput) (*GreetOutput, error)
)

// GreetingWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// GreetingWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	GreetingWorkflowFunctions interface {
		// Greet executes a "example.protocgengonexus.Greeting.Greet" workflow inline
		Greet(workflow.Context, *GreetInput) (*GreetOutput, error)
	}
	// greetingWorkflowFunctions provides an internal GreetingWorkflowFunctions implementation
	greetingWorkflowFunctions struct{}
)

func NewGreetingWorkflowFunctions() GreetingWorkflowFunctions {
	return &greetingWorkflowFunctions{}
}

// Greet executes a "example.protocgengonexus.Greeting.Greet" workflow inline
func (f *greetingWorkflowFunctions) Greet(ctx workflow.Context, req *GreetInput) (*GreetOutput, error) {
	if GreetFunction == nil {
		return nil, errors.New("Greet requires workflow registration via RegisterGreetingWorkflows or RegisterGreetWorkflow")
	}
	return GreetFunction(ctx, req)
}

// GreetingWorkflows provides methods for initializing new example.protocgengonexus.Greeting workflow values
type GreetingWorkflows interface {
	// Greet initializes a new a(n) GreetWorkflow implementation
	Greet(ctx workflow.Context, input *GreetWorkflowInput) (GreetWorkflow, error)
}

// RegisterGreetingWorkflows registers example.protocgengonexus.Greeting workflows with the given worker
func RegisterGreetingWorkflows(r worker.WorkflowRegistry, workflows GreetingWorkflows) {
	RegisterGreetWorkflow(r, workflows.Greet)
}

// RegisterGreetWorkflow registers a example.protocgengonexus.Greeting.Greet workflow with the given worker
func RegisterGreetWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *GreetWorkflowInput) (GreetWorkflow, error)) {
	GreetFunction = buildGreet(wf)
	r.RegisterWorkflowWithOptions(GreetFunction, workflow.RegisterOptions{Name: GreetWorkflowName})
}

// buildGreet converts a Greet workflow struct into a valid workflow function
func buildGreet(ctor func(workflow.Context, *GreetWorkflowInput) (GreetWorkflow, error)) func(workflow.Context, *GreetInput) (*GreetOutput, error) {
	return func(ctx workflow.Context, req *GreetInput) (*GreetOutput, error) {
		input := &GreetWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// GreetWorkflowInput describes the input to a(n) example.protocgengonexus.Greeting.Greet workflow constructor
type GreetWorkflowInput struct {
	Req *GreetInput
}

// GreetWorkflow describes a(n) example.protocgengonexus.Greeting.Greet workflow implementation
//
// workflow details: (id: "Greet/${! name.or("World") }")
type GreetWorkflow interface {
	// Execute defines the entrypoint to a(n) example.protocgengonexus.Greeting.Greet workflow
	Execute(ctx workflow.Context) (*GreetOutput, error)
}

// GreetChild executes a child example.protocgengonexus.Greeting.Greet workflow and blocks until error or response received
func GreetChild(ctx workflow.Context, req *GreetInput, options ...*GreetChildOptions) (*GreetOutput, error) {
	childRun, err := GreetChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// GreetChildAsync starts a child example.protocgengonexus.Greeting.Greet workflow and returns a handle to the child workflow run
func GreetChildAsync(ctx workflow.Context, req *GreetInput, options ...*GreetChildOptions) (*GreetChildRun, error) {
	var o *GreetChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGreetChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &GreetChildRun{Future: workflow.ExecuteChildWorkflow(ctx, GreetWorkflowName, req)}, nil
}

// GreetChildOptions provides configuration for a child example.protocgengonexus.Greeting.Greet workflow operation
type GreetChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewGreetChildOptions initializes a new GreetChildOptions value
func NewGreetChildOptions() *GreetChildOptions {
	return &GreetChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *GreetChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(GreetIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", GreetWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", GreetWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(GreetIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", GreetWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = GreetingTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *GreetChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *GreetChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *GreetChildOptions) WithExecutionTimeout(d time.Duration) *GreetChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *GreetChildOptions) WithID(id string) *GreetChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *GreetChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *GreetChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *GreetChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *GreetChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *GreetChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *GreetChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *GreetChildOptions) WithRunTimeout(d time.Duration) *GreetChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *GreetChildOptions) WithSearchAttributes(sa map[string]any) *GreetChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *GreetChildOptions) WithTaskTimeout(d time.Duration) *GreetChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *GreetChildOptions) WithTaskQueue(tq string) *GreetChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *GreetChildOptions) WithWaitForCancellation(wait bool) *GreetChildOptions {
	o.waitForCancellation = &wait
	return o
}

// GreetChildRun describes a child Greet workflow run
type GreetChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *GreetChildRun) Get(ctx workflow.Context) (*GreetOutput, error) {
	var resp GreetOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *GreetChildRun) Select(sel workflow.Selector, fn func(*GreetChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *GreetChildRun) SelectStart(sel workflow.Selector, fn func(*GreetChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *GreetChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// GreetingActivities describes available worker activities
type GreetingActivities interface {
	// example.protocgengonexus.Greeting.GenerateGreeting implements a(n) example.protocgengonexus.Greeting.GenerateGreeting activity definition
	GenerateGreeting(ctx context.Context, req *GenerateGreetingInput) (*GenerateGreetingOutput, error)
}

// RegisterGreetingActivities registers activities with a worker
func RegisterGreetingActivities(r worker.ActivityRegistry, activities GreetingActivities) {
	RegisterGenerateGreetingActivity(r, activities.GenerateGreeting)
}

// RegisterGenerateGreetingActivity registers a example.protocgengonexus.Greeting.GenerateGreeting activity
func RegisterGenerateGreetingActivity(r worker.ActivityRegistry, fn func(context.Context, *GenerateGreetingInput) (*GenerateGreetingOutput, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: GenerateGreetingActivityName,
	})
}

// GenerateGreetingFuture describes a(n) example.protocgengonexus.Greeting.GenerateGreeting activity execution
type GenerateGreetingFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *GenerateGreetingFuture) Get(ctx workflow.Context) (*GenerateGreetingOutput, error) {
	var resp GenerateGreetingOutput
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *GenerateGreetingFuture) Select(sel workflow.Selector, fn func(*GenerateGreetingFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// GenerateGreeting executes a(n) example.protocgengonexus.Greeting.GenerateGreeting activity
func GenerateGreeting(ctx workflow.Context, req *GenerateGreetingInput, options ...*GenerateGreetingActivityOptions) (*GenerateGreetingOutput, error) {
	return GenerateGreetingAsync(ctx, req, options...).Get(ctx)
}

// GenerateGreetingAsync executes a(n) example.protocgengonexus.Greeting.GenerateGreeting activity (asynchronously)
func GenerateGreetingAsync(ctx workflow.Context, req *GenerateGreetingInput, options ...*GenerateGreetingActivityOptions) *GenerateGreetingFuture {
	var o *GenerateGreetingActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGenerateGreetingActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &GenerateGreetingFuture{Future: errF}
	}
	activity := GenerateGreetingActivityName
	future := &GenerateGreetingFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// GenerateGreetingLocal executes a(n) example.protocgengonexus.Greeting.GenerateGreeting activity (locally)
func GenerateGreetingLocal(ctx workflow.Context, req *GenerateGreetingInput, options ...*GenerateGreetingLocalActivityOptions) (*GenerateGreetingOutput, error) {
	return GenerateGreetingLocalAsync(ctx, req, options...).Get(ctx)
}

// GenerateGreetingLocalAsync executes a(n) example.protocgengonexus.Greeting.GenerateGreeting activity (asynchronously, locally)
func GenerateGreetingLocalAsync(ctx workflow.Context, req *GenerateGreetingInput, options ...*GenerateGreetingLocalActivityOptions) *GenerateGreetingFuture {
	var o *GenerateGreetingLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGenerateGreetingLocalActivityOptions()
	}
	var err error
	if ctx, err = o.Build(ctx); err != nil {
		errF, errS := workflow.NewFuture(ctx)
		errS.SetError(err)
		return &GenerateGreetingFuture{Future: errF}
	}
	var activity any
	if o.fn != nil {
		activity = o.fn
	} else {
		activity = GenerateGreetingActivityName
	}
	future := &GenerateGreetingFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// GenerateGreetingActivityOptions provides configuration for a(n) example.protocgengonexus.Greeting.GenerateGreeting activity
type GenerateGreetingActivityOptions struct {
	options                workflow.ActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	heartbeatTimeout       *time.Duration
	scheduleToStartTimeout *time.Duration
	taskQueue              *string
	waitForCancellation    *bool
}

// NewGenerateGreetingActivityOptions initializes a new GenerateGreetingActivityOptions value
func NewGenerateGreetingActivityOptions() *GenerateGreetingActivityOptions {
	return &GenerateGreetingActivityOptions{}
}

// Build initializes a workflow.Context with appropriate ActivityOptions values derived from schema defaults and any user-defined overrides
func (o *GenerateGreetingActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.heartbeatTimeout; v != nil {
		opts.HeartbeatTimeout = *v
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.scheduleToStartTimeout; v != nil {
		opts.ScheduleToStartTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = GreetingTaskQueue
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return workflow.WithActivityOptions(ctx, opts), nil
}

// WithActivityOptions specifies an initial ActivityOptions value to which defaults will be applied
func (o *GenerateGreetingActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *GenerateGreetingActivityOptions {
	o.options = options
	return o
}

// WithHeartbeatTimeout sets the HeartbeatTimeout value
func (o *GenerateGreetingActivityOptions) WithHeartbeatTimeout(d time.Duration) *GenerateGreetingActivityOptions {
	o.heartbeatTimeout = &d
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *GenerateGreetingActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *GenerateGreetingActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *GenerateGreetingActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *GenerateGreetingActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithScheduleToStartTimeout sets the ScheduleToStartTimeout value
func (o *GenerateGreetingActivityOptions) WithScheduleToStartTimeout(d time.Duration) *GenerateGreetingActivityOptions {
	o.scheduleToStartTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *GenerateGreetingActivityOptions) WithStartToCloseTimeout(d time.Duration) *GenerateGreetingActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *GenerateGreetingActivityOptions) WithTaskQueue(tq string) *GenerateGreetingActivityOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *GenerateGreetingActivityOptions) WithWaitForCancellation(wait bool) *GenerateGreetingActivityOptions {
	o.waitForCancellation = &wait
	return o
}

// GenerateGreetingLocalActivityOptions provides configuration for a(n) example.protocgengonexus.Greeting.GenerateGreeting activity
type GenerateGreetingLocalActivityOptions struct {
	options                workflow.LocalActivityOptions
	retryPolicy            *temporal.RetryPolicy
	scheduleToCloseTimeout *time.Duration
	startToCloseTimeout    *time.Duration
	fn                     func(context.Context, *GenerateGreetingInput) (*GenerateGreetingOutput, error)
}

// NewGenerateGreetingLocalActivityOptions initializes a new GenerateGreetingLocalActivityOptions value
func NewGenerateGreetingLocalActivityOptions() *GenerateGreetingLocalActivityOptions {
	return &GenerateGreetingLocalActivityOptions{}
}

// Build initializes a workflow.Context with appropriate LocalActivityOptions values derived from schema defaults and any user-defined overrides
func (o *GenerateGreetingLocalActivityOptions) Build(ctx workflow.Context) (workflow.Context, error) {
	opts := o.options
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.scheduleToCloseTimeout; v != nil {
		opts.ScheduleToCloseTimeout = *v
	}
	if v := o.startToCloseTimeout; v != nil {
		opts.StartToCloseTimeout = *v
	} else if opts.StartToCloseTimeout == 0 {
		opts.StartToCloseTimeout = 10000000000 // 10 seconds
	}
	return workflow.WithLocalActivityOptions(ctx, opts), nil
}

// Local specifies a custom example.protocgengonexus.Greeting.GenerateGreeting implementation
func (o *GenerateGreetingLocalActivityOptions) Local(fn func(context.Context, *GenerateGreetingInput) (*GenerateGreetingOutput, error)) *GenerateGreetingLocalActivityOptions {
	o.fn = fn
	return o
}

// WithLocalActivityOptions specifies an initial LocalActivityOptions value to which defaults will be applied
func (o *GenerateGreetingLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *GenerateGreetingLocalActivityOptions {
	o.options = options
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *GenerateGreetingLocalActivityOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *GenerateGreetingLocalActivityOptions {
	o.retryPolicy = policy
	return o
}

// WithScheduleToCloseTimeout sets the ScheduleToCloseTimeout value
func (o *GenerateGreetingLocalActivityOptions) WithScheduleToCloseTimeout(d time.Duration) *GenerateGreetingLocalActivityOptions {
	o.scheduleToCloseTimeout = &d
	return o
}

// WithStartToCloseTimeout sets the StartToCloseTimeout value
func (o *GenerateGreetingLocalActivityOptions) WithStartToCloseTimeout(d time.Duration) *GenerateGreetingLocalActivityOptions {
	o.startToCloseTimeout = &d
	return o
}

// TestClient provides a testsuite-compatible Client
type TestGreetingClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows GreetingWorkflows
}

var _ GreetingClient = &TestGreetingClient{}

// NewTestGreetingClient initializes a new TestGreetingClient value
func NewTestGreetingClient(env *testsuite.TestWorkflowEnvironment, workflows GreetingWorkflows, activities GreetingActivities) *TestGreetingClient {
	if workflows != nil {
		RegisterGreetingWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterGreetingActivities(env, activities)
	}
	return &TestGreetingClient{env, workflows}
}

// Greet executes a(n) example.protocgengonexus.Greeting.Greet workflow in the test environment
func (c *TestGreetingClient) Greet(ctx context.Context, req *GreetInput, opts ...*GreetOptions) (*GreetOutput, error) {
	run, err := c.GreetAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// GreetAsync executes a(n) example.protocgengonexus.Greeting.Greet workflow in the test environment
func (c *TestGreetingClient) GreetAsync(ctx context.Context, req *GreetInput, options ...*GreetOptions) (GreetRun, error) {
	var o *GreetOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewGreetOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testGreetRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetGreet is a noop
func (c *TestGreetingClient) GetGreet(ctx context.Context, workflowID string, runID string) GreetRun {
	return &testGreetRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestGreetingClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestGreetingClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ GreetRun = &testGreetRun{}

// testGreetRun provides convenience methods for interacting with a(n) example.protocgengonexus.Greeting.Greet workflow in the test environment
type testGreetRun struct {
	client    *TestGreetingClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *GreetInput
	workflows GreetingWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testGreetRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.protocgengonexus.Greeting.Greet workflow result
func (r *testGreetRun) Get(context.Context) (*GreetOutput, error) {
	r.env.ExecuteWorkflow(GreetWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result GreetOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.protocgengonexus.Greeting.Greet workflow run's workflow ID
func (r *testGreetRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testGreetRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testGreetRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testGreetRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// GreetingCliOptions describes runtime configuration for example.protocgengonexus.Greeting cli
type GreetingCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewGreetingCliOptions initializes a new GreetingCliOptions value
func NewGreetingCliOptions() *GreetingCliOptions {
	return &GreetingCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *GreetingCliOptions) WithAfter(fn func(*v2.Context) error) *GreetingCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *GreetingCliOptions) WithBefore(fn func(*v2.Context) error) *GreetingCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *GreetingCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *GreetingCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *GreetingCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *GreetingCliOptions {
	opts.worker = fn
	return opts
}

// NewGreetingCli initializes a cli for a(n) example.protocgengonexus.Greeting service
func NewGreetingCli(options ...*GreetingCliOptions) (*v2.App, error) {
	commands, err := newGreetingCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "greeting",
		Commands: commands,
	}, nil
}

// NewGreetingCliCommand initializes a cli command for a example.protocgengonexus.Greeting service with subcommands for each query, signal, update, and workflow
func NewGreetingCliCommand(options ...*GreetingCliOptions) (*v2.Command, error) {
	subcommands, err := newGreetingCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "greeting",
		Subcommands: subcommands,
	}, nil
}

// newGreetingCommands initializes (sub)commands for a example.protocgengonexus.Greeting cli or command
func newGreetingCommands(options ...*GreetingCliOptions) ([]*v2.Command, error) {
	opts := &GreetingCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "greet",
			Usage:                  "executes a(n) example.protocgengonexus.Greeting.Greet workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "example",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "set the value of the operation's \"Name\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewGreetingClient(tc)
				req, err := UnmarshalCliFlagsToGreetInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.GreetAsync(cmd.Context, req, NewGreetOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", GreetWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.protocgengonexus.Greeting worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToGreetInput unmarshals a GreetInput from command line flags
func UnmarshalCliFlagsToGreetInput(cmd *v2.Context) (*GreetInput, error) {
	var result GreetInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("name") {
		hasValues = true
		result.Name = cmd.String("name")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithGreetingSchemeTypes registers all Greeting protobuf types with the given scheme
func WithGreetingSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_protocgengonexus_example_proto.Messages().ByName("GenerateGreetingInput"))
		s.RegisterType(File_example_protocgengonexus_example_proto.Messages().ByName("GenerateGreetingOutput"))
		s.RegisterType(File_example_protocgengonexus_example_proto.Messages().ByName("GreetInput"))
		s.RegisterType(File_example_protocgengonexus_example_proto.Messages().ByName("GreetOutput"))
	}
}

// CallerTaskQueue is the default task-queue for a example.protocgengonexus.Caller worker
const CallerTaskQueue = "example"

// example.protocgengonexus.Caller workflow names
const (
	CallGreetWorkflowName = "example.protocgengonexus.Caller.CallGreet"
)

// example.protocgengonexus.Caller workflow id expressions
var (
	CallGreetIdexpression = expression.MustParseExpression("CallGreet/${! name.or(\"World\") }")
)

// CallerClient describes a client for a(n) example.protocgengonexus.Caller worker
type CallerClient interface {
	// CallGreet executes a(n) example.protocgengonexus.Caller.CallGreet workflow and blocks until error or response received
	CallGreet(ctx context.Context, req *CallGreetInput, opts ...*CallGreetOptions) (*CallGreetOutput, error)

	// CallGreetAsync starts a(n) example.protocgengonexus.Caller.CallGreet workflow and returns a handle to the workflow run
	CallGreetAsync(ctx context.Context, req *CallGreetInput, opts ...*CallGreetOptions) (CallGreetRun, error)

	// GetCallGreet retrieves a handle to an existing example.protocgengonexus.Caller.CallGreet workflow execution
	GetCallGreet(ctx context.Context, workflowID string, runID string) CallGreetRun

	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error

	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
}

// callerClient implements a temporal client for a example.protocgengonexus.Caller service
type callerClient struct {
	client client.Client
	log    *slog.Logger
}

// NewCallerClient initializes a new example.protocgengonexus.Caller client
func NewCallerClient(c client.Client, options ...*callerClientOptions) CallerClient {
	var cfg *callerClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewCallerClientOptions()
	}
	return &callerClient{
		client: c,
		log:    cfg.getLogger(),
	}
}

// NewCallerClientWithOptions initializes a new Caller client with the given options
func NewCallerClientWithOptions(c client.Client, opts client.Options, options ...*callerClientOptions) (CallerClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	var cfg *callerClientOptions
	if len(options) > 0 {
		cfg = options[0]
	} else {
		cfg = NewCallerClientOptions()
	}
	return &callerClient{
		client: c,
		log:    cfg.getLogger(),
	}, nil
}

// callerClientOptions describes optional runtime configuration for a CallerClient
type callerClientOptions struct {
	log *slog.Logger
}

// NewCallerClientOptions initializes a new callerClientOptions value
func NewCallerClientOptions() *callerClientOptions {
	return &callerClientOptions{}
}

// WithLogger can be used to override the default logger
func (opts *callerClientOptions) WithLogger(l *slog.Logger) *callerClientOptions {
	if l != nil {
		opts.log = l
	}
	return opts
}

// getLogger returns the configured logger, or the default logger
func (opts *callerClientOptions) getLogger() *slog.Logger {
	if opts != nil && opts.log != nil {
		return opts.log
	}
	return slog.Default()
}

// example.protocgengonexus.Caller.CallGreet executes a example.protocgengonexus.Caller.CallGreet workflow and blocks until error or response received
func (c *callerClient) CallGreet(ctx context.Context, req *CallGreetInput, options ...*CallGreetOptions) (*CallGreetOutput, error) {
	run, err := c.CallGreetAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CallGreetAsync starts a(n) example.protocgengonexus.Caller.CallGreet workflow and returns a handle to the workflow run
func (c *callerClient) CallGreetAsync(ctx context.Context, req *CallGreetInput, options ...*CallGreetOptions) (CallGreetRun, error) {
	var o *CallGreetOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallGreetOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	run, err := c.client.ExecuteWorkflow(ctx, opts, CallGreetWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &callGreetRun{
		client: c,
		run:    run,
	}, nil
}

// GetCallGreet fetches an existing example.protocgengonexus.Caller.CallGreet execution
func (c *callerClient) GetCallGreet(ctx context.Context, workflowID string, runID string) CallGreetRun {
	return &callGreetRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *callerClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *callerClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// CallGreetOptions provides configuration for a example.protocgengonexus.Caller.CallGreet workflow operation
type CallGreetOptions struct {
	options          client.StartWorkflowOptions
	executionTimeout *time.Duration
	id               *string
	idReusePolicy    enumsv1.WorkflowIdReusePolicy
	retryPolicy      *temporal.RetryPolicy
	runTimeout       *time.Duration
	searchAttributes map[string]any
	taskQueue        *string
	taskTimeout      *time.Duration
}

// NewCallGreetOptions initializes a new CallGreetOptions value
func NewCallGreetOptions() *CallGreetOptions {
	return &CallGreetOptions{}
}

// Build initializes a new go.temporal.io/sdk/client.StartWorkflowOptions value with defaults and overrides applied
func (o *CallGreetOptions) Build(req protoreflect.Message) (client.StartWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.ID = *v
	} else if opts.ID == "" {
		id, err := expression.EvalExpression(CallGreetIdexpression, req)
		if err != nil {
			return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CallGreetWorkflowName, err)
		}
		opts.ID = id
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CallerTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	return opts, nil
}

// WithStartWorkflowOptions sets the initial go.temporal.io/sdk/client.StartWorkflowOptions
func (o *CallGreetOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *CallGreetOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CallGreetOptions) WithExecutionTimeout(d time.Duration) *CallGreetOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the ID value
func (o *CallGreetOptions) WithID(id string) *CallGreetOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CallGreetOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CallGreetOptions {
	o.idReusePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CallGreetOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CallGreetOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CallGreetOptions) WithRunTimeout(d time.Duration) *CallGreetOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CallGreetOptions) WithSearchAttributes(sa map[string]any) *CallGreetOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CallGreetOptions) WithTaskTimeout(d time.Duration) *CallGreetOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CallGreetOptions) WithTaskQueue(tq string) *CallGreetOptions {
	o.taskQueue = &tq
	return o
}

// CallGreetRun describes a(n) example.protocgengonexus.Caller.CallGreet workflow run
type CallGreetRun interface {
	// ID returns the workflow ID
	ID() string

	// RunID returns the workflow instance ID
	RunID() string

	// Run returns the inner client.WorkflowRun
	Run() client.WorkflowRun

	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*CallGreetOutput, error)

	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error

	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// callGreetRun provides an internal implementation of a(n) CallGreetRunRun
type callGreetRun struct {
	client *callerClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *callGreetRun) ID() string {
	return r.run.GetID()
}

// Run returns the inner client.WorkflowRun
func (r *callGreetRun) Run() client.WorkflowRun {
	return r.run
}

// RunID returns the execution ID
func (r *callGreetRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *callGreetRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *callGreetRun) Get(ctx context.Context) (*CallGreetOutput, error) {
	var resp CallGreetOutput
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *callGreetRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// Reference to generated workflow functions
var (
	// CallGreetFunction implements a "example.protocgengonexus.Caller.CallGreet" workflow
	CallGreetFunction func(workflow.Context, *CallGreetInput) (*CallGreetOutput, error)
)

// CallerWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
type (
	// CallerWorkflowFunctions describes a mockable dependency for inlining workflows within other workflows
	CallerWorkflowFunctions interface {
		// CallGreet executes a "example.protocgengonexus.Caller.CallGreet" workflow inline
		CallGreet(workflow.Context, *CallGreetInput) (*CallGreetOutput, error)
	}
	// callerWorkflowFunctions provides an internal CallerWorkflowFunctions implementation
	callerWorkflowFunctions struct{}
)

func NewCallerWorkflowFunctions() CallerWorkflowFunctions {
	return &callerWorkflowFunctions{}
}

// CallGreet executes a "example.protocgengonexus.Caller.CallGreet" workflow inline
func (f *callerWorkflowFunctions) CallGreet(ctx workflow.Context, req *CallGreetInput) (*CallGreetOutput, error) {
	if CallGreetFunction == nil {
		return nil, errors.New("CallGreet requires workflow registration via RegisterCallerWorkflows or RegisterCallGreetWorkflow")
	}
	return CallGreetFunction(ctx, req)
}

// CallerWorkflows provides methods for initializing new example.protocgengonexus.Caller workflow values
type CallerWorkflows interface {
	// CallGreet initializes a new a(n) CallGreetWorkflow implementation
	CallGreet(ctx workflow.Context, input *CallGreetWorkflowInput) (CallGreetWorkflow, error)
}

// RegisterCallerWorkflows registers example.protocgengonexus.Caller workflows with the given worker
func RegisterCallerWorkflows(r worker.WorkflowRegistry, workflows CallerWorkflows) {
	RegisterCallGreetWorkflow(r, workflows.CallGreet)
}

// RegisterCallGreetWorkflow registers a example.protocgengonexus.Caller.CallGreet workflow with the given worker
func RegisterCallGreetWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *CallGreetWorkflowInput) (CallGreetWorkflow, error)) {
	CallGreetFunction = buildCallGreet(wf)
	r.RegisterWorkflowWithOptions(CallGreetFunction, workflow.RegisterOptions{Name: CallGreetWorkflowName})
}

// buildCallGreet converts a CallGreet workflow struct into a valid workflow function
func buildCallGreet(ctor func(workflow.Context, *CallGreetWorkflowInput) (CallGreetWorkflow, error)) func(workflow.Context, *CallGreetInput) (*CallGreetOutput, error) {
	return func(ctx workflow.Context, req *CallGreetInput) (*CallGreetOutput, error) {
		input := &CallGreetWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if initializable, ok := wf.(helpers.Initializable); ok {
			if err := initializable.Initialize(ctx); err != nil {
				return nil, err
			}
		}
		return wf.Execute(ctx)
	}
}

// CallGreetWorkflowInput describes the input to a(n) example.protocgengonexus.Caller.CallGreet workflow constructor
type CallGreetWorkflowInput struct {
	Req *CallGreetInput
}

// CallGreetWorkflow describes a(n) example.protocgengonexus.Caller.CallGreet workflow implementation
//
// workflow details: (id: "CallGreet/${! name.or("World") }")
type CallGreetWorkflow interface {
	// Execute defines the entrypoint to a(n) example.protocgengonexus.Caller.CallGreet workflow
	Execute(ctx workflow.Context) (*CallGreetOutput, error)
}

// CallGreetChild executes a child example.protocgengonexus.Caller.CallGreet workflow and blocks until error or response received
func CallGreetChild(ctx workflow.Context, req *CallGreetInput, options ...*CallGreetChildOptions) (*CallGreetOutput, error) {
	childRun, err := CallGreetChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// CallGreetChildAsync starts a child example.protocgengonexus.Caller.CallGreet workflow and returns a handle to the child workflow run
func CallGreetChildAsync(ctx workflow.Context, req *CallGreetInput, options ...*CallGreetChildOptions) (*CallGreetChildRun, error) {
	var o *CallGreetChildOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallGreetChildOptions()
	}
	opts, err := o.Build(ctx, req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing workflow.ChildWorkflowOptions: %w", err)
	}
	ctx = workflow.WithChildOptions(ctx, opts)
	return &CallGreetChildRun{Future: workflow.ExecuteChildWorkflow(ctx, CallGreetWorkflowName, req)}, nil
}

// CallGreetChildOptions provides configuration for a child example.protocgengonexus.Caller.CallGreet workflow operation
type CallGreetChildOptions struct {
	options             workflow.ChildWorkflowOptions
	executionTimeout    *time.Duration
	id                  *string
	idReusePolicy       enumsv1.WorkflowIdReusePolicy
	retryPolicy         *temporal.RetryPolicy
	runTimeout          *time.Duration
	searchAttributes    map[string]any
	taskQueue           *string
	taskTimeout         *time.Duration
	parentClosePolicy   enumsv1.ParentClosePolicy
	waitForCancellation *bool
}

// NewCallGreetChildOptions initializes a new CallGreetChildOptions value
func NewCallGreetChildOptions() *CallGreetChildOptions {
	return &CallGreetChildOptions{}
}

// Build initializes a new go.temporal.io/sdk/workflow.ChildWorkflowOptions value with defaults and overrides applied
func (o *CallGreetChildOptions) Build(ctx workflow.Context, req protoreflect.Message) (workflow.ChildWorkflowOptions, error) {
	opts := o.options
	if v := o.id; v != nil {
		opts.WorkflowID = *v
	} else if opts.WorkflowID == "" {
		// wrap expression evaluation in local activity
		// more info: https://cludden.github.io/protoc-gen-go-temporal/docs/guides/patches#pv_64-expression-evaluation-local-activity
		if workflow.GetVersion(ctx, "cludden_protoc-gen-go-temporal_64_expression-evaluation-local-activity", workflow.DefaultVersion, 1) == 1 {
			lao := workflow.GetLocalActivityOptions(ctx)
			lao.ScheduleToCloseTimeout = time.Second * 10
			if err := workflow.ExecuteLocalActivity(workflow.WithLocalActivityOptions(ctx, lao), func(ctx context.Context) (string, error) {
				id, err := expression.EvalExpression(CallGreetIdexpression, req)
				if err != nil {
					return "", fmt.Errorf("error evaluating id expression for %q workflow: %w", CallGreetWorkflowName, err)
				}
				return id, nil
			}).Get(ctx, &opts.WorkflowID); err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CallGreetWorkflowName, err)
			}
		} else {
			id, err := expression.EvalExpression(CallGreetIdexpression, req)
			if err != nil {
				return opts, fmt.Errorf("error evaluating id expression for %q workflow: %w", CallGreetWorkflowName, err)
			}
			opts.WorkflowID = id
		}
	}
	if v := o.idReusePolicy; v != enumsv1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v
	}
	if v := o.taskQueue; v != nil {
		opts.TaskQueue = *v
	} else if opts.TaskQueue == "" {
		opts.TaskQueue = CallerTaskQueue
	}
	if v := o.retryPolicy; v != nil {
		opts.RetryPolicy = v
	}
	if v := o.searchAttributes; v != nil {
		opts.SearchAttributes = o.searchAttributes
	}
	if v := o.executionTimeout; v != nil {
		opts.WorkflowExecutionTimeout = *v
	}
	if v := o.runTimeout; v != nil {
		opts.WorkflowRunTimeout = *v
	}
	if v := o.taskTimeout; v != nil {
		opts.WorkflowTaskTimeout = *v
	}
	if v := o.parentClosePolicy; v != enumsv1.PARENT_CLOSE_POLICY_UNSPECIFIED {
		opts.ParentClosePolicy = v
	}
	if v := o.waitForCancellation; v != nil {
		opts.WaitForCancellation = *v
	}
	return opts, nil
}

// WithChildWorkflowOptions sets the initial go.temporal.io/sdk/workflow.ChildWorkflowOptions
func (o *CallGreetChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *CallGreetChildOptions {
	o.options = options
	return o
}

// WithExecutionTimeout sets the WorkflowExecutionTimeout value
func (o *CallGreetChildOptions) WithExecutionTimeout(d time.Duration) *CallGreetChildOptions {
	o.executionTimeout = &d
	return o
}

// WithID sets the WorkflowID value
func (o *CallGreetChildOptions) WithID(id string) *CallGreetChildOptions {
	o.id = &id
	return o
}

// WithIDReusePolicy sets the WorkflowIDReusePolicy value
func (o *CallGreetChildOptions) WithIDReusePolicy(policy enumsv1.WorkflowIdReusePolicy) *CallGreetChildOptions {
	o.idReusePolicy = policy
	return o
}

// WithParentClosePolicy sets the WorkflowIDReusePolicy value
func (o *CallGreetChildOptions) WithParentClosePolicy(policy enumsv1.ParentClosePolicy) *CallGreetChildOptions {
	o.parentClosePolicy = policy
	return o
}

// WithRetryPolicy sets the RetryPolicy value
func (o *CallGreetChildOptions) WithRetryPolicy(policy *temporal.RetryPolicy) *CallGreetChildOptions {
	o.retryPolicy = policy
	return o
}

// WithRunTimeout sets the WorkflowRunTimeout value
func (o *CallGreetChildOptions) WithRunTimeout(d time.Duration) *CallGreetChildOptions {
	o.runTimeout = &d
	return o
}

// WithSearchAttributes sets the SearchAttributes value
func (o *CallGreetChildOptions) WithSearchAttributes(sa map[string]any) *CallGreetChildOptions {
	o.searchAttributes = sa
	return o
}

// WithTaskTimeout sets the WorkflowTaskTimeout value
func (o *CallGreetChildOptions) WithTaskTimeout(d time.Duration) *CallGreetChildOptions {
	o.taskTimeout = &d
	return o
}

// WithTaskQueue sets the TaskQueue value
func (o *CallGreetChildOptions) WithTaskQueue(tq string) *CallGreetChildOptions {
	o.taskQueue = &tq
	return o
}

// WithWaitForCancellation sets the WaitForCancellation value
func (o *CallGreetChildOptions) WithWaitForCancellation(wait bool) *CallGreetChildOptions {
	o.waitForCancellation = &wait
	return o
}

// CallGreetChildRun describes a child CallGreet workflow run
type CallGreetChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *CallGreetChildRun) Get(ctx workflow.Context) (*CallGreetOutput, error) {
	var resp CallGreetOutput
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *CallGreetChildRun) Select(sel workflow.Selector, fn func(*CallGreetChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *CallGreetChildRun) SelectStart(sel workflow.Selector, fn func(*CallGreetChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *CallGreetChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// CallerActivities describes available worker activities
type CallerActivities interface{}

// RegisterCallerActivities registers activities with a worker
func RegisterCallerActivities(r worker.ActivityRegistry, activities CallerActivities) {}

// TestClient provides a testsuite-compatible Client
type TestCallerClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows CallerWorkflows
}

var _ CallerClient = &TestCallerClient{}

// NewTestCallerClient initializes a new TestCallerClient value
func NewTestCallerClient(env *testsuite.TestWorkflowEnvironment, workflows CallerWorkflows, activities CallerActivities) *TestCallerClient {
	if workflows != nil {
		RegisterCallerWorkflows(env, workflows)
	}
	if activities != nil {
		RegisterCallerActivities(env, activities)
	}
	return &TestCallerClient{env, workflows}
}

// CallGreet executes a(n) example.protocgengonexus.Caller.CallGreet workflow in the test environment
func (c *TestCallerClient) CallGreet(ctx context.Context, req *CallGreetInput, opts ...*CallGreetOptions) (*CallGreetOutput, error) {
	run, err := c.CallGreetAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// CallGreetAsync executes a(n) example.protocgengonexus.Caller.CallGreet workflow in the test environment
func (c *TestCallerClient) CallGreetAsync(ctx context.Context, req *CallGreetInput, options ...*CallGreetOptions) (CallGreetRun, error) {
	var o *CallGreetOptions
	if len(options) > 0 && options[0] != nil {
		o = options[0]
	} else {
		o = NewCallGreetOptions()
	}
	opts, err := o.Build(req.ProtoReflect())
	if err != nil {
		return nil, fmt.Errorf("error initializing client.StartWorkflowOptions: %w", err)
	}
	return &testCallGreetRun{client: c, env: c.env, opts: &opts, req: req, workflows: c.workflows}, nil
}

// GetCallGreet is a noop
func (c *TestCallerClient) GetCallGreet(ctx context.Context, workflowID string, runID string) CallGreetRun {
	return &testCallGreetRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestCallerClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestCallerClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

var _ CallGreetRun = &testCallGreetRun{}

// testCallGreetRun provides convenience methods for interacting with a(n) example.protocgengonexus.Caller.CallGreet workflow in the test environment
type testCallGreetRun struct {
	client    *TestCallerClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *CallGreetInput
	workflows CallerWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testCallGreetRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test example.protocgengonexus.Caller.CallGreet workflow result
func (r *testCallGreetRun) Get(context.Context) (*CallGreetOutput, error) {
	r.env.ExecuteWorkflow(CallGreetWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result CallGreetOutput
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test example.protocgengonexus.Caller.CallGreet workflow run's workflow ID
func (r *testCallGreetRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// Run noop implementation
func (r *testCallGreetRun) Run() client.WorkflowRun {
	return nil
}

// RunID noop implementation
func (r *testCallGreetRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testCallGreetRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// CallerCliOptions describes runtime configuration for example.protocgengonexus.Caller cli
type CallerCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewCallerCliOptions initializes a new CallerCliOptions value
func NewCallerCliOptions() *CallerCliOptions {
	return &CallerCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *CallerCliOptions) WithAfter(fn func(*v2.Context) error) *CallerCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *CallerCliOptions) WithBefore(fn func(*v2.Context) error) *CallerCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *CallerCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *CallerCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *CallerCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *CallerCliOptions {
	opts.worker = fn
	return opts
}

// NewCallerCli initializes a cli for a(n) example.protocgengonexus.Caller service
func NewCallerCli(options ...*CallerCliOptions) (*v2.App, error) {
	commands, err := newCallerCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "caller",
		Commands: commands,
	}, nil
}

// NewCallerCliCommand initializes a cli command for a example.protocgengonexus.Caller service with subcommands for each query, signal, update, and workflow
func NewCallerCliCommand(options ...*CallerCliOptions) (*v2.Command, error) {
	subcommands, err := newCallerCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "caller",
		Subcommands: subcommands,
	}, nil
}

// newCallerCommands initializes (sub)commands for a example.protocgengonexus.Caller cli or command
func newCallerCommands(options ...*CallerCliOptions) ([]*v2.Command, error) {
	opts := &CallerCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		{
			Name:                   "call-greet",
			Usage:                  "executes a(n) example.protocgengonexus.Caller.CallGreet workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:    "task-queue",
					Usage:   "task queue name",
					Aliases: []string{"t"},
					EnvVars: []string{"TEMPORAL_TASK_QUEUE_NAME", "TEMPORAL_TASK_QUEUE", "TASK_QUEUE_NAME", "TASK_QUEUE"},
					Value:   "example",
				},
				&v2.StringFlag{
					Name:    "input-file",
					Usage:   "path to json-formatted input file",
					Aliases: []string{"f"},
				},
				&v2.StringFlag{
					Name:     "name",
					Usage:    "set the value of the operation's \"Name\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				tc, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer tc.Close()
				c := NewCallerClient(tc)
				req, err := UnmarshalCliFlagsToCallGreetInput(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				opts := client.StartWorkflowOptions{}
				if tq := cmd.String("task-queue"); tq != "" {
					opts.TaskQueue = tq
				}
				run, err := c.CallGreetAsync(cmd.Context, req, NewCallGreetOptions().WithStartWorkflowOptions(opts))
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", CallGreetWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a example.protocgengonexus.Caller worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// UnmarshalCliFlagsToCallGreetInput unmarshals a CallGreetInput from command line flags
func UnmarshalCliFlagsToCallGreetInput(cmd *v2.Context) (*CallGreetInput, error) {
	var result CallGreetInput
	var hasValues bool
	if cmd.IsSet("input-file") {
		inputFile, err := gohomedir.Expand(cmd.String("input-file"))
		if err != nil {
			inputFile = cmd.String("input-file")
		}
		b, err := os.ReadFile(inputFile)
		if err != nil {
			return nil, fmt.Errorf("error reading input-file: %w", err)
		}
		if err := protojson.Unmarshal(b, &result); err != nil {
			return nil, fmt.Errorf("error parsing input-file json: %w", err)
		}
		hasValues = true
	}
	if cmd.IsSet("name") {
		hasValues = true
		result.Name = cmd.String("name")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// WithCallerSchemeTypes registers all Caller protobuf types with the given scheme
func WithCallerSchemeTypes() scheme.Option {
	return func(s *scheme.Scheme) {
		s.RegisterType(File_example_protocgengonexus_example_proto.Messages().ByName("CallGreetInput"))
		s.RegisterType(File_example_protocgengonexus_example_proto.Messages().ByName("CallGreetOutput"))
	}
}
