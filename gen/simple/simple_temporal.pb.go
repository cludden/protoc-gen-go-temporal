// Code generated by protoc-gen-go_temporal. DO NOT EDIT.
// versions:
//
//	protoc-gen-go_temporal 1.0.0-next (c780e52b9e1b4a122993ac6d83598ba4c1edef20)
//	go go1.20.4
//	protoc (unknown)
//
// source: simple/simple.proto
package simple

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	expression "github.com/cludden/protoc-gen-go-temporal/pkg/expression"
	testutil "github.com/cludden/protoc-gen-go-temporal/pkg/testutil"
	v2 "github.com/urfave/cli/v2"
	v1 "go.temporal.io/api/enums/v1"
	v11 "go.temporal.io/api/update/v1"
	activity "go.temporal.io/sdk/activity"
	client "go.temporal.io/sdk/client"
	temporal "go.temporal.io/sdk/temporal"
	testsuite "go.temporal.io/sdk/testsuite"
	worker "go.temporal.io/sdk/worker"
	workflow "go.temporal.io/sdk/workflow"
	protojson "google.golang.org/protobuf/encoding/protojson"
	"sort"
)

// SimpleTaskQueue= is the default task-queue for a mycompany.simple.Simple worker
const SimpleTaskQueue = "my-task-queue"

// mycompany.simple.Simple workflow names
const (
	SomeWorkflow1WorkflowName = "mycompany.simple.SomeWorkflow1"
	SomeWorkflow2WorkflowName = "mycompany.simple.SomeWorkflow2"
	SomeWorkflow3WorkflowName = "mycompany.simple.Simple.SomeWorkflow3"
)

// mycompany.simple.Simple workflow id expressions
var (
	SomeWorkflow1IDExpression = expression.MustParseExpression("some-workflow-1/${! id }/${! uuid_v4() }")
	SomeWorkflow3IDExpression = expression.MustParseExpression("some-workflow-3/${! id }/${! requestVal }")
)

// mycompany.simple.Simple activity names
const (
	SomeActivity1ActivityName = "mycompany.simple.SomeActivity1"
	SomeActivity2ActivityName = "mycompany.simple.Simple.SomeActivity2"
	SomeActivity3ActivityName = "mycompany.simple.Simple.SomeActivity3"
)

// mycompany.simple.Simple query names
const (
	SomeQuery1QueryName = "mycompany.simple.Simple.SomeQuery1"
	SomeQuery2QueryName = "mycompany.simple.Simple.SomeQuery2"
)

// mycompany.simple.Simple signal names
const (
	SomeSignal1SignalName = "mycompany.simple.Simple.SomeSignal1"
	SomeSignal2SignalName = "mycompany.simple.Simple.SomeSignal2"
)

// mycompany.simple.Simple update names
const (
	SomeUpdate1UpdateName = "mycompany.simple.Simple.SomeUpdate1"
)

// mycompany.simple.Simple update id expressions
var (
	SomeUpdate1IDExpression = expression.MustParseExpression("some-update/${! requestVal.not_empty().catch(\"default\").slug() }")
)

// SimpleClient describes a client for a(n) mycompany.simple.Simple worker
type SimpleClient interface {
	// SomeWorkflow1 does some workflow thing.
	SomeWorkflow1(ctx context.Context, req *SomeWorkflow1Request, opts ...*SomeWorkflow1Options) (*SomeWorkflow1Response, error)
	// SomeWorkflow1Async executes a(n) mycompany.simple.Simple.SomeWorkflow1 workflow asynchronously
	SomeWorkflow1Async(ctx context.Context, req *SomeWorkflow1Request, opts ...*SomeWorkflow1Options) (SomeWorkflow1Run, error)
	// GetSomeWorkflow1 retrieves a handle to an existing mycompany.simple.Simple.SomeWorkflow1 workflow execution
	GetSomeWorkflow1(ctx context.Context, workflowID string, runID string) SomeWorkflow1Run
	// SomeWorkflow2 does some workflow thing.
	SomeWorkflow2(ctx context.Context, opts ...*SomeWorkflow2Options) error
	// SomeWorkflow2Async executes a(n) mycompany.simple.Simple.SomeWorkflow2 workflow asynchronously
	SomeWorkflow2Async(ctx context.Context, opts ...*SomeWorkflow2Options) (SomeWorkflow2Run, error)
	// GetSomeWorkflow2 retrieves a handle to an existing mycompany.simple.Simple.SomeWorkflow2 workflow execution
	GetSomeWorkflow2(ctx context.Context, workflowID string, runID string) SomeWorkflow2Run
	/*
	   SomeSignal1 is a signal.
	*/
	SomeWorkflow2WithSomeSignal1(ctx context.Context, opts ...*SomeWorkflow2Options) error
	/*
	   SomeSignal1 is a signal.
	*/
	SomeWorkflow2WithSomeSignal1Async(ctx context.Context, opts ...*SomeWorkflow2Options) (SomeWorkflow2Run, error)
	// SomeWorkflow3 does some workflow thing.
	SomeWorkflow3(ctx context.Context, req *SomeWorkflow3Request, opts ...*SomeWorkflow3Options) error
	// SomeWorkflow3Async executes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow asynchronously
	SomeWorkflow3Async(ctx context.Context, req *SomeWorkflow3Request, opts ...*SomeWorkflow3Options) (SomeWorkflow3Run, error)
	// GetSomeWorkflow3 retrieves a handle to an existing mycompany.simple.Simple.SomeWorkflow3 workflow execution
	GetSomeWorkflow3(ctx context.Context, workflowID string, runID string) SomeWorkflow3Run
	/*
	   SomeSignal2 is a signal.
	*/
	SomeWorkflow3WithSomeSignal2(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) error
	/*
	   SomeSignal2 is a signal.
	*/
	SomeWorkflow3WithSomeSignal2Async(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) (SomeWorkflow3Run, error)
	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error
	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
	/*
	   SomeQuery1 queries some thing.
	*/
	SomeQuery1(ctx context.Context, workflowID string, runID string) (*SomeQuery1Response, error)
	/*
	   SomeQuery2 queries some thing.
	*/
	SomeQuery2(ctx context.Context, workflowID string, runID string, query *SomeQuery2Request) (*SomeQuery2Response, error)
	/*
	   SomeSignal1 is a signal.
	*/
	SomeSignal1(ctx context.Context, workflowID string, runID string) error
	/*
	   SomeSignal2 is a signal.
	*/
	SomeSignal2(ctx context.Context, workflowID string, runID string, signal *SomeSignal2Request) error
	/*
	   SomeUpdate1 updates a SomeWorkflow2
	*/
	SomeUpdate1(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error)
	/*
	   SomeUpdate1 updates a SomeWorkflow2
	*/
	SomeUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error)
}

// simpleClient implements a temporal client for a mycompany.simple.Simple service
type simpleClient struct {
	client client.Client
}

// NewSimpleClient initializes a new mycompany.simple.Simple client
func NewSimpleClient(c client.Client) SimpleClient {
	return &simpleClient{client: c}
}

// NewSimpleClientWithOptions initializes a new Simple client with the given options
func NewSimpleClientWithOptions(c client.Client, opts client.Options) (SimpleClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	return &simpleClient{client: c}, nil
}

// SomeWorkflow1 executes a mycompany.simple.Simple.SomeWorkflow1 workflow and blocks until error or response received
func (c *simpleClient) SomeWorkflow1(ctx context.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1Options) (*SomeWorkflow1Response, error) {
	run, err := c.SomeWorkflow1Async(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow1Async starts a(n) mycompany.simple.Simple.SomeWorkflow1 workflow
func (c *simpleClient) SomeWorkflow1Async(ctx context.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1Options) (SomeWorkflow1Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow1IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, SomeWorkflow1WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow1Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow1 fetches an existing mycompany.simple.Simple.SomeWorkflow1 execution
func (c *simpleClient) GetSomeWorkflow1(ctx context.Context, workflowID string, runID string) SomeWorkflow1Run {
	return &someWorkflow1Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeWorkflow2 executes a mycompany.simple.Simple.SomeWorkflow2 workflow and blocks until error or response received
func (c *simpleClient) SomeWorkflow2(ctx context.Context, options ...*SomeWorkflow2Options) error {
	run, err := c.SomeWorkflow2Async(ctx, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2Async starts a(n) mycompany.simple.Simple.SomeWorkflow2 workflow
func (c *simpleClient) SomeWorkflow2Async(ctx context.Context, options ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, SomeWorkflow2WorkflowName)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow2Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow2 fetches an existing mycompany.simple.Simple.SomeWorkflow2 execution
func (c *simpleClient) GetSomeWorkflow2(ctx context.Context, workflowID string, runID string) SomeWorkflow2Run {
	return &someWorkflow2Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeWorkflow2WithSomeSignal1 starts a(n) mycompany.simple.Simple.SomeWorkflow2 workflow and sends a(n) mycompany.simple.Simple.SomeSignal1 signal in a transaction
func (c *simpleClient) SomeWorkflow2WithSomeSignal1(ctx context.Context, options ...*SomeWorkflow2Options) error {
	run, err := c.SomeWorkflow2WithSomeSignal1Async(ctx, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2WithSomeSignal1Async starts a(n) mycompany.simple.Simple.SomeWorkflow2 workflow and sends a(n) mycompany.simple.Simple.SomeSignal1 signal in a transaction
func (c *simpleClient) SomeWorkflow2WithSomeSignal1Async(ctx context.Context, options ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SomeSignal1SignalName, nil, *opts, SomeWorkflow2WorkflowName)
	if run == nil || err != nil {
		return nil, err
	}
	return &someWorkflow2Run{
		client: c,
		run:    run,
	}, nil
}

// SomeWorkflow3 executes a mycompany.simple.Simple.SomeWorkflow3 workflow and blocks until error or response received
func (c *simpleClient) SomeWorkflow3(ctx context.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3Options) error {
	run, err := c.SomeWorkflow3Async(ctx, req, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3Async starts a(n) mycompany.simple.Simple.SomeWorkflow3 workflow
func (c *simpleClient) SomeWorkflow3Async(ctx context.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "my-task-queue-2"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow3IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(2)}
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, SomeWorkflow3WorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &someWorkflow3Run{
		client: c,
		run:    run,
	}, nil
}

// GetSomeWorkflow3 fetches an existing mycompany.simple.Simple.SomeWorkflow3 execution
func (c *simpleClient) GetSomeWorkflow3(ctx context.Context, workflowID string, runID string) SomeWorkflow3Run {
	return &someWorkflow3Run{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// SomeWorkflow3WithSomeSignal2 starts a(n) mycompany.simple.Simple.SomeWorkflow3 workflow and sends a(n) mycompany.simple.Simple.SomeSignal2 signal in a transaction
func (c *simpleClient) SomeWorkflow3WithSomeSignal2(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, options ...*SomeWorkflow3Options) error {
	run, err := c.SomeWorkflow3WithSomeSignal2Async(ctx, req, signal, options...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3WithSomeSignal2Async starts a(n) mycompany.simple.Simple.SomeWorkflow3 workflow and sends a(n) mycompany.simple.Simple.SomeSignal2 signal in a transaction
func (c *simpleClient) SomeWorkflow3WithSomeSignal2Async(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, options ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "my-task-queue-2"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow3IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(2)}
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	run, err := c.client.SignalWithStartWorkflow(ctx, opts.ID, SomeSignal2SignalName, signal, *opts, SomeWorkflow3WorkflowName, req)
	if run == nil || err != nil {
		return nil, err
	}
	return &someWorkflow3Run{
		client: c,
		run:    run,
	}, nil
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *simpleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *simpleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// SomeQuery1 sends a(n) mycompany.simple.Simple.SomeQuery1 query to an existing workflow
func (c *simpleClient) SomeQuery1(ctx context.Context, workflowID string, runID string) (*SomeQuery1Response, error) {
	var resp SomeQuery1Response
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SomeQuery1QueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeQuery2 sends a(n) mycompany.simple.Simple.SomeQuery2 query to an existing workflow
func (c *simpleClient) SomeQuery2(ctx context.Context, workflowID string, runID string, query *SomeQuery2Request) (*SomeQuery2Response, error) {
	var resp SomeQuery2Response
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, SomeQuery2QueryName, query); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal to an existing workflow
func (c *simpleClient) SomeSignal1(ctx context.Context, workflowID string, runID string) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeSignal1SignalName, nil)
}

// SomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal to an existing workflow
func (c *simpleClient) SomeSignal2(ctx context.Context, workflowID string, runID string, signal *SomeSignal2Request) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, SomeSignal2SignalName, signal)
}

// SomeUpdate1 sends a(n) mycompany.simple.Simple.SomeUpdate1 update to an existing workflow
func (c *simpleClient) SomeUpdate1(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	options := NewSomeUpdate1Options()
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0]
	}
	options.opts.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	handle, err := c.SomeUpdate1Async(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeUpdate1Async sends a(n) mycompany.simple.Simple.SomeUpdate1 update to an existing workflow
func (c *simpleClient) SomeUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	options := &client.UpdateWorkflowWithOptionsRequest{}
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0].opts
	}
	options.Args = []any{req}
	options.RunID = runID
	options.UpdateName = SomeUpdate1UpdateName
	options.WorkflowID = workflowID
	if options.UpdateID == "" {
		id, err := expression.EvalExpression(SomeUpdate1IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating %s id expression: %w", SomeUpdate1UpdateName, err)
		}
		options.UpdateID = id
	}
	if options.WaitPolicy.GetLifecycleStage() == v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED {
		options.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	}
	handle, err := c.client.UpdateWorkflowWithOptions(ctx, options)
	if err != nil {
		return nil, err
	}
	return &someUpdate1Handle{client: c, handle: handle}, nil
}

// SomeWorkflow1Options provides configuration for a mycompany.simple.Simple.SomeWorkflow1 workflow operation
type SomeWorkflow1Options struct {
	opts *client.StartWorkflowOptions
}

// NewSomeWorkflow1Options initializes a new SomeWorkflow1Options value
func NewSomeWorkflow1Options() *SomeWorkflow1Options {
	return &SomeWorkflow1Options{}
}

// WithStartWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SomeWorkflow1Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow1Options {
	opts.opts = &options
	return opts
}

// SomeWorkflow1Run describes a(n) mycompany.simple.Simple.SomeWorkflow1 workflow run
type SomeWorkflow1Run interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeWorkflow1Response, error)
	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error
	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
	/*
	   SomeQuery1 queries some thing.
	*/
	SomeQuery1(ctx context.Context) (*SomeQuery1Response, error)
	/*
	   SomeQuery2 queries some thing.
	*/
	SomeQuery2(ctx context.Context, req *SomeQuery2Request) (*SomeQuery2Response, error)
	/*
	   SomeSignal1 is a signal.
	*/
	SomeSignal1(ctx context.Context) error
	/*
	   SomeSignal2 is a signal.
	*/
	SomeSignal2(ctx context.Context, req *SomeSignal2Request) error
}

// someWorkflow1Run provides an internal implementation of a(n) SomeWorkflow1RunRun
type someWorkflow1Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow1Run) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *someWorkflow1Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow1Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow1Run) Get(ctx context.Context) (*SomeWorkflow1Response, error) {
	var resp SomeWorkflow1Response
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow1Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeQuery1 executes a(n) mycompany.simple.Simple.SomeQuery1 query
func (r *someWorkflow1Run) SomeQuery1(ctx context.Context) (*SomeQuery1Response, error) {
	return r.client.SomeQuery1(ctx, r.ID(), "")
}

// SomeQuery2 executes a(n) mycompany.simple.Simple.SomeQuery2 query
func (r *someWorkflow1Run) SomeQuery2(ctx context.Context, req *SomeQuery2Request) (*SomeQuery2Response, error) {
	return r.client.SomeQuery2(ctx, r.ID(), "", req)
}

// SomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal
func (r *someWorkflow1Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), "")
}

// SomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal
func (r *someWorkflow1Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), "", req)
}

// SomeWorkflow2Options provides configuration for a mycompany.simple.Simple.SomeWorkflow2 workflow operation
type SomeWorkflow2Options struct {
	opts *client.StartWorkflowOptions
}

// NewSomeWorkflow2Options initializes a new SomeWorkflow2Options value
func NewSomeWorkflow2Options() *SomeWorkflow2Options {
	return &SomeWorkflow2Options{}
}

// WithStartWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SomeWorkflow2Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow2Options {
	opts.opts = &options
	return opts
}

// SomeWorkflow2Run describes a(n) mycompany.simple.Simple.SomeWorkflow2 workflow run
type SomeWorkflow2Run interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error
	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error
	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
	/*
	   SomeSignal1 is a signal.
	*/
	SomeSignal1(ctx context.Context) error
	/*
	   SomeUpdate1 updates a SomeWorkflow2
	*/
	SomeUpdate1(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error)
	// SomeUpdate1Async sends a(n) mycompany.simple.Simple.SomeUpdate1 update to the workflow
	SomeUpdate1Async(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error)
}

// someWorkflow2Run provides an internal implementation of a(n) SomeWorkflow2RunRun
type someWorkflow2Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow2Run) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *someWorkflow2Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow2Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow2Run) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow2Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal1 sends a(n) mycompany.simple.Simple.SomeSignal1 signal
func (r *someWorkflow2Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), "")
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update
func (r *someWorkflow2Run) SomeUpdate1(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	return r.client.SomeUpdate1(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeUpdate1Async sends a(n) mycompany.simple.Simple.SomeUpdate1 update to the workflow
func (r *someWorkflow2Run) SomeUpdate1Async(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	return r.client.SomeUpdate1Async(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeWorkflow3Options provides configuration for a mycompany.simple.Simple.SomeWorkflow3 workflow operation
type SomeWorkflow3Options struct {
	opts *client.StartWorkflowOptions
}

// NewSomeWorkflow3Options initializes a new SomeWorkflow3Options value
func NewSomeWorkflow3Options() *SomeWorkflow3Options {
	return &SomeWorkflow3Options{}
}

// WithStartWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SomeWorkflow3Options) WithStartWorkflowOptions(options client.StartWorkflowOptions) *SomeWorkflow3Options {
	opts.opts = &options
	return opts
}

// SomeWorkflow3Run describes a(n) mycompany.simple.Simple.SomeWorkflow3 workflow run
type SomeWorkflow3Run interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) error
	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error
	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
	/*
	   SomeSignal2 is a signal.
	*/
	SomeSignal2(ctx context.Context, req *SomeSignal2Request) error
}

// someWorkflow3Run provides an internal implementation of a(n) SomeWorkflow3RunRun
type someWorkflow3Run struct {
	client *simpleClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *someWorkflow3Run) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *someWorkflow3Run) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *someWorkflow3Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *someWorkflow3Run) Get(ctx context.Context) error {
	return r.run.Get(ctx, nil)
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *someWorkflow3Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal2 sends a(n) mycompany.simple.Simple.SomeSignal2 signal
func (r *someWorkflow3Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), "", req)
}

// SomeUpdate1Handle describes a(n) mycompany.simple.Simple.SomeUpdate1 update handle
type SomeUpdate1Handle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*SomeUpdate1Response, error)
}

// someUpdate1Handle provides an internal implementation of a(n) SomeUpdate1Handle
type someUpdate1Handle struct {
	client *simpleClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *someUpdate1Handle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *someUpdate1Handle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *someUpdate1Handle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *someUpdate1Handle) Get(ctx context.Context) (*SomeUpdate1Response, error) {
	var resp SomeUpdate1Response
	if err := h.handle.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// SomeUpdate1Options provides configuration for a mycompany.simple.Simple.SomeUpdate1 update operation
type SomeUpdate1Options struct {
	opts *client.UpdateWorkflowWithOptionsRequest
}

// NewSomeUpdate1Options initializes a new SomeUpdate1Options value
func NewSomeUpdate1Options() *SomeUpdate1Options {
	return &SomeUpdate1Options{opts: &client.UpdateWorkflowWithOptionsRequest{}}
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowWithOptionsRequest
func (opts *SomeUpdate1Options) WithUpdateWorkflowOptions(options client.UpdateWorkflowWithOptionsRequest) *SomeUpdate1Options {
	opts.opts = &options
	return opts
}

// Reference to generated workflow functions
var (
	// SomeWorkflow1 does some workflow thing.
	SomeWorkflow1Function func(workflow.Context, *SomeWorkflow1Request) (*SomeWorkflow1Response, error)
	// SomeWorkflow2 does some workflow thing.
	SomeWorkflow2Function func(workflow.Context) error
	// SomeWorkflow3 does some workflow thing.
	SomeWorkflow3Function func(workflow.Context, *SomeWorkflow3Request) error
)

// SimpleWorkflows provides methods for initializing new mycompany.simple.Simple workflow values
type SimpleWorkflows interface {
	SomeWorkflow1(ctx workflow.Context, input *SomeWorkflow1Input) (SomeWorkflow1Workflow, error)
	SomeWorkflow2(ctx workflow.Context, input *SomeWorkflow2Input) (SomeWorkflow2Workflow, error)
	SomeWorkflow3(ctx workflow.Context, input *SomeWorkflow3Input) (SomeWorkflow3Workflow, error)
}

// SomeWorkflow1 does some workflow thing.
// SomeWorkflow2 does some workflow thing.
// SomeWorkflow3 does some workflow thing.
// RegisterSimpleWorkflows registers mycompany.simple.Simple workflows with the given worker
func RegisterSimpleWorkflows(r worker.WorkflowRegistry, workflows SimpleWorkflows) {
	RegisterSomeWorkflow1Workflow(r, workflows.SomeWorkflow1)
	RegisterSomeWorkflow2Workflow(r, workflows.SomeWorkflow2)
	RegisterSomeWorkflow3Workflow(r, workflows.SomeWorkflow3)
}

// RegisterSomeWorkflow1Workflow registers a mycompany.simple.Simple.SomeWorkflow1 workflow with the given worker
func RegisterSomeWorkflow1Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow1Input) (SomeWorkflow1Workflow, error)) {
	SomeWorkflow1Function = buildSomeWorkflow1(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow1Function, workflow.RegisterOptions{Name: SomeWorkflow1WorkflowName})
}

// buildSomeWorkflow1 converts a SomeWorkflow1 workflow struct into a valid workflow function
func buildSomeWorkflow1(ctor func(workflow.Context, *SomeWorkflow1Input) (SomeWorkflow1Workflow, error)) func(workflow.Context, *SomeWorkflow1Request) (*SomeWorkflow1Response, error) {
	return func(ctx workflow.Context, req *SomeWorkflow1Request) (*SomeWorkflow1Response, error) {
		input := &SomeWorkflow1Input{
			Req: req,
			SomeSignal1: &SomeSignal1Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal1SignalName),
			},
			SomeSignal2: &SomeSignal2Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal2SignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		if err := workflow.SetQueryHandler(ctx, SomeQuery1QueryName, wf.SomeQuery1); err != nil {
			return nil, err
		}
		if err := workflow.SetQueryHandler(ctx, SomeQuery2QueryName, wf.SomeQuery2); err != nil {
			return nil, err
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow1Input describes the input to a(n) mycompany.simple.Simple.SomeWorkflow1 workflow constructor
type SomeWorkflow1Input struct {
	Req         *SomeWorkflow1Request
	SomeSignal1 *SomeSignal1Signal
	SomeSignal2 *SomeSignal2Signal
}

// SomeWorkflow1 does some workflow thing.
type SomeWorkflow1Workflow interface {
	// SomeWorkflow1 does some workflow thing.
	Execute(ctx workflow.Context) (*SomeWorkflow1Response, error)
	// SomeQuery1 queries some thing.
	SomeQuery1() (*SomeQuery1Response, error)
	// SomeQuery2 queries some thing.
	SomeQuery2(*SomeQuery2Request) (*SomeQuery2Response, error)
}

// SomeWorkflow1Child executes a child mycompany.simple.Simple.SomeWorkflow1 workflow
func SomeWorkflow1Child(ctx workflow.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1ChildOptions) (*SomeWorkflow1Response, error) {
	childRun, err := SomeWorkflow1ChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow1ChildAsync executes a child mycompany.simple.Simple.SomeWorkflow1 workflow
func SomeWorkflow1ChildAsync(ctx workflow.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1ChildOptions) (*SomeWorkflow1ChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(SomeWorkflow1IDExpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &SomeWorkflow1ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow1WorkflowName, req)}, nil
}

// SomeWorkflow1ChildOptions provides configuration for a mycompany.simple.Simple.SomeWorkflow1 workflow operation
type SomeWorkflow1ChildOptions struct {
	opts *workflow.ChildWorkflowOptions
}

// NewSomeWorkflow1ChildOptions initializes a new SomeWorkflow1ChildOptions value
func NewSomeWorkflow1ChildOptions() *SomeWorkflow1ChildOptions {
	return &SomeWorkflow1ChildOptions{}
}

// WithChildWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SomeWorkflow1ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow1ChildOptions {
	opts.opts = &options
	return opts
}

// SomeWorkflow1ChildRun describes a child mycompany.simple.Simple.SomeWorkflow1 workflow run
type SomeWorkflow1ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow1ChildRun) Get(ctx workflow.Context) (*SomeWorkflow1Response, error) {
	var resp SomeWorkflow1Response
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow1ChildRun) Select(sel workflow.Selector, fn func(SomeWorkflow1ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow1ChildRun) SelectStart(sel workflow.Selector, fn func(SomeWorkflow1ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow1ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal1 sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal1(ctx workflow.Context) error {
	return r.SomeSignal1Async(ctx).Get(ctx, nil)
}

// SomeSignal1Async sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal1Async(ctx workflow.Context) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal1SignalName, nil)
}

// SomeSignal2 sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal2(ctx workflow.Context, input *SomeSignal2Request) error {
	return r.SomeSignal2Async(ctx, input).Get(ctx, nil)
}

// SomeSignal2Async sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow1ChildRun) SomeSignal2Async(ctx workflow.Context, input *SomeSignal2Request) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal2SignalName, input)
}

// RegisterSomeWorkflow2Workflow registers a mycompany.simple.Simple.SomeWorkflow2 workflow with the given worker
func RegisterSomeWorkflow2Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow2Input) (SomeWorkflow2Workflow, error)) {
	SomeWorkflow2Function = buildSomeWorkflow2(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow2Function, workflow.RegisterOptions{Name: SomeWorkflow2WorkflowName})
}

// buildSomeWorkflow2 converts a SomeWorkflow2 workflow struct into a valid workflow function
func buildSomeWorkflow2(ctor func(workflow.Context, *SomeWorkflow2Input) (SomeWorkflow2Workflow, error)) func(workflow.Context) error {
	return func(ctx workflow.Context) error {
		input := &SomeWorkflow2Input{
			SomeSignal1: &SomeSignal1Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal1SignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		{
			opts := workflow.UpdateHandlerOptions{Validator: wf.ValidateSomeUpdate1}
			if err := workflow.SetUpdateHandlerWithOptions(ctx, SomeUpdate1UpdateName, wf.SomeUpdate1, opts); err != nil {
				return err
			}
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow2Input describes the input to a(n) mycompany.simple.Simple.SomeWorkflow2 workflow constructor
type SomeWorkflow2Input struct {
	SomeSignal1 *SomeSignal1Signal
}

// SomeWorkflow2 does some workflow thing.
type SomeWorkflow2Workflow interface {
	// SomeWorkflow2 does some workflow thing.
	Execute(ctx workflow.Context) error
	// ValidateSomeUpdate1 validates a(n) mycompany.simple.Simple.SomeUpdate1 update
	ValidateSomeUpdate1(workflow.Context, *SomeUpdate1Request) error
	// SomeUpdate1 updates a SomeWorkflow2
	SomeUpdate1(workflow.Context, *SomeUpdate1Request) (*SomeUpdate1Response, error)
}

// SomeWorkflow2Child executes a child mycompany.simple.Simple.SomeWorkflow2 workflow
func SomeWorkflow2Child(ctx workflow.Context, options ...*SomeWorkflow2ChildOptions) error {
	childRun, err := SomeWorkflow2ChildAsync(ctx, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow2ChildAsync executes a child mycompany.simple.Simple.SomeWorkflow2 workflow
func SomeWorkflow2ChildAsync(ctx workflow.Context, options ...*SomeWorkflow2ChildOptions) (*SomeWorkflow2ChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &SomeWorkflow2ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow2WorkflowName, nil)}, nil
}

// SomeWorkflow2ChildOptions provides configuration for a mycompany.simple.Simple.SomeWorkflow2 workflow operation
type SomeWorkflow2ChildOptions struct {
	opts *workflow.ChildWorkflowOptions
}

// NewSomeWorkflow2ChildOptions initializes a new SomeWorkflow2ChildOptions value
func NewSomeWorkflow2ChildOptions() *SomeWorkflow2ChildOptions {
	return &SomeWorkflow2ChildOptions{}
}

// WithChildWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SomeWorkflow2ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow2ChildOptions {
	opts.opts = &options
	return opts
}

// SomeWorkflow2ChildRun describes a child mycompany.simple.Simple.SomeWorkflow2 workflow run
type SomeWorkflow2ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow2ChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow2ChildRun) Select(sel workflow.Selector, fn func(SomeWorkflow2ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow2ChildRun) SelectStart(sel workflow.Selector, fn func(SomeWorkflow2ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow2ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal1 sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow2ChildRun) SomeSignal1(ctx workflow.Context) error {
	return r.SomeSignal1Async(ctx).Get(ctx, nil)
}

// SomeSignal1Async sends a(n) "mycompany.simple.Simple.SomeSignal1" signal request to the child workflow
func (r *SomeWorkflow2ChildRun) SomeSignal1Async(ctx workflow.Context) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal1SignalName, nil)
}

// RegisterSomeWorkflow3Workflow registers a mycompany.simple.Simple.SomeWorkflow3 workflow with the given worker
func RegisterSomeWorkflow3Workflow(r worker.WorkflowRegistry, wf func(workflow.Context, *SomeWorkflow3Input) (SomeWorkflow3Workflow, error)) {
	SomeWorkflow3Function = buildSomeWorkflow3(wf)
	r.RegisterWorkflowWithOptions(SomeWorkflow3Function, workflow.RegisterOptions{Name: SomeWorkflow3WorkflowName})
}

// buildSomeWorkflow3 converts a SomeWorkflow3 workflow struct into a valid workflow function
func buildSomeWorkflow3(ctor func(workflow.Context, *SomeWorkflow3Input) (SomeWorkflow3Workflow, error)) func(workflow.Context, *SomeWorkflow3Request) error {
	return func(ctx workflow.Context, req *SomeWorkflow3Request) error {
		input := &SomeWorkflow3Input{
			Req: req,
			SomeSignal2: &SomeSignal2Signal{
				Channel: workflow.GetSignalChannel(ctx, SomeSignal2SignalName),
			},
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return err
		}
		return wf.Execute(ctx)
	}
}

// SomeWorkflow3Input describes the input to a(n) mycompany.simple.Simple.SomeWorkflow3 workflow constructor
type SomeWorkflow3Input struct {
	Req         *SomeWorkflow3Request
	SomeSignal2 *SomeSignal2Signal
}

// SomeWorkflow3 does some workflow thing.
type SomeWorkflow3Workflow interface {
	// SomeWorkflow3 does some workflow thing.
	Execute(ctx workflow.Context) error
}

// SomeWorkflow3Child executes a child mycompany.simple.Simple.SomeWorkflow3 workflow
func SomeWorkflow3Child(ctx workflow.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3ChildOptions) error {
	childRun, err := SomeWorkflow3ChildAsync(ctx, req, options...)
	if err != nil {
		return err
	}
	return childRun.Get(ctx)
}

// SomeWorkflow3ChildAsync executes a child mycompany.simple.Simple.SomeWorkflow3 workflow
func SomeWorkflow3ChildAsync(ctx workflow.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3ChildOptions) (*SomeWorkflow3ChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "my-task-queue-2"
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(SomeWorkflow3IDExpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(2)}
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &SomeWorkflow3ChildRun{Future: workflow.ExecuteChildWorkflow(ctx, SomeWorkflow3WorkflowName, req)}, nil
}

// SomeWorkflow3ChildOptions provides configuration for a mycompany.simple.Simple.SomeWorkflow3 workflow operation
type SomeWorkflow3ChildOptions struct {
	opts *workflow.ChildWorkflowOptions
}

// NewSomeWorkflow3ChildOptions initializes a new SomeWorkflow3ChildOptions value
func NewSomeWorkflow3ChildOptions() *SomeWorkflow3ChildOptions {
	return &SomeWorkflow3ChildOptions{}
}

// WithChildWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *SomeWorkflow3ChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *SomeWorkflow3ChildOptions {
	opts.opts = &options
	return opts
}

// SomeWorkflow3ChildRun describes a child mycompany.simple.Simple.SomeWorkflow3 workflow run
type SomeWorkflow3ChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *SomeWorkflow3ChildRun) Get(ctx workflow.Context) error {
	if err := r.Future.Get(ctx, nil); err != nil {
		return err
	}
	return nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *SomeWorkflow3ChildRun) Select(sel workflow.Selector, fn func(SomeWorkflow3ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *SomeWorkflow3ChildRun) SelectStart(sel workflow.Selector, fn func(SomeWorkflow3ChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *SomeWorkflow3ChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// SomeSignal2 sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow3ChildRun) SomeSignal2(ctx workflow.Context, input *SomeSignal2Request) error {
	return r.SomeSignal2Async(ctx, input).Get(ctx, nil)
}

// SomeSignal2Async sends a(n) "mycompany.simple.Simple.SomeSignal2" signal request to the child workflow
func (r *SomeWorkflow3ChildRun) SomeSignal2Async(ctx workflow.Context, input *SomeSignal2Request) workflow.Future {
	return r.Future.SignalChildWorkflow(ctx, SomeSignal2SignalName, input)
}

// SomeSignal1Signal describes a(n) mycompany.simple.Simple.SomeSignal1 signal
type SomeSignal1Signal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a(n) mycompany.simple.Simple.SomeSignal1 signal is received
func (s *SomeSignal1Signal) Receive(ctx workflow.Context) bool {
	more := s.Channel.Receive(ctx, nil)
	return more
}

// ReceiveAsync checks for a mycompany.simple.Simple.SomeSignal1 signal without blocking
func (s *SomeSignal1Signal) ReceiveAsync() bool {
	return s.Channel.ReceiveAsync(nil)
}

// Select checks for a(n) mycompany.simple.Simple.SomeSignal1 signal without blocking
func (s *SomeSignal1Signal) Select(sel workflow.Selector, fn func()) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		s.ReceiveAsync()
		if fn != nil {
			fn()
		}
	})
}

// SomeSignal1External sends a(n) mycompany.simple.Simple.SomeSignal1 signal to an existing workflow
func SomeSignal1External(ctx workflow.Context, workflowID string, runID string) error {
	return SomeSignal1ExternalAsync(ctx, workflowID, runID).Get(ctx, nil)
}

// SomeSignal1ExternalAsync sends a(n) mycompany.simple.Simple.SomeSignal1 signal to an existing workflow
func SomeSignal1ExternalAsync(ctx workflow.Context, workflowID string, runID string) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeSignal1SignalName, nil)
}

// SomeSignal2Signal describes a(n) mycompany.simple.Simple.SomeSignal2 signal
type SomeSignal2Signal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a(n) mycompany.simple.Simple.SomeSignal2 signal is received
func (s *SomeSignal2Signal) Receive(ctx workflow.Context) (*SomeSignal2Request, bool) {
	var resp SomeSignal2Request
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Simple.SomeSignal2 signal without blocking
func (s *SomeSignal2Signal) ReceiveAsync() *SomeSignal2Request {
	var resp SomeSignal2Request
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a(n) mycompany.simple.Simple.SomeSignal2 signal without blocking
func (s *SomeSignal2Signal) Select(sel workflow.Selector, fn func(*SomeSignal2Request)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// SomeSignal2External sends a(n) mycompany.simple.Simple.SomeSignal2 signal to an existing workflow
func SomeSignal2External(ctx workflow.Context, workflowID string, runID string, req *SomeSignal2Request) error {
	return SomeSignal2ExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// SomeSignal2ExternalAsync sends a(n) mycompany.simple.Simple.SomeSignal2 signal to an existing workflow
func SomeSignal2ExternalAsync(ctx workflow.Context, workflowID string, runID string, req *SomeSignal2Request) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, SomeSignal2SignalName, req)
}

// SimpleActivities describes available worker activites
type SimpleActivities interface {
	// SomeActivity1 does some activity thing.
	SomeActivity1(ctx context.Context) error
	// SomeActivity2 does some activity thing.
	SomeActivity2(ctx context.Context, req *SomeActivity2Request) error
	// SomeActivity3 does some activity thing.
	SomeActivity3(ctx context.Context, req *SomeActivity3Request) (*SomeActivity3Response, error)
}

// RegisterSimpleActivities registers activities with a worker
func RegisterSimpleActivities(r worker.ActivityRegistry, activities SimpleActivities) {
	RegisterSomeActivity1Activity(r, activities.SomeActivity1)
	RegisterSomeActivity2Activity(r, activities.SomeActivity2)
	RegisterSomeActivity3Activity(r, activities.SomeActivity3)
}

// RegisterSomeActivity1Activity registers a mycompany.simple.SomeActivity1 activity
func RegisterSomeActivity1Activity(r worker.ActivityRegistry, fn func(context.Context) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity1ActivityName,
	})
}

// SomeActivity1Future describes a(n) mycompany.simple.SomeActivity1 activity execution
type SomeActivity1Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity1Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity1Future) Select(sel workflow.Selector, fn func(*SomeActivity1Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity1 does some activity thing.
func SomeActivity1(ctx workflow.Context, options ...*SomeActivity1ActivityOptions) error {
	var opts *SomeActivity1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity1ActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = SomeActivity1ActivityName
	future := &SomeActivity1Future{Future: workflow.ExecuteActivity(ctx, activity)}
	return future.Get(ctx)
}

// SomeActivity1 does some activity thing. (asynchronously)
func SomeActivity1Async(ctx workflow.Context, options ...*SomeActivity1ActivityOptions) *SomeActivity1Future {
	var opts *SomeActivity1ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity1ActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = SomeActivity1ActivityName
	future := &SomeActivity1Future{Future: workflow.ExecuteActivity(ctx, activity)}
	return future
}

// SomeActivity1 does some activity thing. (locally)
func SomeActivity1Local(ctx workflow.Context, options ...*SomeActivity1LocalActivityOptions) error {
	var opts *SomeActivity1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity1LocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = SomeActivity1ActivityName
	}
	future := &SomeActivity1Future{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future.Get(ctx)
}

// SomeActivity1 does some activity thing. (asynchronously, locally)
func SomeActivity1LocalAsync(ctx workflow.Context, options ...*SomeActivity1LocalActivityOptions) *SomeActivity1Future {
	var opts *SomeActivity1LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity1LocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = SomeActivity1ActivityName
	}
	future := &SomeActivity1Future{Future: workflow.ExecuteLocalActivity(ctx, activity)}
	return future
}

// SomeActivity1LocalActivityOptions provides configuration for a local mycompany.simple.SomeActivity1 activity
type SomeActivity1LocalActivityOptions struct {
	fn   func(context.Context) error
	opts *workflow.LocalActivityOptions
}

// NewSomeActivity1LocalActivityOptions sets default LocalActivityOptions
func NewSomeActivity1LocalActivityOptions() *SomeActivity1LocalActivityOptions {
	return &SomeActivity1LocalActivityOptions{}
}

// Local provides a local mycompany.simple.SomeActivity1 activity implementation
func (opts *SomeActivity1LocalActivityOptions) Local(fn func(context.Context) error) *SomeActivity1LocalActivityOptions {
	opts.fn = fn
	return opts
}

// WithLocalActivityOptions sets default LocalActivityOptions
func (opts *SomeActivity1LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity1LocalActivityOptions {
	opts.opts = &options
	return opts
}

// SomeActivity1ActivityOptions provides configuration for a(n) mycompany.simple.SomeActivity1 activity
type SomeActivity1ActivityOptions struct {
	opts *workflow.ActivityOptions
}

// NewSomeActivity1ActivityOptions sets default ActivityOptions
func NewSomeActivity1ActivityOptions() *SomeActivity1ActivityOptions {
	return &SomeActivity1ActivityOptions{}
}

// WithActivityOptions sets default ActivityOptions
func (opts *SomeActivity1ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity1ActivityOptions {
	opts.opts = &options
	return opts
}

// RegisterSomeActivity2Activity registers a mycompany.simple.Simple.SomeActivity2 activity
func RegisterSomeActivity2Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeActivity2Request) error) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity2ActivityName,
	})
}

// SomeActivity2Future describes a(n) mycompany.simple.Simple.SomeActivity2 activity execution
type SomeActivity2Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity2Future) Get(ctx workflow.Context) error {
	return f.Future.Get(ctx, nil)
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity2Future) Select(sel workflow.Selector, fn func(*SomeActivity2Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity2 does some activity thing.
func SomeActivity2(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2ActivityOptions) error {
	var opts *SomeActivity2ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity2ActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumInterval: 30000000000}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = SomeActivity2ActivityName
	future := &SomeActivity2Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// SomeActivity2 does some activity thing. (asynchronously)
func SomeActivity2Async(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2ActivityOptions) *SomeActivity2Future {
	var opts *SomeActivity2ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity2ActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumInterval: 30000000000}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = SomeActivity2ActivityName
	future := &SomeActivity2Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeActivity2 does some activity thing. (locally)
func SomeActivity2Local(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2LocalActivityOptions) error {
	var opts *SomeActivity2LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity2LocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumInterval: 30000000000}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = SomeActivity2ActivityName
	}
	future := &SomeActivity2Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// SomeActivity2 does some activity thing. (asynchronously, locally)
func SomeActivity2LocalAsync(ctx workflow.Context, req *SomeActivity2Request, options ...*SomeActivity2LocalActivityOptions) *SomeActivity2Future {
	var opts *SomeActivity2LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity2LocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumInterval: 30000000000}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = SomeActivity2ActivityName
	}
	future := &SomeActivity2Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeActivity2LocalActivityOptions provides configuration for a local mycompany.simple.Simple.SomeActivity2 activity
type SomeActivity2LocalActivityOptions struct {
	fn   func(context.Context, *SomeActivity2Request) error
	opts *workflow.LocalActivityOptions
}

// NewSomeActivity2LocalActivityOptions sets default LocalActivityOptions
func NewSomeActivity2LocalActivityOptions() *SomeActivity2LocalActivityOptions {
	return &SomeActivity2LocalActivityOptions{}
}

// Local provides a local mycompany.simple.Simple.SomeActivity2 activity implementation
func (opts *SomeActivity2LocalActivityOptions) Local(fn func(context.Context, *SomeActivity2Request) error) *SomeActivity2LocalActivityOptions {
	opts.fn = fn
	return opts
}

// WithLocalActivityOptions sets default LocalActivityOptions
func (opts *SomeActivity2LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity2LocalActivityOptions {
	opts.opts = &options
	return opts
}

// SomeActivity2ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity2 activity
type SomeActivity2ActivityOptions struct {
	opts *workflow.ActivityOptions
}

// NewSomeActivity2ActivityOptions sets default ActivityOptions
func NewSomeActivity2ActivityOptions() *SomeActivity2ActivityOptions {
	return &SomeActivity2ActivityOptions{}
}

// WithActivityOptions sets default ActivityOptions
func (opts *SomeActivity2ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity2ActivityOptions {
	opts.opts = &options
	return opts
}

// RegisterSomeActivity3Activity registers a mycompany.simple.Simple.SomeActivity3 activity
func RegisterSomeActivity3Activity(r worker.ActivityRegistry, fn func(context.Context, *SomeActivity3Request) (*SomeActivity3Response, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: SomeActivity3ActivityName,
	})
}

// SomeActivity3Future describes a(n) mycompany.simple.Simple.SomeActivity3 activity execution
type SomeActivity3Future struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *SomeActivity3Future) Get(ctx workflow.Context) (*SomeActivity3Response, error) {
	var resp SomeActivity3Response
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *SomeActivity3Future) Select(sel workflow.Selector, fn func(*SomeActivity3Future)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// SomeActivity3 does some activity thing.
func SomeActivity3(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3ActivityOptions) (*SomeActivity3Response, error) {
	var opts *SomeActivity3ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity3ActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = SomeActivity3ActivityName
	future := &SomeActivity3Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// SomeActivity3 does some activity thing. (asynchronously)
func SomeActivity3Async(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3ActivityOptions) *SomeActivity3Future {
	var opts *SomeActivity3ActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity3ActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = SomeActivity3ActivityName
	future := &SomeActivity3Future{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// SomeActivity3 does some activity thing. (locally)
func SomeActivity3Local(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3LocalActivityOptions) (*SomeActivity3Response, error) {
	var opts *SomeActivity3LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity3LocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = SomeActivity3ActivityName
	}
	future := &SomeActivity3Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// SomeActivity3 does some activity thing. (asynchronously, locally)
func SomeActivity3LocalAsync(ctx workflow.Context, req *SomeActivity3Request, options ...*SomeActivity3LocalActivityOptions) *SomeActivity3Future {
	var opts *SomeActivity3LocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewSomeActivity3LocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.RetryPolicy == nil {
		opts.opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(5)}
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 10000000000 // 10s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = SomeActivity3ActivityName
	}
	future := &SomeActivity3Future{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// SomeActivity3LocalActivityOptions provides configuration for a local mycompany.simple.Simple.SomeActivity3 activity
type SomeActivity3LocalActivityOptions struct {
	fn   func(context.Context, *SomeActivity3Request) (*SomeActivity3Response, error)
	opts *workflow.LocalActivityOptions
}

// NewSomeActivity3LocalActivityOptions sets default LocalActivityOptions
func NewSomeActivity3LocalActivityOptions() *SomeActivity3LocalActivityOptions {
	return &SomeActivity3LocalActivityOptions{}
}

// Local provides a local mycompany.simple.Simple.SomeActivity3 activity implementation
func (opts *SomeActivity3LocalActivityOptions) Local(fn func(context.Context, *SomeActivity3Request) (*SomeActivity3Response, error)) *SomeActivity3LocalActivityOptions {
	opts.fn = fn
	return opts
}

// WithLocalActivityOptions sets default LocalActivityOptions
func (opts *SomeActivity3LocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *SomeActivity3LocalActivityOptions {
	opts.opts = &options
	return opts
}

// SomeActivity3ActivityOptions provides configuration for a(n) mycompany.simple.Simple.SomeActivity3 activity
type SomeActivity3ActivityOptions struct {
	opts *workflow.ActivityOptions
}

// NewSomeActivity3ActivityOptions sets default ActivityOptions
func NewSomeActivity3ActivityOptions() *SomeActivity3ActivityOptions {
	return &SomeActivity3ActivityOptions{}
}

// WithActivityOptions sets default ActivityOptions
func (opts *SomeActivity3ActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *SomeActivity3ActivityOptions {
	opts.opts = &options
	return opts
}

// TestClient provides a testsuite-compatible Client
type TestSimpleClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows SimpleWorkflows
}

var _ SimpleClient = &TestSimpleClient{}

// NewTestSimpleClient initializes a new TestSimpleClient value
func NewTestSimpleClient(env *testsuite.TestWorkflowEnvironment, workflows SimpleWorkflows, activities SimpleActivities) *TestSimpleClient {
	RegisterSimpleWorkflows(env, workflows)
	if activities != nil {
		RegisterSimpleActivities(env, activities)
	}
	return &TestSimpleClient{env, workflows}
}

// SomeWorkflow1 executes a(n) SomeWorkflow1 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow1(ctx context.Context, req *SomeWorkflow1Request, opts ...*SomeWorkflow1Options) (*SomeWorkflow1Response, error) {
	run, err := c.SomeWorkflow1Async(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// SomeWorkflow1Async executes a(n) SomeWorkflow1 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow1Async(ctx context.Context, req *SomeWorkflow1Request, options ...*SomeWorkflow1Options) (SomeWorkflow1Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow1IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	return &testSomeWorkflow1Run{client: c, env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetSomeWorkflow1 is a noop
func (c *TestSimpleClient) GetSomeWorkflow1(ctx context.Context, workflowID string, runID string) SomeWorkflow1Run {
	return &testSomeWorkflow1Run{env: c.env, workflows: c.workflows}
}

// SomeWorkflow2 executes a(n) SomeWorkflow2 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow2(ctx context.Context, opts ...*SomeWorkflow2Options) error {
	run, err := c.SomeWorkflow2Async(ctx, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow2Async executes a(n) SomeWorkflow2 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow2Async(ctx context.Context, options ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = SimpleTaskQueue
	}
	return &testSomeWorkflow2Run{client: c, env: c.env, opts: opts, workflows: c.workflows}, nil
}

// GetSomeWorkflow2 is a noop
func (c *TestSimpleClient) GetSomeWorkflow2(ctx context.Context, workflowID string, runID string) SomeWorkflow2Run {
	return &testSomeWorkflow2Run{env: c.env, workflows: c.workflows}
}

// SomeWorkflow2WithSomeSignal1 sends a(n) SomeSignal1 signal to a(n) SomeWorkflow2 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow2WithSomeSignal1(ctx context.Context, opts ...*SomeWorkflow2Options) error {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SomeSignal1SignalName, nil)
	}, 0)
	return c.SomeWorkflow2(ctx, opts...)
}

// SomeWorkflow2WithSomeSignal1Async sends a(n) SomeSignal1 signal to a(n) SomeWorkflow2 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow2WithSomeSignal1Async(ctx context.Context, opts ...*SomeWorkflow2Options) (SomeWorkflow2Run, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.SomeSignal1(ctx, "", "")
	}, 0)
	return c.SomeWorkflow2Async(ctx, opts...)
}

// SomeWorkflow3 executes a(n) SomeWorkflow3 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow3(ctx context.Context, req *SomeWorkflow3Request, opts ...*SomeWorkflow3Options) error {
	run, err := c.SomeWorkflow3Async(ctx, req, opts...)
	if err != nil {
		return err
	}
	return run.Get(ctx)
}

// SomeWorkflow3Async executes a(n) SomeWorkflow3 workflow in the test environment
func (c *TestSimpleClient) SomeWorkflow3Async(ctx context.Context, req *SomeWorkflow3Request, options ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = "my-task-queue-2"
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(SomeWorkflow3IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	if opts.WorkflowIDReusePolicy == v1.WORKFLOW_ID_REUSE_POLICY_UNSPECIFIED {
		opts.WorkflowIDReusePolicy = v1.WORKFLOW_ID_REUSE_POLICY_ALLOW_DUPLICATE
	}
	if opts.RetryPolicy == nil {
		opts.RetryPolicy = &temporal.RetryPolicy{MaximumAttempts: int32(2)}
	}
	if opts.WorkflowExecutionTimeout == 0 {
		opts.WorkflowRunTimeout = 3600000000000 // 1h0m0s
	}
	return &testSomeWorkflow3Run{client: c, env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetSomeWorkflow3 is a noop
func (c *TestSimpleClient) GetSomeWorkflow3(ctx context.Context, workflowID string, runID string) SomeWorkflow3Run {
	return &testSomeWorkflow3Run{env: c.env, workflows: c.workflows}
}

// SomeWorkflow3WithSomeSignal2 sends a(n) SomeSignal2 signal to a(n) SomeWorkflow3 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow3WithSomeSignal2(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) error {
	c.env.RegisterDelayedCallback(func() {
		c.env.SignalWorkflow(SomeSignal2SignalName, signal)
	}, 0)
	return c.SomeWorkflow3(ctx, req, opts...)
}

// SomeWorkflow3WithSomeSignal2Async sends a(n) SomeSignal2 signal to a(n) SomeWorkflow3 workflow, starting it if necessary
func (c *TestSimpleClient) SomeWorkflow3WithSomeSignal2Async(ctx context.Context, req *SomeWorkflow3Request, signal *SomeSignal2Request, opts ...*SomeWorkflow3Options) (SomeWorkflow3Run, error) {
	c.env.RegisterDelayedCallback(func() {
		_ = c.SomeSignal2(ctx, "", "", signal)
	}, 0)
	return c.SomeWorkflow3Async(ctx, req, opts...)
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestSimpleClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestSimpleClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// SomeQuery1 executes a mycompany.simple.Simple.SomeQuery1 query
func (c *TestSimpleClient) SomeQuery1(ctx context.Context, workflowID string, runID string) (*SomeQuery1Response, error) {
	val, err := c.env.QueryWorkflow(SomeQuery1QueryName)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result SomeQuery1Response
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SomeQuery2 executes a mycompany.simple.Simple.SomeQuery2 query
func (c *TestSimpleClient) SomeQuery2(ctx context.Context, workflowID string, runID string, req *SomeQuery2Request) (*SomeQuery2Response, error) {
	val, err := c.env.QueryWorkflow(SomeQuery2QueryName, req)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result SomeQuery2Response
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// SomeSignal1 executes a SomeSignal1 signal
func (c *TestSimpleClient) SomeSignal1(ctx context.Context, workflowID string, runID string) error {
	c.env.SignalWorkflow(SomeSignal1SignalName, nil)
	return nil
}

// SomeSignal2 executes a SomeSignal2 signal
func (c *TestSimpleClient) SomeSignal2(ctx context.Context, workflowID string, runID string, req *SomeSignal2Request) error {
	c.env.SignalWorkflow(SomeSignal2SignalName, req)
	return nil
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update in the test environment
func (c *TestSimpleClient) SomeUpdate1(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	options := NewSomeUpdate1Options()
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0]
	}
	options.opts.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	handle, err := c.SomeUpdate1Async(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// SomeUpdate1Async executes a(n) mycompany.simple.Simple.SomeUpdate1 update in the test environment
func (c *TestSimpleClient) SomeUpdate1Async(ctx context.Context, workflowID string, runID string, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	options := &client.UpdateWorkflowWithOptionsRequest{}
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0].opts
	}
	options.Args = []any{req}
	options.RunID = runID
	options.UpdateName = SomeUpdate1UpdateName
	options.WorkflowID = workflowID
	if options.UpdateID == "" {
		id, err := expression.EvalExpression(SomeUpdate1IDExpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating %s id expression: %w", SomeUpdate1UpdateName, err)
		}
		options.UpdateID = id
	}
	if options.WaitPolicy.GetLifecycleStage() == v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_UNSPECIFIED {
		options.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(SomeUpdate1UpdateName, uc, req)
	return &testSomeUpdate1Handle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

var _ SomeUpdate1Handle = &testSomeUpdate1Handle{}

// testSomeUpdate1Handle provides an internal implementation of a(n) SomeUpdate1Handle
type testSomeUpdate1Handle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowWithOptionsRequest
	req        *SomeUpdate1Request
	runID      string
	workflowID string
}

// Get retrieves a test mycompany.simple.Simple.SomeUpdate1 update result
func (h *testSomeUpdate1Handle) Get(ctx context.Context) (*SomeUpdate1Response, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*SomeUpdate1Response), nil
	}
}

// RunID implementation
func (h *testSomeUpdate1Handle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testSomeUpdate1Handle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testSomeUpdate1Handle) WorkflowID() string {
	return h.workflowID
}

var _ SomeWorkflow1Run = &testSomeWorkflow1Run{}

// testSomeWorkflow1Run provides convenience methods for interacting with a(n) SomeWorkflow1 workflow in the test environment
type testSomeWorkflow1Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SomeWorkflow1Request
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow1Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test SomeWorkflow1 workflow result
func (r *testSomeWorkflow1Run) Get(context.Context) (*SomeWorkflow1Response, error) {
	r.env.ExecuteWorkflow(SomeWorkflow1WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result SomeWorkflow1Response
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test SomeWorkflow1 workflow run's workflow ID
func (r *testSomeWorkflow1Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// RunID noop implementation
func (r *testSomeWorkflow1Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow1Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeQuery1 executes a SomeQuery1 query against a test SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeQuery1(ctx context.Context) (*SomeQuery1Response, error) {
	return r.client.SomeQuery1(ctx, r.ID(), r.RunID())
}

// SomeQuery2 executes a SomeQuery2 query against a test SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeQuery2(ctx context.Context, req *SomeQuery2Request) (*SomeQuery2Response, error) {
	return r.client.SomeQuery2(ctx, r.ID(), r.RunID(), req)
}

// SomeSignal1 executes a SomeSignal1 signal against a test SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), r.RunID())
}

// SomeSignal2 executes a SomeSignal2 signal against a test SomeWorkflow1 workflow
func (r *testSomeWorkflow1Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), r.RunID(), req)
}

var _ SomeWorkflow2Run = &testSomeWorkflow2Run{}

// testSomeWorkflow2Run provides convenience methods for interacting with a(n) SomeWorkflow2 workflow in the test environment
type testSomeWorkflow2Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow2Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test SomeWorkflow2 workflow result
func (r *testSomeWorkflow2Run) Get(context.Context) error {
	r.env.ExecuteWorkflow(SomeWorkflow2WorkflowName)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test SomeWorkflow2 workflow run's workflow ID
func (r *testSomeWorkflow2Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// RunID noop implementation
func (r *testSomeWorkflow2Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow2Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal1 executes a SomeSignal1 signal against a test SomeWorkflow2 workflow
func (r *testSomeWorkflow2Run) SomeSignal1(ctx context.Context) error {
	return r.client.SomeSignal1(ctx, r.ID(), r.RunID())
}

// SomeUpdate1 executes a(n) mycompany.simple.Simple.SomeUpdate1 update against a test mycompany.simple.Simple.SomeWorkflow2 workflow
func (r *testSomeWorkflow2Run) SomeUpdate1(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (*SomeUpdate1Response, error) {
	return r.client.SomeUpdate1(ctx, r.ID(), r.RunID(), req, opts...)
}

// SomeUpdate1Async executes a(n) mycompany.simple.Simple.SomeUpdate1 update against a test mycompany.simple.Simple.SomeWorkflow2 workflow
func (r *testSomeWorkflow2Run) SomeUpdate1Async(ctx context.Context, req *SomeUpdate1Request, opts ...*SomeUpdate1Options) (SomeUpdate1Handle, error) {
	return r.client.SomeUpdate1Async(ctx, r.ID(), r.RunID(), req, opts...)
}

var _ SomeWorkflow3Run = &testSomeWorkflow3Run{}

// testSomeWorkflow3Run provides convenience methods for interacting with a(n) SomeWorkflow3 workflow in the test environment
type testSomeWorkflow3Run struct {
	client    *TestSimpleClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *SomeWorkflow3Request
	workflows SimpleWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow3Run) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test SomeWorkflow3 workflow result
func (r *testSomeWorkflow3Run) Get(context.Context) error {
	r.env.ExecuteWorkflow(SomeWorkflow3WorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return err
	}
	return nil
}

// ID returns a test SomeWorkflow3 workflow run's workflow ID
func (r *testSomeWorkflow3Run) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// RunID noop implementation
func (r *testSomeWorkflow3Run) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testSomeWorkflow3Run) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// SomeSignal2 executes a SomeSignal2 signal against a test SomeWorkflow3 workflow
func (r *testSomeWorkflow3Run) SomeSignal2(ctx context.Context, req *SomeSignal2Request) error {
	return r.client.SomeSignal2(ctx, r.ID(), r.RunID(), req)
}

// SimpleCliOptions describes runtime configuration for mycompany.simple.Simple cli
type SimpleCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewSimpleCliOptions initializes a new SimpleCliOptions value
func NewSimpleCliOptions() *SimpleCliOptions {
	return &SimpleCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *SimpleCliOptions) WithAfter(fn func(*v2.Context) error) *SimpleCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *SimpleCliOptions) WithBefore(fn func(*v2.Context) error) *SimpleCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *SimpleCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *SimpleCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *SimpleCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *SimpleCliOptions {
	opts.worker = fn
	return opts
}

// NewSimpleCli initializes a cli for a(n) mycompany.simple.Simple service
func NewSimpleCli(options ...*SimpleCliOptions) (*v2.App, error) {
	commands, err := newSimpleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "simple",
		Commands: commands,
	}, nil
}

// NewSimpleCliCommand initializes a cli command for a mycompany.simple.Simple service with subcommands for each query, signal, update, and workflow
func NewSimpleCliCommand(options ...*SimpleCliOptions) (*v2.Command, error) {
	subcommands, err := newSimpleCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "simple",
		Subcommands: subcommands,
	}, nil
}

// newSimpleCommands initializes (sub)commands for a mycompany.simple.Simple cli or command
func newSimpleCommands(options ...*SimpleCliOptions) ([]*v2.Command, error) {
	opts := &SimpleCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		// SomeQuery1 queries some thing.,
		{
			Name:                   "some-query-1",
			Usage:                  "SomeQuery1 queries some thing.",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				if resp, err := client.SomeQuery1(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", SomeQuery1QueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// SomeQuery2 queries some thing.,
		{
			Name:                   "some-query-2",
			Usage:                  "SomeQuery2 queries some thing.",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := unmarshalCliFlagsToSomeQuery2Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if resp, err := client.SomeQuery2(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error executing %q query: %w", SomeQuery2QueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// SomeSignal1 is a signal.,
		{
			Name:                   "some-signal-1",
			Usage:                  "SomeSignal1 is a signal.",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				if err := client.SomeSignal1(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeSignal1SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// SomeSignal2 is a signal.,
		{
			Name:                   "some-signal-2",
			Usage:                  "SomeSignal2 is a signal.",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := unmarshalCliFlagsToSomeSignal2Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.SomeSignal2(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", SomeSignal2SignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// SomeUpdate1 updates a SomeWorkflow2,
		{
			Name:                   "some-update-1",
			Usage:                  "SomeUpdate1 updates a SomeWorkflow2",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := unmarshalCliFlagsToSomeUpdate1Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.SomeUpdate1Async(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", SomeUpdate1UpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// SomeWorkflow1 does some workflow thing.,
		{
			Name:                   "some-workflow-1",
			Usage:                  "SomeWorkflow1 does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "id",
					Usage:    "set the value of the operation's \"Id\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := unmarshalCliFlagsToSomeWorkflow1Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				run, err := client.SomeWorkflow1Async(cmd.Context, req)
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow1WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// SomeWorkflow2 does some workflow thing.,
		{
			Name:                   "some-workflow-2",
			Usage:                  "SomeWorkflow2 does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				run, err := client.SomeWorkflow2Async(cmd.Context)
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow2WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// sends a SomeSignal1 signal to a SomeWorkflow2 worklow, starting it if necessary,
		{
			Name:                   "some-workflow-2-with-some-signal-1",
			Usage:                  "sends a SomeSignal1 signal to a SomeWorkflow2 worklow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				run, err := client.SomeWorkflow2WithSomeSignal1Async(cmd.Context)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", SomeWorkflow2WorkflowName, SomeSignal1SignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// SomeWorkflow3 does some workflow thing.,
		{
			Name:                   "some-workflow-3",
			Usage:                  "SomeWorkflow3 does some workflow thing.",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "id",
					Usage:    "set the value of the operation's \"Id\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := unmarshalCliFlagsToSomeWorkflow3Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				run, err := client.SomeWorkflow3Async(cmd.Context, req)
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", SomeWorkflow3WorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
		// sends a SomeSignal2 signal to a SomeWorkflow3 worklow, starting it if necessary,
		{
			Name:                   "some-workflow-3-with-some-signal-2",
			Usage:                  "sends a SomeSignal2 signal to a SomeWorkflow3 worklow, starting it if necessary",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "id",
					Usage:    "set the value of the operation's \"Id\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "INPUT",
				},
				&v2.StringFlag{
					Name:     "request-val",
					Usage:    "set the value of the operation's \"RequestVal\" parameter",
					Category: "SIGNAL",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewSimpleClient(c)
				req, err := unmarshalCliFlagsToSomeWorkflow3Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				signal, err := unmarshalCliFlagsToSomeSignal2Request(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling signal: %w", err)
				}
				run, err := client.SomeWorkflow3WithSomeSignal2Async(cmd.Context, req, signal)
				if err != nil {
					return fmt.Errorf("error starting %s workflow with %s signal: %w", SomeWorkflow3WorkflowName, SomeSignal2SignalName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.simple.Simple worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// unmarshalCliFlagsToSomeQuery2Request unmarshals a SomeQuery2Request from command line flags
func unmarshalCliFlagsToSomeQuery2Request(cmd *v2.Context) (*SomeQuery2Request, error) {
	var result SomeQuery2Request
	var hasValues bool
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToSomeSignal2Request unmarshals a SomeSignal2Request from command line flags
func unmarshalCliFlagsToSomeSignal2Request(cmd *v2.Context) (*SomeSignal2Request, error) {
	var result SomeSignal2Request
	var hasValues bool
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToSomeUpdate1Request unmarshals a SomeUpdate1Request from command line flags
func unmarshalCliFlagsToSomeUpdate1Request(cmd *v2.Context) (*SomeUpdate1Request, error) {
	var result SomeUpdate1Request
	var hasValues bool
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToSomeWorkflow1Request unmarshals a SomeWorkflow1Request from command line flags
func unmarshalCliFlagsToSomeWorkflow1Request(cmd *v2.Context) (*SomeWorkflow1Request, error) {
	var result SomeWorkflow1Request
	var hasValues bool
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if cmd.IsSet("id") {
		hasValues = true
		result.Id = cmd.String("id")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToSomeWorkflow3Request unmarshals a SomeWorkflow3Request from command line flags
func unmarshalCliFlagsToSomeWorkflow3Request(cmd *v2.Context) (*SomeWorkflow3Request, error) {
	var result SomeWorkflow3Request
	var hasValues bool
	if cmd.IsSet("id") {
		hasValues = true
		result.Id = cmd.String("id")
	}
	if cmd.IsSet("request-val") {
		hasValues = true
		result.RequestVal = cmd.String("request-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// OtherTaskQueue= is the default task-queue for a mycompany.simple.Other worker
const OtherTaskQueue = "other-task-queue"

// mycompany.simple.Other workflow names
const (
	OtherWorkflowWorkflowName = "mycompany.simple.Other.OtherWorkflow"
)

// mycompany.simple.Other workflow id expressions
var (
	OtherWorkflowIDExpression = expression.MustParseExpression("other-workflow/${!uuid_v4()}")
)

// mycompany.simple.Other activity names
const (
	OtherWorkflowActivityName = "mycompany.simple.Other.OtherWorkflow"
)

// mycompany.simple.Other query names
const (
	OtherQueryQueryName = "mycompany.simple.Other.OtherQuery"
)

// mycompany.simple.Other signal names
const (
	OtherSignalSignalName = "mycompany.simple.Other.OtherSignal"
)

// mycompany.simple.Other update names
const (
	OtherUpdateUpdateName = "mycompany.simple.Other.OtherUpdate"
)

// mycompany.simple.Other update id expressions
var (
	OtherUpdateIDExpression = expression.MustParseExpression("other-update/${!uuid_v4()}")
)

// OtherClient describes a client for a(n) mycompany.simple.Other worker
type OtherClient interface {
	// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
	OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest, opts ...*OtherWorkflowOptions) (*OtherWorkflowResponse, error)
	// OtherWorkflowAsync executes a(n) mycompany.simple.Other.OtherWorkflow workflow asynchronously
	OtherWorkflowAsync(ctx context.Context, req *OtherWorkflowRequest, opts ...*OtherWorkflowOptions) (OtherWorkflowRun, error)
	// GetOtherWorkflow retrieves a handle to an existing mycompany.simple.Other.OtherWorkflow workflow execution
	GetOtherWorkflow(ctx context.Context, workflowID string, runID string) OtherWorkflowRun
	// CancelWorkflow requests cancellation of an existing workflow execution
	CancelWorkflow(ctx context.Context, workflowID string, runID string) error
	// TerminateWorkflow an existing workflow execution
	TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error
	// OtherQuery executes a(n) mycompany.simple.Other.OtherQuery query
	OtherQuery(ctx context.Context, workflowID string, runID string) (*OtherQueryResponse, error)
	// OtherSignal sends a(n) mycompany.simple.Other.OtherSignal signal
	OtherSignal(ctx context.Context, workflowID string, runID string, signal *OtherSignalRequest) error
	// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until update completion
	OtherUpdate(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (*OtherUpdateResponse, error)
	// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update and blocks until update completion
	OtherUpdateAsync(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (OtherUpdateHandle, error)
}

// otherClient implements a temporal client for a mycompany.simple.Other service
type otherClient struct {
	client client.Client
}

// NewOtherClient initializes a new mycompany.simple.Other client
func NewOtherClient(c client.Client) OtherClient {
	return &otherClient{client: c}
}

// NewOtherClientWithOptions initializes a new Other client with the given options
func NewOtherClientWithOptions(c client.Client, opts client.Options) (OtherClient, error) {
	var err error
	c, err = client.NewClientFromExisting(c, opts)
	if err != nil {
		return nil, fmt.Errorf("error initializing client with options: %w", err)
	}
	return &otherClient{client: c}, nil
}

// OtherWorkflow executes a mycompany.simple.Other.OtherWorkflow workflow and blocks until error or response received
func (c *otherClient) OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowOptions) (*OtherWorkflowResponse, error) {
	run, err := c.OtherWorkflowAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflowAsync starts a(n) mycompany.simple.Other.OtherWorkflow workflow
func (c *otherClient) OtherWorkflowAsync(ctx context.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowOptions) (OtherWorkflowRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = OtherTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(OtherWorkflowIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	run, err := c.client.ExecuteWorkflow(ctx, *opts, OtherWorkflowWorkflowName, req)
	if err != nil {
		return nil, err
	}
	if run == nil {
		return nil, errors.New("execute workflow returned nil run")
	}
	return &otherWorkflowRun{
		client: c,
		run:    run,
	}, nil
}

// GetOtherWorkflow fetches an existing mycompany.simple.Other.OtherWorkflow execution
func (c *otherClient) GetOtherWorkflow(ctx context.Context, workflowID string, runID string) OtherWorkflowRun {
	return &otherWorkflowRun{
		client: c,
		run:    c.client.GetWorkflow(ctx, workflowID, runID),
	}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *otherClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	return c.client.CancelWorkflow(ctx, workflowID, runID)
}

// TerminateWorkflow terminates an existing workflow execution
func (c *otherClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.client.TerminateWorkflow(ctx, workflowID, runID, reason, details...)
}

// OtherQuery sends a(n) mycompany.simple.Other.OtherQuery query to an existing workflow
func (c *otherClient) OtherQuery(ctx context.Context, workflowID string, runID string) (*OtherQueryResponse, error) {
	var resp OtherQueryResponse
	if val, err := c.client.QueryWorkflow(ctx, workflowID, runID, OtherQueryQueryName); err != nil {
		return nil, err
	} else if err = val.Get(&resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// OtherSignal sends a(n) mycompany.simple.Other.OtherSignal signal to an existing workflow
func (c *otherClient) OtherSignal(ctx context.Context, workflowID string, runID string, signal *OtherSignalRequest) error {
	return c.client.SignalWorkflow(ctx, workflowID, runID, OtherSignalSignalName, signal)
}

// OtherUpdate sends a(n) mycompany.simple.Other.OtherUpdate update to an existing workflow
func (c *otherClient) OtherUpdate(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (*OtherUpdateResponse, error) {
	options := NewOtherUpdateOptions()
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0]
	}
	options.opts.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	handle, err := c.OtherUpdateAsync(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// OtherUpdateAsync sends a(n) mycompany.simple.Other.OtherUpdate update to an existing workflow
func (c *otherClient) OtherUpdateAsync(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (OtherUpdateHandle, error) {
	options := &client.UpdateWorkflowWithOptionsRequest{}
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0].opts
	}
	options.Args = []any{req}
	options.RunID = runID
	options.UpdateName = OtherUpdateUpdateName
	options.WorkflowID = workflowID
	if options.UpdateID == "" {
		id, err := expression.EvalExpression(OtherUpdateIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating %s id expression: %w", OtherUpdateUpdateName, err)
		}
		options.UpdateID = id
	}
	handle, err := c.client.UpdateWorkflowWithOptions(ctx, options)
	if err != nil {
		return nil, err
	}
	return &otherUpdateHandle{client: c, handle: handle}, nil
}

// OtherWorkflowOptions provides configuration for a mycompany.simple.Other.OtherWorkflow workflow operation
type OtherWorkflowOptions struct {
	opts *client.StartWorkflowOptions
}

// NewOtherWorkflowOptions initializes a new OtherWorkflowOptions value
func NewOtherWorkflowOptions() *OtherWorkflowOptions {
	return &OtherWorkflowOptions{}
}

// WithStartWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *OtherWorkflowOptions) WithStartWorkflowOptions(options client.StartWorkflowOptions) *OtherWorkflowOptions {
	opts.opts = &options
	return opts
}

// OtherWorkflowRun describes a(n) mycompany.simple.Other.OtherWorkflow workflow run
type OtherWorkflowRun interface {
	// ID returns the workflow ID
	ID() string
	// RunID returns the workflow instance ID
	RunID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*OtherWorkflowResponse, error)
	// Cancel requests cancellation of a workflow in execution, returning an error if applicable
	Cancel(ctx context.Context) error
	// Terminate terminates a workflow in execution, returning an error if applicable
	Terminate(ctx context.Context, reason string, details ...interface{}) error
}

// otherWorkflowRun provides an internal implementation of a(n) OtherWorkflowRunRun
type otherWorkflowRun struct {
	client *otherClient
	run    client.WorkflowRun
}

// ID returns the workflow ID
func (r *otherWorkflowRun) ID() string {
	return r.run.GetID()
}

// RunID returns the execution ID
func (r *otherWorkflowRun) RunID() string {
	return r.run.GetRunID()
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *otherWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get blocks until the workflow is complete, returning the result if applicable
func (r *otherWorkflowRun) Get(ctx context.Context) (*OtherWorkflowResponse, error) {
	var resp OtherWorkflowResponse
	if err := r.run.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *otherWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// OtherUpdateHandle describes a(n) mycompany.simple.Other.OtherUpdate update handle
type OtherUpdateHandle interface {
	// WorkflowID returns the workflow ID
	WorkflowID() string
	// RunID returns the workflow instance ID
	RunID() string
	// UpdateID returns the update ID
	UpdateID() string
	// Get blocks until the workflow is complete and returns the result
	Get(ctx context.Context) (*OtherUpdateResponse, error)
}

// otherUpdateHandle provides an internal implementation of a(n) OtherUpdateHandle
type otherUpdateHandle struct {
	client *otherClient
	handle client.WorkflowUpdateHandle
}

// WorkflowID returns the workflow ID
func (h *otherUpdateHandle) WorkflowID() string {
	return h.handle.WorkflowID()
}

// RunID returns the execution ID
func (h *otherUpdateHandle) RunID() string {
	return h.handle.RunID()
}

// UpdateID returns the update ID
func (h *otherUpdateHandle) UpdateID() string {
	return h.handle.UpdateID()
}

// Get blocks until the update wait policy is met, returning the result if applicable
func (h *otherUpdateHandle) Get(ctx context.Context) (*OtherUpdateResponse, error) {
	var resp OtherUpdateResponse
	if err := h.handle.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// OtherUpdateOptions provides configuration for a mycompany.simple.Other.OtherUpdate update operation
type OtherUpdateOptions struct {
	opts *client.UpdateWorkflowWithOptionsRequest
}

// NewOtherUpdateOptions initializes a new OtherUpdateOptions value
func NewOtherUpdateOptions() *OtherUpdateOptions {
	return &OtherUpdateOptions{opts: &client.UpdateWorkflowWithOptionsRequest{}}
}

// WithUpdateWorkflowOptions sets the initial client.UpdateWorkflowWithOptionsRequest
func (opts *OtherUpdateOptions) WithUpdateWorkflowOptions(options client.UpdateWorkflowWithOptionsRequest) *OtherUpdateOptions {
	opts.opts = &options
	return opts
}

// Reference to generated workflow functions
var (
	// OtherWorkflowFunction implements a "OtherWorkflowWorkflow" workflow
	OtherWorkflowFunction func(workflow.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
)

// OtherWorkflows provides methods for initializing new mycompany.simple.Other workflow values
type OtherWorkflows interface {
	OtherWorkflow(ctx workflow.Context, input *OtherWorkflowInput) (OtherWorkflowWorkflow, error)
}

// OtherWorkflow initializes a new a(n) OtherWorkflowWorkflow implementation
// RegisterOtherWorkflows registers mycompany.simple.Other workflows with the given worker
func RegisterOtherWorkflows(r worker.WorkflowRegistry, workflows OtherWorkflows) {
	RegisterOtherWorkflowWorkflow(r, workflows.OtherWorkflow)
}

// RegisterOtherWorkflowWorkflow registers a mycompany.simple.Other.OtherWorkflow workflow with the given worker
func RegisterOtherWorkflowWorkflow(r worker.WorkflowRegistry, wf func(workflow.Context, *OtherWorkflowInput) (OtherWorkflowWorkflow, error)) {
	OtherWorkflowFunction = buildOtherWorkflow(wf)
	r.RegisterWorkflowWithOptions(OtherWorkflowFunction, workflow.RegisterOptions{Name: OtherWorkflowWorkflowName})
}

// buildOtherWorkflow converts a OtherWorkflow workflow struct into a valid workflow function
func buildOtherWorkflow(ctor func(workflow.Context, *OtherWorkflowInput) (OtherWorkflowWorkflow, error)) func(workflow.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error) {
	return func(ctx workflow.Context, req *OtherWorkflowRequest) (*OtherWorkflowResponse, error) {
		input := &OtherWorkflowInput{
			Req: req,
		}
		wf, err := ctor(ctx, input)
		if err != nil {
			return nil, err
		}
		return wf.Execute(ctx)
	}
}

// OtherWorkflowInput describes the input to a(n) mycompany.simple.Other.OtherWorkflow workflow constructor
type OtherWorkflowInput struct {
	Req *OtherWorkflowRequest
}

// OtherWorkflowWorkflow describes a(n) mycompany.simple.Other.OtherWorkflow workflow implementation
type OtherWorkflowWorkflow interface {
	// Execute defines the entrypoint to a(n) mycompany.simple.Other.OtherWorkflow workflow
	Execute(ctx workflow.Context) (*OtherWorkflowResponse, error)
}

// OtherWorkflowChild executes a child mycompany.simple.Other.OtherWorkflow workflow
func OtherWorkflowChild(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowChildOptions) (*OtherWorkflowResponse, error) {
	childRun, err := OtherWorkflowChildAsync(ctx, req, options...)
	if err != nil {
		return nil, err
	}
	return childRun.Get(ctx)
}

// OtherWorkflowChildAsync executes a child mycompany.simple.Other.OtherWorkflow workflow
func OtherWorkflowChildAsync(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowChildOptions) (*OtherWorkflowChildRun, error) {
	var opts *workflow.ChildWorkflowOptions
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	} else {
		childOpts := workflow.GetChildWorkflowOptions(ctx)
		opts = &childOpts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = OtherTaskQueue
	}
	if opts.WorkflowID == "" {
		id, err := expression.EvalExpression(OtherWorkflowIDExpression, req.ProtoReflect())
		if err != nil {
			panic(err)
		}
		opts.WorkflowID = id
	}
	ctx = workflow.WithChildOptions(ctx, *opts)
	return &OtherWorkflowChildRun{Future: workflow.ExecuteChildWorkflow(ctx, OtherWorkflowWorkflowName, req)}, nil
}

// OtherWorkflowChildOptions provides configuration for a mycompany.simple.Other.OtherWorkflow workflow operation
type OtherWorkflowChildOptions struct {
	opts *workflow.ChildWorkflowOptions
}

// NewOtherWorkflowChildOptions initializes a new OtherWorkflowChildOptions value
func NewOtherWorkflowChildOptions() *OtherWorkflowChildOptions {
	return &OtherWorkflowChildOptions{}
}

// WithChildWorkflowOptions sets the initial client.StartWorkflowOptions
func (opts *OtherWorkflowChildOptions) WithChildWorkflowOptions(options workflow.ChildWorkflowOptions) *OtherWorkflowChildOptions {
	opts.opts = &options
	return opts
}

// OtherWorkflowChildRun describes a child mycompany.simple.Other.OtherWorkflow workflow run
type OtherWorkflowChildRun struct {
	Future workflow.ChildWorkflowFuture
}

// Get blocks until the workflow is completed, returning the response value
func (r *OtherWorkflowChildRun) Get(ctx workflow.Context) (*OtherWorkflowResponse, error) {
	var resp OtherWorkflowResponse
	if err := r.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds this completion to the selector. Callback can be nil.
func (r *OtherWorkflowChildRun) Select(sel workflow.Selector, fn func(OtherWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future, func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// SelectStart adds waiting for start to the selector. Callback can be nil.
func (r *OtherWorkflowChildRun) SelectStart(sel workflow.Selector, fn func(OtherWorkflowChildRun)) workflow.Selector {
	return sel.AddFuture(r.Future.GetChildWorkflowExecution(), func(workflow.Future) {
		if fn != nil {
			fn(*r)
		}
	})
}

// WaitStart waits for the child workflow to start
func (r *OtherWorkflowChildRun) WaitStart(ctx workflow.Context) (*workflow.Execution, error) {
	var exec workflow.Execution
	if err := r.Future.GetChildWorkflowExecution().Get(ctx, &exec); err != nil {
		return nil, err
	}
	return &exec, nil
}

// OtherSignalSignal describes a(n) mycompany.simple.Other.OtherSignal signal
type OtherSignalSignal struct {
	Channel workflow.ReceiveChannel
}

// Receive blocks until a(n) mycompany.simple.Other.OtherSignal signal is received
func (s *OtherSignalSignal) Receive(ctx workflow.Context) (*OtherSignalRequest, bool) {
	var resp OtherSignalRequest
	more := s.Channel.Receive(ctx, &resp)
	return &resp, more
}

// ReceiveAsync checks for a mycompany.simple.Other.OtherSignal signal without blocking
func (s *OtherSignalSignal) ReceiveAsync() *OtherSignalRequest {
	var resp OtherSignalRequest
	if ok := s.Channel.ReceiveAsync(&resp); !ok {
		return nil
	}
	return &resp
}

// Select checks for a(n) mycompany.simple.Other.OtherSignal signal without blocking
func (s *OtherSignalSignal) Select(sel workflow.Selector, fn func(*OtherSignalRequest)) workflow.Selector {
	return sel.AddReceive(s.Channel, func(workflow.ReceiveChannel, bool) {
		req := s.ReceiveAsync()
		if fn != nil {
			fn(req)
		}
	})
}

// OtherSignalExternal sends a(n) mycompany.simple.Other.OtherSignal signal to an existing workflow
func OtherSignalExternal(ctx workflow.Context, workflowID string, runID string, req *OtherSignalRequest) error {
	return OtherSignalExternalAsync(ctx, workflowID, runID, req).Get(ctx, nil)
}

// OtherSignalExternalAsync sends a(n) mycompany.simple.Other.OtherSignal signal to an existing workflow
func OtherSignalExternalAsync(ctx workflow.Context, workflowID string, runID string, req *OtherSignalRequest) workflow.Future {
	return workflow.SignalExternalWorkflow(ctx, workflowID, runID, OtherSignalSignalName, req)
}

// OtherActivities describes available worker activites
type OtherActivities interface {
	OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
}

// RegisterOtherActivities registers activities with a worker
func RegisterOtherActivities(r worker.ActivityRegistry, activities OtherActivities) {
	RegisterOtherWorkflowActivity(r, activities.OtherWorkflow)
}

// RegisterOtherWorkflowActivity registers a mycompany.simple.Other.OtherWorkflow activity
func RegisterOtherWorkflowActivity(r worker.ActivityRegistry, fn func(context.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)) {
	r.RegisterActivityWithOptions(fn, activity.RegisterOptions{
		Name: OtherWorkflowActivityName,
	})
}

// OtherWorkflowFuture describes a(n) mycompany.simple.Other.OtherWorkflow activity execution
type OtherWorkflowFuture struct {
	Future workflow.Future
}

// Get blocks on the activity's completion, returning the response
func (f *OtherWorkflowFuture) Get(ctx workflow.Context) (*OtherWorkflowResponse, error) {
	var resp OtherWorkflowResponse
	if err := f.Future.Get(ctx, &resp); err != nil {
		return nil, err
	}
	return &resp, nil
}

// Select adds the activity's completion to the selector, callback can be nil
func (f *OtherWorkflowFuture) Select(sel workflow.Selector, fn func(*OtherWorkflowFuture)) workflow.Selector {
	return sel.AddFuture(f.Future, func(workflow.Future) {
		if fn != nil {
			fn(f)
		}
	})
}

// OtherWorkflow executes a(n) mycompany.simple.Other.OtherWorkflow activity
func OtherWorkflow(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowActivityOptions) (*OtherWorkflowResponse, error) {
	var opts *OtherWorkflowActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewOtherWorkflowActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = OtherWorkflowActivityName
	future := &OtherWorkflowFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// OtherWorkflowAsync executes a(n) mycompany.simple.Other.OtherWorkflow activity (asynchronously)
func OtherWorkflowAsync(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowActivityOptions) *OtherWorkflowFuture {
	var opts *OtherWorkflowActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewOtherWorkflowActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithActivityOptions(ctx, *opts.opts)
	var activity any
	activity = OtherWorkflowActivityName
	future := &OtherWorkflowFuture{Future: workflow.ExecuteActivity(ctx, activity, req)}
	return future
}

// OtherWorkflowLocal executes a(n) mycompany.simple.Other.OtherWorkflow activity (locally)
func OtherWorkflowLocal(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowLocalActivityOptions) (*OtherWorkflowResponse, error) {
	var opts *OtherWorkflowLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewOtherWorkflowLocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = OtherWorkflowActivityName
	}
	future := &OtherWorkflowFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future.Get(ctx)
}

// OtherWorkflowLocalAsync executes a(n) mycompany.simple.Other.OtherWorkflow activity (asynchronously, locally)
func OtherWorkflowLocalAsync(ctx workflow.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowLocalActivityOptions) *OtherWorkflowFuture {
	var opts *OtherWorkflowLocalActivityOptions
	if len(options) > 0 && options[0] != nil {
		opts = options[0]
	} else {
		opts = NewOtherWorkflowLocalActivityOptions()
	}
	if opts.opts == nil {
		activityOpts := workflow.GetLocalActivityOptions(ctx)
		opts.opts = &activityOpts
	}
	if opts.opts.StartToCloseTimeout == 0 {
		opts.opts.StartToCloseTimeout = 30000000000 // 30s
	}
	ctx = workflow.WithLocalActivityOptions(ctx, *opts.opts)
	var activity any
	if opts.fn != nil {
		activity = opts.fn
	} else {
		activity = OtherWorkflowActivityName
	}
	future := &OtherWorkflowFuture{Future: workflow.ExecuteLocalActivity(ctx, activity, req)}
	return future
}

// OtherWorkflowLocalActivityOptions provides configuration for a local mycompany.simple.Other.OtherWorkflow activity
type OtherWorkflowLocalActivityOptions struct {
	fn   func(context.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)
	opts *workflow.LocalActivityOptions
}

// NewOtherWorkflowLocalActivityOptions sets default LocalActivityOptions
func NewOtherWorkflowLocalActivityOptions() *OtherWorkflowLocalActivityOptions {
	return &OtherWorkflowLocalActivityOptions{}
}

// Local provides a local mycompany.simple.Other.OtherWorkflow activity implementation
func (opts *OtherWorkflowLocalActivityOptions) Local(fn func(context.Context, *OtherWorkflowRequest) (*OtherWorkflowResponse, error)) *OtherWorkflowLocalActivityOptions {
	opts.fn = fn
	return opts
}

// WithLocalActivityOptions sets default LocalActivityOptions
func (opts *OtherWorkflowLocalActivityOptions) WithLocalActivityOptions(options workflow.LocalActivityOptions) *OtherWorkflowLocalActivityOptions {
	opts.opts = &options
	return opts
}

// OtherWorkflowActivityOptions provides configuration for a(n) mycompany.simple.Other.OtherWorkflow activity
type OtherWorkflowActivityOptions struct {
	opts *workflow.ActivityOptions
}

// NewOtherWorkflowActivityOptions sets default ActivityOptions
func NewOtherWorkflowActivityOptions() *OtherWorkflowActivityOptions {
	return &OtherWorkflowActivityOptions{}
}

// WithActivityOptions sets default ActivityOptions
func (opts *OtherWorkflowActivityOptions) WithActivityOptions(options workflow.ActivityOptions) *OtherWorkflowActivityOptions {
	opts.opts = &options
	return opts
}

// TestClient provides a testsuite-compatible Client
type TestOtherClient struct {
	env       *testsuite.TestWorkflowEnvironment
	workflows OtherWorkflows
}

var _ OtherClient = &TestOtherClient{}

// NewTestOtherClient initializes a new TestOtherClient value
func NewTestOtherClient(env *testsuite.TestWorkflowEnvironment, workflows OtherWorkflows, activities OtherActivities) *TestOtherClient {
	RegisterOtherWorkflows(env, workflows)
	if activities != nil {
		RegisterOtherActivities(env, activities)
	}
	return &TestOtherClient{env, workflows}
}

// OtherWorkflow executes a(n) OtherWorkflow workflow in the test environment
func (c *TestOtherClient) OtherWorkflow(ctx context.Context, req *OtherWorkflowRequest, opts ...*OtherWorkflowOptions) (*OtherWorkflowResponse, error) {
	run, err := c.OtherWorkflowAsync(ctx, req, opts...)
	if err != nil {
		return nil, err
	}
	return run.Get(ctx)
}

// OtherWorkflowAsync executes a(n) OtherWorkflow workflow in the test environment
func (c *TestOtherClient) OtherWorkflowAsync(ctx context.Context, req *OtherWorkflowRequest, options ...*OtherWorkflowOptions) (OtherWorkflowRun, error) {
	opts := &client.StartWorkflowOptions{}
	if len(options) > 0 && options[0].opts != nil {
		opts = options[0].opts
	}
	if opts.TaskQueue == "" {
		opts.TaskQueue = OtherTaskQueue
	}
	if opts.ID == "" {
		id, err := expression.EvalExpression(OtherWorkflowIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, err
		}
		opts.ID = id
	}
	return &testOtherWorkflowRun{client: c, env: c.env, opts: opts, req: req, workflows: c.workflows}, nil
}

// GetOtherWorkflow is a noop
func (c *TestOtherClient) GetOtherWorkflow(ctx context.Context, workflowID string, runID string) OtherWorkflowRun {
	return &testOtherWorkflowRun{env: c.env, workflows: c.workflows}
}

// CancelWorkflow requests cancellation of an existing workflow execution
func (c *TestOtherClient) CancelWorkflow(ctx context.Context, workflowID string, runID string) error {
	c.env.CancelWorkflow()
	return nil
}

// TerminateWorkflow terminates an existing workflow execution
func (c *TestOtherClient) TerminateWorkflow(ctx context.Context, workflowID string, runID string, reason string, details ...interface{}) error {
	return c.CancelWorkflow(ctx, workflowID, runID)
}

// OtherQuery executes a mycompany.simple.Other.OtherQuery query
func (c *TestOtherClient) OtherQuery(ctx context.Context, workflowID string, runID string) (*OtherQueryResponse, error) {
	val, err := c.env.QueryWorkflow(OtherQueryQueryName)
	if err != nil {
		return nil, err
	} else if !val.HasValue() {
		return nil, nil
	} else {
		var result OtherQueryResponse
		if err := val.Get(&result); err != nil {
			return nil, err
		}
		return &result, nil
	}
}

// OtherSignal executes a OtherSignal signal
func (c *TestOtherClient) OtherSignal(ctx context.Context, workflowID string, runID string, req *OtherSignalRequest) error {
	c.env.SignalWorkflow(OtherSignalSignalName, req)
	return nil
}

// OtherUpdate executes a(n) mycompany.simple.Other.OtherUpdate update in the test environment
func (c *TestOtherClient) OtherUpdate(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (*OtherUpdateResponse, error) {
	options := NewOtherUpdateOptions()
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0]
	}
	options.opts.WaitPolicy = &v11.WaitPolicy{LifecycleStage: v1.UPDATE_WORKFLOW_EXECUTION_LIFECYCLE_STAGE_COMPLETED}
	handle, err := c.OtherUpdateAsync(ctx, workflowID, runID, req, options)
	if err != nil {
		return nil, err
	}
	return handle.Get(ctx)
}

// OtherUpdateAsync executes a(n) mycompany.simple.Other.OtherUpdate update in the test environment
func (c *TestOtherClient) OtherUpdateAsync(ctx context.Context, workflowID string, runID string, req *OtherUpdateRequest, opts ...*OtherUpdateOptions) (OtherUpdateHandle, error) {
	options := &client.UpdateWorkflowWithOptionsRequest{}
	if len(opts) > 0 && opts[0].opts != nil {
		options = opts[0].opts
	}
	options.Args = []any{req}
	options.RunID = runID
	options.UpdateName = OtherUpdateUpdateName
	options.WorkflowID = workflowID
	if options.UpdateID == "" {
		id, err := expression.EvalExpression(OtherUpdateIDExpression, req.ProtoReflect())
		if err != nil {
			return nil, fmt.Errorf("error evaluating %s id expression: %w", OtherUpdateUpdateName, err)
		}
		options.UpdateID = id
	}
	uc := testutil.NewUpdateCallbacks()
	c.env.UpdateWorkflow(OtherUpdateUpdateName, uc, req)
	return &testOtherUpdateHandle{
		callbacks:  uc,
		env:        c.env,
		opts:       options,
		runID:      runID,
		workflowID: workflowID,
		req:        req,
	}, nil
}

var _ OtherUpdateHandle = &testOtherUpdateHandle{}

// testOtherUpdateHandle provides an internal implementation of a(n) OtherUpdateHandle
type testOtherUpdateHandle struct {
	callbacks  *testutil.UpdateCallbacks
	env        *testsuite.TestWorkflowEnvironment
	opts       *client.UpdateWorkflowWithOptionsRequest
	req        *OtherUpdateRequest
	runID      string
	workflowID string
}

// Get retrieves a test mycompany.simple.Other.OtherUpdate update result
func (h *testOtherUpdateHandle) Get(ctx context.Context) (*OtherUpdateResponse, error) {
	if resp, err := h.callbacks.Get(ctx); err != nil {
		return nil, err
	} else {
		return resp.(*OtherUpdateResponse), nil
	}
}

// RunID implementation
func (h *testOtherUpdateHandle) RunID() string {
	return h.runID
}

// UpdateID implementation
func (h *testOtherUpdateHandle) UpdateID() string {
	if h.opts != nil {
		return h.opts.UpdateID
	}
	return ""
}

// WorkflowID implementation
func (h *testOtherUpdateHandle) WorkflowID() string {
	return h.workflowID
}

var _ OtherWorkflowRun = &testOtherWorkflowRun{}

// testOtherWorkflowRun provides convenience methods for interacting with a(n) OtherWorkflow workflow in the test environment
type testOtherWorkflowRun struct {
	client    *TestOtherClient
	env       *testsuite.TestWorkflowEnvironment
	opts      *client.StartWorkflowOptions
	req       *OtherWorkflowRequest
	workflows OtherWorkflows
}

// Cancel requests cancellation of a workflow in execution, returning an error if applicable
func (r *testOtherWorkflowRun) Cancel(ctx context.Context) error {
	return r.client.CancelWorkflow(ctx, r.ID(), r.RunID())
}

// Get retrieves a test OtherWorkflow workflow result
func (r *testOtherWorkflowRun) Get(context.Context) (*OtherWorkflowResponse, error) {
	r.env.ExecuteWorkflow(OtherWorkflowWorkflowName, r.req)
	if !r.env.IsWorkflowCompleted() {
		return nil, errors.New("workflow in progress")
	}
	if err := r.env.GetWorkflowError(); err != nil {
		return nil, err
	}
	var result OtherWorkflowResponse
	if err := r.env.GetWorkflowResult(&result); err != nil {
		return nil, err
	}
	return &result, nil
}

// ID returns a test OtherWorkflow workflow run's workflow ID
func (r *testOtherWorkflowRun) ID() string {
	if r.opts != nil {
		return r.opts.ID
	}
	return ""
}

// RunID noop implementation
func (r *testOtherWorkflowRun) RunID() string {
	return ""
}

// Terminate terminates a workflow in execution, returning an error if applicable
func (r *testOtherWorkflowRun) Terminate(ctx context.Context, reason string, details ...interface{}) error {
	return r.client.TerminateWorkflow(ctx, r.ID(), r.RunID(), reason, details...)
}

// OtherCliOptions describes runtime configuration for mycompany.simple.Other cli
type OtherCliOptions struct {
	after            func(*v2.Context) error
	before           func(*v2.Context) error
	clientForCommand func(*v2.Context) (client.Client, error)
	worker           func(*v2.Context, client.Client) (worker.Worker, error)
}

// NewOtherCliOptions initializes a new OtherCliOptions value
func NewOtherCliOptions() *OtherCliOptions {
	return &OtherCliOptions{}
}

// WithAfter injects a custom After hook to be run after any command invocation
func (opts *OtherCliOptions) WithAfter(fn func(*v2.Context) error) *OtherCliOptions {
	opts.after = fn
	return opts
}

// WithBefore injects a custom Before hook to be run prior to any command invocation
func (opts *OtherCliOptions) WithBefore(fn func(*v2.Context) error) *OtherCliOptions {
	opts.before = fn
	return opts
}

// WithClient provides a Temporal client factory for use by commands
func (opts *OtherCliOptions) WithClient(fn func(*v2.Context) (client.Client, error)) *OtherCliOptions {
	opts.clientForCommand = fn
	return opts
}

// WithWorker provides an method for initializing a worker
func (opts *OtherCliOptions) WithWorker(fn func(*v2.Context, client.Client) (worker.Worker, error)) *OtherCliOptions {
	opts.worker = fn
	return opts
}

// NewOtherCli initializes a cli for a(n) mycompany.simple.Other service
func NewOtherCli(options ...*OtherCliOptions) (*v2.App, error) {
	commands, err := newOtherCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.App{
		Name:     "other",
		Commands: commands,
	}, nil
}

// NewOtherCliCommand initializes a cli command for a mycompany.simple.Other service with subcommands for each query, signal, update, and workflow
func NewOtherCliCommand(options ...*OtherCliOptions) (*v2.Command, error) {
	subcommands, err := newOtherCommands(options...)
	if err != nil {
		return nil, fmt.Errorf("error initializing subcommands: %w", err)
	}
	return &v2.Command{
		Name:        "other",
		Subcommands: subcommands,
	}, nil
}

// newOtherCommands initializes (sub)commands for a mycompany.simple.Other cli or command
func newOtherCommands(options ...*OtherCliOptions) ([]*v2.Command, error) {
	opts := &OtherCliOptions{}
	if len(options) > 0 {
		opts = options[0]
	}
	if opts.clientForCommand == nil {
		opts.clientForCommand = func(*v2.Context) (client.Client, error) {
			return client.Dial(client.Options{})
		}
	}
	commands := []*v2.Command{
		// executes a OtherQuery query and blocks until error or response received,
		{
			Name:                   "other-query",
			Usage:                  "executes a OtherQuery query and blocks until error or response received",
			Category:               "QUERIES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewOtherClient(c)
				if resp, err := client.OtherQuery(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id")); err != nil {
					return fmt.Errorf("error executing %q query: %w", OtherQueryQueryName, err)
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// executes a OtherSignal signal,
		{
			Name:                   "other-signal",
			Usage:                  "executes a OtherSignal signal",
			Category:               "SIGNALS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "type",
					Usage:    "set the value of the operation's \"Type\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewOtherClient(c)
				req, err := unmarshalCliFlagsToOtherSignalRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				if err := client.OtherSignal(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req); err != nil {
					return fmt.Errorf("error sending %q signal: %w", OtherSignalSignalName, err)
				}
				fmt.Println("success")
				return nil
			},
		},
		// OtherUpdate executes a(n) OtherUpdate update,
		{
			Name:                   "other-update",
			Usage:                  "OtherUpdate executes a(n) OtherUpdate update",
			Category:               "UPDATES",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "workflow-id",
					Usage:    "workflow id",
					Required: true,
					Aliases:  []string{"w"},
				},
				&v2.StringFlag{
					Name:    "run-id",
					Usage:   "run id",
					Aliases: []string{"r"},
				},
				&v2.StringFlag{
					Name:     "mode",
					Usage:    "set the value of the operation's \"Mode\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewOtherClient(c)
				req, err := unmarshalCliFlagsToOtherUpdateRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				handle, err := client.OtherUpdateAsync(cmd.Context, cmd.String("workflow-id"), cmd.String("run-id"), req)
				if err != nil {
					return fmt.Errorf("error executing %s update: %w", OtherUpdateUpdateName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", handle.WorkflowID())
					fmt.Printf("run id: %s\n", handle.RunID())
					fmt.Printf("update id: %s\n", handle.UpdateID())
					return nil
				}
				if resp, err := handle.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
		// OtherWorkflow executes a(n) OtherWorkflow workflow,
		{
			Name:                   "other-workflow",
			Usage:                  "OtherWorkflow executes a(n) OtherWorkflow workflow",
			Category:               "WORKFLOWS",
			UseShortOptionHandling: true,
			Before:                 opts.before,
			After:                  opts.after,
			Flags: []v2.Flag{
				&v2.BoolFlag{
					Name:    "detach",
					Usage:   "run workflow in the background and print workflow and execution id",
					Aliases: []string{"d"},
				},
				&v2.StringFlag{
					Name:     "some-val",
					Usage:    "set the value of the operation's \"SomeVal\" parameter",
					Category: "INPUT",
				},
			},
			Action: func(cmd *v2.Context) error {
				c, err := opts.clientForCommand(cmd)
				if err != nil {
					return fmt.Errorf("error initializing client for command: %w", err)
				}
				defer c.Close()
				client := NewOtherClient(c)
				req, err := unmarshalCliFlagsToOtherWorkflowRequest(cmd)
				if err != nil {
					return fmt.Errorf("error unmarshalling request: %w", err)
				}
				run, err := client.OtherWorkflowAsync(cmd.Context, req)
				if err != nil {
					return fmt.Errorf("error starting %s workflow: %w", OtherWorkflowWorkflowName, err)
				}
				if cmd.Bool("detach") {
					fmt.Println("success")
					fmt.Printf("workflow id: %s\n", run.ID())
					fmt.Printf("run id: %s\n", run.RunID())
					return nil
				}
				if resp, err := run.Get(cmd.Context); err != nil {
					return err
				} else {
					b, err := protojson.Marshal(resp)
					if err != nil {
						return fmt.Errorf("error serializing response json: %w", err)
					}
					var out bytes.Buffer
					if err := json.Indent(&out, b, "", "  "); err != nil {
						return fmt.Errorf("error formatting json: %w", err)
					}
					fmt.Println(out.String())
					return nil
				}
			},
		},
	}
	if opts.worker != nil {
		commands = append(commands, []*v2.Command{
			{
				Name:                   "worker",
				Usage:                  "runs a mycompany.simple.Other worker process",
				UseShortOptionHandling: true,
				Before:                 opts.before,
				After:                  opts.after,
				Action: func(cmd *v2.Context) error {
					c, err := opts.clientForCommand(cmd)
					if err != nil {
						return fmt.Errorf("error initializing client for command: %w", err)
					}
					defer c.Close()
					w, err := opts.worker(cmd, c)
					if opts.worker != nil {
						if err != nil {
							return fmt.Errorf("error initializing worker: %w", err)
						}
					}
					if err := w.Start(); err != nil {
						return fmt.Errorf("error starting worker: %w", err)
					}
					defer w.Stop()
					<-cmd.Context.Done()
					return nil
				},
			},
		}...)
	}
	sort.Slice(commands, func(i, j int) bool {
		return commands[i].Name < commands[j].Name
	})
	return commands, nil
}

// unmarshalCliFlagsToOtherSignalRequest unmarshals a OtherSignalRequest from command line flags
func unmarshalCliFlagsToOtherSignalRequest(cmd *v2.Context) (*OtherSignalRequest, error) {
	var result OtherSignalRequest
	var hasValues bool
	if cmd.IsSet("type") {
		hasValues = true
		result.Type = cmd.String("type")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToOtherUpdateRequest unmarshals a OtherUpdateRequest from command line flags
func unmarshalCliFlagsToOtherUpdateRequest(cmd *v2.Context) (*OtherUpdateRequest, error) {
	var result OtherUpdateRequest
	var hasValues bool
	if cmd.IsSet("mode") {
		hasValues = true
		result.Mode = cmd.String("mode")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}

// unmarshalCliFlagsToOtherWorkflowRequest unmarshals a OtherWorkflowRequest from command line flags
func unmarshalCliFlagsToOtherWorkflowRequest(cmd *v2.Context) (*OtherWorkflowRequest, error) {
	var result OtherWorkflowRequest
	var hasValues bool
	if cmd.IsSet("some-val") {
		hasValues = true
		result.SomeVal = cmd.String("some-val")
	}
	if !hasValues {
		return nil, nil
	}
	return &result, nil
}
