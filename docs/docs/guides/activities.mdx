import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Activities

Activities are implemented as methods on a Go `struct` that satisfies the generated `<Service>Activities` interface type generated by this plugin

<Tabs>
<TabItem value="implementation-go" label="Go">
```go title="main.go"
package main

import (
    "context"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/client"
    "go.temporal.io/sdk/worker"
)

type Activities struct {}

func (a *Activities) Hello(ctx context.Context, input *examplev1.HelloInput) (*examplev1.HelloOutput, error) {
    return &examplev1.HelloOutput{}, nil
}

func main() {
    c, _ := client.Dial(client.Options{})
    w := worker.New(c, examplev1.ExampleTaskQueue, worker.Options{})

    // Register all example.v1.Example activities with the worker
    examplev1.RegisterExampleActivities(w, &Activities{})
    w.Run(worker.InterruptCh())
}
```
</TabItem>
<TabItem value="implementation-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  option (temporal.v1.service).task_queue = "example-v1";

  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```
</TabItem>
</Tabs>

## Parameters

The signature of an activity method varies based on whether or not the activity definition specifies a non-empty input and/or output message type.

<Tabs>
<TabItem value="parameters-both" label="Input & Output Parameters">

Most activities should specify both an input and output message type, even if the type is empty. This to support the addition of fields to either the input or output (or both) in the future without needing to introduce a breaking change.

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```

```go title="main.go"
package main

import (
    "context"

    examplev1 "path/to/gen/example/v1"
)

type Activities struct {}

func (a *Activities) Hello(ctx context.Context, input *examplev1.HelloInput) (*examplev1.HelloOutput, error) {
    return &examplev1.HelloOutput{}, nil
}
```

</TabItem>
<TabItem value="parameters-input" label="No Output Parameter">

An Activity output can be omitted using the native [google.protobuf.Empty](https://protobuf.dev/reference/protobuf/google.protobuf/#empty) type. This modifies the signature of the Activity method to have a single return value of type `error`. Note that this also requires an additional `google/protobuf/empty.proto` protobuf import statement.

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "google/protobuf/empty.proto";
import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (google.protobuf.Empty) {
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```

```go title="main.go"
package main

import (
    "context"

    examplev1 "path/to/gen/example/v1"
)

type Activities struct {}

func (a *Activities) Hello(ctx context.Context, input *examplev1.HelloInput) error {
    return nil
}
```

</TabItem>
<TabItem value="parameters-output" label="No Input Parameter">

An Activity input can be omitted using the native [google.protobuf.Empty](https://protobuf.dev/reference/protobuf/google.protobuf/#empty) type. This modifies the signature of the Activity method to have a single input argument of type `context.Context`. Note that this also requires an additional `google/protobuf/empty.proto` protobuf import statement.

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "google/protobuf/empty.proto";
import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(google.protobuf.Empty) returns (HelloOutput) {
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```

```go title="main.go"
package main

import (
    "context"

    examplev1 "path/to/gen/example/v1"
)

type Activities struct {}

func (a *Activities) Hello(ctx context.Context) (*examplev1.HelloOutput, error) {
    return &examplev1.HelloOutput{}, nil
}
```

</TabItem>
<TabItem value="parameters-none" label="No Parameters">

An Activity can omit both input and output parameters using the native [google.protobuf.Empty](https://protobuf.dev/reference/protobuf/google.protobuf/#empty) type. This modifies the signature of the Activity method to accept a single argument of type `context.Context` and return a single value of type `error`. Note that this also requires an additional `google/protobuf/empty.proto` protobuf import statement.

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "google/protobuf/empty.proto";
import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(google.protobuf.Empty) returns (google.protobuf.Empty) {
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```

```go title="main.go"
package main

import (
    "context"

    examplev1 "path/to/gen/example/v1"
)

type Activities struct {}

func (a *Activities) Hello(ctx context.Context) error {
    return nil
}
```

</TabItem>
</Tabs>

## Registration

The plugin generates helpers for registering your activities with a Temporal worker.

<Tabs>
<TabItem value="registration-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "log"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/client"
    "go.temporal.io/sdk/worker"
)

type Activities struct {}

func (a *Activities) Hello(ctx context.Context, input *examplev1.HelloInput) (*examplev1.HelloOutput, error) {
    return &examplev1.HelloOutput{}, nil
}

func main() {
    // initialize temporal client and worker
    c, _ := client.Dial(client.Options{})
    w := worker.New(c, examplev1.ExampleTaskQueue, worker.Options{})

    // Register all example.v1.Example activities with the worker
    examplev1.RegisterExampleActivities(w, &Activities{})
    w.Run(worker.InterruptCh())
}
```

</TabItem>
<TabItem value="registration-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  };

  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```
</TabItem>
</Tabs>

## Single Activity Workflows (Tasks)

For convenience, it's possible to define a workflow and activity using the same RPC method.

<Tabs>
<TabItem value="implementation-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
    option (temporal.v1.activity) = {
      start_to_close_timeout: { seconds: 60 }
    };
  }
}
```
</TabItem>
<TabItem value="implementation-go" label="Go">
```go title="main.go"
package main

import (
    "context"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    HelloWorkflow struct {
        *examplev1.HelloWorkflowInput
    }
)

func (w *Workflows) Hello(ctx workflow.Context, input  *examplev1.HelloWorkflowInput) (examplev1.HelloWorkflow, error) {
    return &HelloWorkflow{input}, nil
}

func (w *HelloWorkflow) Execute(ctx workflow.Context) (*examplev1.HelloOutput, error) {
    workflow.GetLogger(ctx).Info("executing hello workflow", "input", w.Req)
    return examplev1.Hello(ctx, w.Req)
}

func (a *Activities) Hello(ctx context.Context, input *examplev1.HelloInput) (*examplev1.HelloOutput, error) {
    activity.GetLogger(ctx).Info("executing hello activity", "input", input)
    return &examplev1.HelloOutput{}, nil
}
```
</TabItem>
</Tabs>

## Invocation

### Synchronous

The plugin generates typed helpers for executing activities synchronously with the appropriate [workflow.ActivityOptions](https://pkg.go.dev/go.temporal.io/sdk/workflow#ActivityOptions) derived from the defaults defined in the schema. These options can be overridden on a per-invocation basis by providing an optional [ActivityOptions](#options) argument as the final argument to the function

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    bar, err := examplev1.Bar(ctx, &examplev1.BarInput{})
    if err != nil {
        return nil, fmt.Errorf("Bar activity error: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

### Asynchronous

The plugin generates typed helpers for executing activities asynchronously with the appropriate [workflow.ActivityOptions](https://pkg.go.dev/go.temporal.io/sdk/workflow#ActivityOptions) derived from the defaults defined in the schema. These helpers start the activity and return a [Future](#future). Like their synchronous counterparts, these options can be overridden on a per-invocation basis by providing an optional [ActivityOptions](#options) argument as the final argument to the function

<Tabs>
<TabItem value="asynchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    f, err := examplev1.BarAsync(ctx, &examplev1.BarInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting Bar activity: %w", err)
    }

    bar, err := f.Get(ctx)
    if err != nil {
        return nil, fmt.Errorf("Bar activity error: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="asynchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

### Local

The plugin generates typed helpers for executing activities locally (both synchronously and asynchronously) with the appropriate [workflow.LocalActivityOptions](https://pkg.go.dev/go.temporal.io/sdk/workflow#LocalActivityOptions) derived from the defaults defined in the schema. These options can be overridden on a per-invocation basis by providing an optional [LocalActivityOptions](#local-options) argument as the final argument to the function.

<Tabs>
<TabItem value="local-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    bar, err := examplev1.BarLocal(ctx, &examplev1.BarInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting local Bar activity: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar local activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="local-custom" label="Go (Custom)">

It's possible to override a local activity execution definition using the [Local](#local) local activity option.

```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    bar, err := examplev1.BarLocal(ctx, &examplev1.BarInput{}, examplev1.NewBarLocalActivityOptions().
        Local(func(ctx context.Context, input *BarInput) (*BarOutput, error) {
            activity.GetLogger(ctx).Info("executing custom Bar local activity", "input", input)
            return &examplev1.BarOutput{}, nil
        }),
    )
    if err != nil {
        return nil, fmt.Errorf("error starting local Bar activity: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar local activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="local-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

## Future

For each Activity, a corresponding `<Activity>Future` struct is generated with methods for conveniently interacting with the activity execution that wraps the underlying [workflow.Future](https://pkg.go.dev/go.temporal.io/sdk/workflow#Future) returned by the SDK. All asynchronous activity helpers return this value.

### Get

Blocks until the activity completes, returning the activity output or error.

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    f, err := examplev1.BarAsync(ctx, &examplev1.BarInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting Bar activity: %w", err)
    }

    bar, err := f.Get(ctx)
    if err != nil {
        return nil, fmt.Errorf("Bar activity error: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

### Select

Registers activity completion callback on the given selector.

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    barF, err := examplev1.BarAsync(ctx, &examplev1.BarInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting Bar activity: %w", err)
    }

    bazF, err := examplev1.BazAsync(ctx &examplev1.BazInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting Baz activity: %w", err)
    }

    sel := workflow.NewSelect(ctx)
    barF.Select(sel, func(bar *BarOutput) {
        workflow.GetLogger(ctx).Info("Bar activity success", "bar", bar)
    })
    bazF.Select(sel, func(baz *BazOutput) {
        workflow.GetLogger(ctx).Info("Baz activity success", "baz", baz)
    })
    sel.Select(ctx)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}

func (a *Activities) Baz(ctx context.Context, input *examplev1.BazInput) (*examplev1.BazOutput, error) {
    activity.GetLogger(ctx).Info("executing Baz activity", "input", input)
    return &examplev1.BazOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }

  rpc Baz(BazInput) returns (BazOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

### Future

[workflow.Future](https://pkg.go.dev/go.temporal.io/sdk/workflow#Future)

In addition to the methods, the underlying Future is available via the public `Future` field.

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    barF, err := examplev1.BarAsync(ctx, &examplev1.BarInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting Bar activity: %w", err)
    }

    bazF, err := examplev1.BazAsync(ctx &examplev1.BazInput{})
    if err != nil {
        return nil, fmt.Errorf("error starting Baz activity: %w", err)
    }

    sel := workflow.NewSelect(ctx).
        AddFuture(barF.Future, func(workflow.Future) {
            bar, _ := barF.Get(ctx)
            workflow.GetLogger(ctx).Info("Bar activity success", "bar", bar)
        }).
        AddFuture(bazF.Future, func(workflow.Future) {
            baz, _ := barF.Get(ctx)
            workflow.GetLogger(ctx).Info("Baz activity success", "baz", baz)
        }).
        Select(ctx)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}

func (a *Activities) Baz(ctx context.Context, input *examplev1.BazInput) (*examplev1.BazOutput, error) {
    activity.GetLogger(ctx).Info("executing Baz activity", "input", input)
    return &examplev1.BazOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }

  rpc Baz(BazInput) returns (BazOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

## Options

Both synchronous and asynchronous activity helpers accept an optional `<Activity>ActivityOptions` value as the final argument. This argument can be used to override the default [workflow.ActivityOptions](https://pkg.go.dev/go.temporal.io/sdk/workflow#ActivityOptions) created using the defaults defined in the schema.

### WithActivityOptions

:::warning
It is currently not possible to override certain scalar options with a empty/falsey value if the schema defines a non-empty/non-falsey value. This may be addressed in a future release.
:::

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"
    "time"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    bar, err := examplev1.Bar(ctx, &examplev1.BarInput{}, examplev1.NewBarActivityOptions().
        WithActivityOptions(workflow.ActivityOptions{
            ScheduleToCloseTimeout: time.Minute, // this overrides the 30s default defined in the schema
        }),
    )
    if err != nil {
        return nil, fmt.Errorf("Bar activity error: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>

## Local Options

Both synchronous and asynchronous local activity helpers accept an optional `<Activity>LocalActivityOptions` value as the final argument. This argument can be used to override the default [workflow.LocalActivityOptions](https://pkg.go.dev/go.temporal.io/sdk/workflow#LocalActivityOptions) created using the defaults defined in the schema.

### Local

Override the local activity with a caller-defined implementation.

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"
    "time"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    bar, err := examplev1.BarLocal(ctx, &examplev1.BarInput{}, examplev1.NewBarLocalActivityOptions().
        Local(func(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
            activity.GetLogger(ctx).Info("executing custom Bar activity", "input", input)
            return &examplev1.BarOutput{}, nil
        }),
    )
    if err != nil {
        return nil, fmt.Errorf("Bar local activity error: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar local activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>


### WithLocalActivityOptions

<Tabs>
<TabItem value="synchronous-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "fmt"
    "time"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/activity"
    "go.temporal.io/sdk/workflow"
)

type (
    Workflows struct {}

    Activities struct {}

    FooWorkflow struct {
        *examplev1.FooWorkflowInput
    }
)

func (w *Workflows) Foo(ctx workflow.Context, input  *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorkflow{input}, nil
}

func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    bar, err := examplev1.BarLocal(ctx, &examplev1.BarInput{}, examplev1.NewBarLocalActivityOptions().
        WithLocalActivityOptions(workflow.LocalActivityOptions{
            ScheduleToCloseTimeout: time.Minute, // this overrides the 30s default defined in the schema
        }),
    )
    if err != nil {
        return nil, fmt.Errorf("Bar local activity error: %w", err)
    }
    workflow.GetLogger(ctx).Info("Bar local activity success", "bar", bar)
    return &examplev1.FooOutput{}, nil
}

func (a *Activities) Bar(ctx context.Context, input *examplev1.BarInput) (*examplev1.BarOutput, error) {
    activity.GetLogger(ctx).Info("executing Bar activity", "input", input)
    return &examplev1.BarOutput{}, nil
}
```
</TabItem>
<TabItem value="synchronous-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.activity) = {
      schedule_to_close_timeout: { seconds: 30 }
    };
  }
}
```
</TabItem>
</Tabs>
