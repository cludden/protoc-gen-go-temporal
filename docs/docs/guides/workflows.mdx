import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Workflows

## Implementation

A workflow is implemented as a Go `struct` that:
- satisfies the generated `<Workflow>Workflow` interface type generated by the plugin
- embeds the generated `<Workflow>WorkflowInput` struct that contains the workflow input and any registered signals

<Tabs>
<TabItem value="implementation-workflow" label="Go">
```go title="example.go"
package example

import (
    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/workflow"
)

type HelloWorkflow struct {
    *examplev1.HelloWorkflowInput
}

func (w *HelloWorkflow) Execute(ctx workflow.Context) (*examplev1.HelloOutput, error) {
    workflow.GetLogger(ctx).Info("executing hello workflow", "input", w.Req)
    return &examplev1.HelloOutput{}, nil
}

// type assertion for illustrative purposes
var _ examplev1.HelloWorkflow = (*HelloWorkflow)(nil)
```
</TabItem>
<TabItem value="implementation-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>


### Parameters

Every `<Workflow>Workflow` interface includes an `Execute` method that defines the workflow entrypoint. The signature of this method varies based on whether or not the workflow specifies a non-empty output message type.

<Tabs>
<TabItem value="parameters-both" label="Input & Output Parameters">

:::tip
Most workflows should specify both an input and output message type, even if the type is empty. This to support the addition of fields to either the input or output (or both) in the future without needing to introduce a breaking change.
:::

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "temporal/v1/temporal.proto";

service Example {
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```

```go title="main.go"
package main

import (
    "fmt"

    examplev1 "path/to/gen/example/v1"
)

type HelloWorkflow struct {
    *examplev1.HelloWorkflowInput
}

func (w *HelloWorkflow) Execute(ctx workflow.Context) (*examplev1.HelloOutput, error) {
    return &examplev1.HelloOutput{
        Result: fmt.Sprintf("Hello %s!", w.Req.GetName()),
    }, nil
}
```

</TabItem>
<TabItem value="parameters-input" label="No Output Parameter">

A workflow output can be omitted using the native [google.protobuf.Empty](https://protobuf.dev/reference/protobuf/google.protobuf/#empty) type. This modifies the signature of the workflow's `Execute` method to have a single return value of type `error`. Note that this also requires an additional `google/protobuf/empty.proto` protobuf import statement.

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "google/protobuf/empty.proto";
import "temporal/v1/temporal.proto";

service Example {
  rpc Hello(HelloInput) returns (google.protobuf.Empty) {
    option (temporal.v1.workflow) = {};
  }
}
```

```go title="main.go"
package main

import (
    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/workflow"
)

type HelloWorkflow struct {
    *examplev1.HelloWorkflowInput
}

func (w *HelloWorkflow) Execute(ctx workflow.Context) error {
    workflow.GetLogger(ctx).Info("hello!", "name", w.Req.GetName())
    return nil
}
```

</TabItem>
<TabItem value="parameters-output" label="No Input Parameter">

A workflow input can be omitted using the native [google.protobuf.Empty](https://protobuf.dev/reference/protobuf/google.protobuf/#empty) type. This does not modify the signature of the workflow's `Execute` method, but does omit the `Req` field from the workflow input structure. Note that this also requires an additional `google/protobuf/empty.proto` protobuf import statement.

```protobuf title="example.proto"
syntax="proto3";

package example.v1;

import "google/protobuf/empty.proto";
import "temporal/v1/temporal.proto";

service Example {
  // Hello returns a friendly greeting
  rpc Hello(google.protobuf.Empty) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```

```go title="main.go"
package main

import (
    "fmt"

    examplev1 "path/to/gen/example/v1"
)

type HelloWorkflow struct {
    *examplev1.HelloWorkflowInput
}

func (w *HelloWorkflow) Execute(ctx workflow.Context) (*examplev1.HelloOutput, error) {
    return &examplev1.HelloOutput{
        Result: fmt.Sprintf("Hello World!"),
    }, nil
}
```

</TabItem>
</Tabs>

## Registration

The plugin generates helpers for registering your workflows with a Temporal worker. These helpers rely on user-defined constructor functions. There are two flavors of registration helpers, composite and individual.

### Composite

:::tip
The composite registration helper is the recommended approach for registrating workflows.
:::

Each protobuf service with Temporal workflow definitions generates a `Register<Service>Workflows` composite registration function that registers all service workflows defined on a given protobuf service. This function receives two inputs:
- a [worker.Registry](https://pkg.go.dev/go.temporal.io/sdk/worker#Registry) to register the Service workflows with
- a struct value implementing the `<Service>Workflows` interface generated by the plugin. The interface describes a struct with methods for each workflow that initialize a new workflow value for an individual execution.

<Tabs>
<TabItem value="go-registration-composite" label="Go">
```go title="main.go"
package main

import (
    "log"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/client"
    "go.temporal.io/sdk/worker"
)

// Workflows provides constructor methods for example.v1.Example workflows
type Workflows struct {}

// FooWorkflow implements an example.v1.Example.Foo workflow
type FooWorkflow struct {
    *examplev1.FooWorkflowInput
}

// Foo initializes a new examplev1.Workflow value
func (w *Workflows) Foo(ctx workflow.Context, input *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorld{input}, nil
}

// Execute defines the entrypoint to  an example.v1.Example.Foo workflow
func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    return &examplev1.FooOutput{}, nil
}

// BarWorkflow implements an example.v1.Example.Bar workflow
type BarWorkflow struct {
    *examplev1.BarWorkflowInput
}

// Bar initializes a new examplev1.Workflow value
func (w *Workflows) Bar(ctx workflow.Context, input *examplev1.BarWorkflowInput) (examplev1.BarWorkflow, error) {
    return &BarWorld{input}, nil
}

// Execute defines the entrypoint to  an example.v1.Example.Bar workflow
func (w *BarWorkflow) Execute(ctx workflow.Context) (*examplev1.BarOutput, error) {
    return &examplev1.BarOutput{}, nil
}

func main() {
    // initialize temporal client and worker
    c, err := client.Dial(client.Options{})
    if err != nil {
        log.Fatalf("error initializing client: %v", err)
    }
    w := worker.New(c, examplev1.ExampleTaskQueue, worker.Options{})

    // Register all example.v1.Example workflows with the worker
    examplev1.RegisterExampleWorkflows(w, &Workflows{})
    w.Run(worker.InterruptCh())
}
```
</TabItem>
<TabItem value="schema-registration-composite" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>

### Individual

Each workflow definitions generates a `Register<Workflow>Workflow` individual registration function. This function receives two inputs:
- a [worker.Worker](https://pkg.go.dev/go.temporal.io/sdk/worker#Worker) to register the workflow with
- a constructor function that receives as input the workflow execution context and generated workflow input and initializes a new workflow value for an individual execution

<Tabs>
<TabItem value="go-registration-individual" label="Go">
```go title="main.go"
package main

import (
    "log"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/client"
    "go.temporal.io/sdk/worker"
)

// FooWorkflow implements an example.v1.Example.Foo workflow
type FooWorkflow struct {
    *examplev1.FooWorkflowInput
}

// NewFooWorkflow initializes a new examplev1.Workflow value
func NewFooWorkflow(ctx workflow.Context, input *examplev1.FooWorkflowInput) (examplev1.FooWorkflow, error) {
    return &FooWorld{input}, nil
}

// Execute defines the entrypoint to  an example.v1.Example.Foo workflow
func (w *FooWorkflow) Execute(ctx workflow.Context) (*examplev1.FooOutput, error) {
    return &examplev1.FooOutput{}, nil
}

// BarWorkflow implements an example.v1.Example.Bar workflow
type BarWorkflow struct {
    *examplev1.BarWorkflowInput
}

// NewBarWorkflow initializes a new examplev1.Workflow value
func NewBarWorkflow(ctx workflow.Context, input *examplev1.BarWorkflowInput) (examplev1.BarWorkflow, error) {
    return &BarWorld{input}, nil
}

// Execute defines the entrypoint to  an example.v1.Example.Bar workflow
func (w *BarWorkflow) Execute(ctx workflow.Context) (*examplev1.BarOutput, error) {
    return &examplev1.BarOutput{}, nil
}

func main() {
    // initialize temporal client and worker
    c, err := client.Dial(client.Options{})
    if err != nil {
        log.Fatalf("error initializing client: %v", err)
    }
    w := worker.New(c, examplev1.ExampleTaskQueue, worker.Options{})

    // Register all example.v1.Example workflows individually
    examplev1.RegisterFooWorkflow(w, NewFooWorkflow)
    examplev1.RegisterBarWorkflow(w, NewBarWorkflow)
    w.Run(worker.InterruptCh())
}
```
</TabItem>
<TabItem value="schema-registration-individual" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  rpc Foo(FooInput) returns (FooOutput) {
    option (temporal.v1.workflow) = {};
  }

  rpc Bar(BarInput) returns (BarOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>

## Invocation

The plugin supports several methods for executing protobuf workflows, each of which is outlined in more detail below.

### Client

Consumers can utilize the generated Client to execute workflows from any Go application. See the [Clients guide](/docs/guides/clients) for more usage details.

<Tabs>
<TabItem value="client-go" label="Go">
```go title="main.go"
package main

import (
    "context"
    "log"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/client"
)

func main() {
    // initialize temporal client
    c, err := client.Dial(client.Options{})
    if err != nil {
        log.Fatalf("error initializing client: %v", err)
    }

    // initialize temporal protobuf client
    client := examplev1.NewExampleClient(c)

    // execute an example.v1.Example.Hello workflow and block until completion or non-retryable error
    out, err := client.Hello(context.Background(), &examplev1.HelloInput{})
    if err != nil {
        log.Fatalf("error executing example.v1.Example.Hello workflow: %v", err)
    }
}
```
</TabItem>
<TabItem value="client-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>


### Command Line Interface

Consumers can utilize the generated Command Line Interface as a standalone application for executing workflows. See the [CLI guide](/docs/guides/cli) for more usage details.

<Tabs>
<TabItem value="cli-shell" label="Shell">
```sh title="example -h"
NAME:
  example - an example temporal cli

USAGE:
  example [global options] command [command options] [arguments...]

COMMANDS:
  help, h  Shows a list of commands or help for one command
    WORKFLOWS:
      hello   Hello returns a friendly greeting
```

```sh title="example hello -h"
NAME:
  example hello - Hello returns a friendly greeting

USAGE:
  example hello [command options] [arguments...]

CATEGORY:
   WORKFLOWS

OPTIONS:
   --detach, -d                  run workflow in the background and print workflow and execution id (default: false)
   --help, -h                    show help
   --input-file value, -f value  path to json-formatted input file
   --task-queue value, -t value  task queue name (default: "example-v1") [$TEMPORAL_TASK_QUEUE_NAME, $TEMPORAL_TASK_QUEUE, $TASK_QUEUE_NAME, $TASK_QUEUE]

   INPUT

   --name value    Name specifies the subject to greet
```

```json title="example hello --name Temporal"
{
  "result": "Hello Temporal!"
}
```
</TabItem>
<TabItem value="cli-go" label="Go">
```go title="main.go"
package main

import (
    "log"
    "os"

    examplev1 "path/to/gen/example/v1"
)

func main() {
    app, err := examplev1.NewExampleCLI()
    if err != nil {
        log.Fatalf("error initializing cli: %v", err)
    }

    if err := app.Run(os.Args); err != nil {
        log.Fatal(err)
    }
}
```
</TabItem>
<TabItem value="cli-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  // Hello returns a friendly greeting
  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}

message HelloInput {
  // Name specifies the subject to greet
  string name = 1;
}

message HelloOutput {
  string result = 1;
}
```
</TabItem>
</Tabs>

### Child Workflows

Workflows can be executed as child workflows from other workflows in the same Temporal namespace. See the [Child Workflows guide](/docs/guides/child-workflows) for more usage details.

<Tabs>
<TabItem value="child-go" label="Go">
```go title="example.go"
package main

import (
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/workflow"
)

func MyWorkflow(ctx workflow.Context) error {
    out, err := examplev1.HelloChild(ctx, &examplev1.HelloInput{})
    if err != nil {
        return fmt.Errorf("error executing example.v1.Example.Hello child workflow: %w", err)
    }
    return nil
}
```
</TabItem>
<TabItem value="child-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>

### Cross-Namespace (XNS)

Workflows can be executed from other workflows in a different Temporal namespace or even an entirely separate Temporal cluster (e.g. on-prem to cloud). See the [Cross-Namespace guide](/docs/guides/xns) for more usage details.

<Tabs>
<TabItem value="xns-go" label="Go">
```go title="example.go"
package example

import (
    "fmt"

    examplev1 "path/to/gen/example/v1"
    "path/to/gen/example/v1/examplev1xns"
    "go.temporal.io/sdk/workflow"
)

func MyWorkflow(ctx workflow.Context) error {
    out, err := examplev1xns.Hello(ctx, &examplev1.HelloInput{})
    if err != nil {
        return fmt.Errorf("error executing example.v1.Example.Hello xns workflow: %w", err)
    }
    return nil
}
```
</TabItem>
<TabItem value="xns-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>

### Workflow Functions

Workflow definitions can be executed inline with another workflow definition.

<Tabs>
<TabItem value="wffn-go" label="Go">
```go title="main.go"
package main

import (
    examplev1 "path/to/gen/example/v1"
    "go.temporal.io/sdk/client"
    "go.temporal.io/sdk/worker"
    "go.temporal.io/sdk/workflow"
)

type ExampleWorkflows struct {}

type HelloWorkflow struct {
    *examplev1.HelloWorkflowInput
}

func (w *ExampleWorkflows) Hello(ctx workflow.Context, input *examplev1.HelloInput) (examplev1.HelloWorkflow, error) {
    return &HelloWorkflow{input}, nil
}

func (w *HelloWorkflow) Execute(ctx workflow.Context) error {
    workflow.GetLogger(ctx).Info("hello!", "name", w.Req.GetName())
    return nil
}

func MyWorkflow(ctx workflow.Context) error {
    // this is equivalent to calling Execute inline
    out, err := examplev1.HelloFunction(ctx, &examplev1.HelloInput{})
    if err != nil {
        return fmt.Errorf("error executing example.v1.Example.Hello inline: %w", err)
    }
    return nil
}

func main() {
    // initialize temporal client and worker
    c, err := client.Dial(client.Options{})
    if err != nil {
        log.Fatalf("error initializing client: %v", err)
    }
    w := worker.New(c, examplev1.ExampleTaskQueue, worker.Options{})

    // Register all example.v1.Example workflows with the worker
    examplev1.RegisterExampleWorkflows(w, &Workflows{})
    w.RegisterWorkflow(MyWorkflow)
    w.Run(worker.InterruptCh())
}
```
</TabItem>
<TabItem value="wffn-schema" label="Schema">
```protobuf title="example.proto"
syntax="proto3";

package example.v1;

service Example {
  option (temporal.v1.service) = {
    task_queue: "example-v1"
  }

  rpc Hello(HelloInput) returns (HelloOutput) {
    option (temporal.v1.workflow) = {};
  }
}
```
</TabItem>
</Tabs>

